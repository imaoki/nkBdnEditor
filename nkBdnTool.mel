/*! © 2024 imaoki | MIT License | https://github.com/imaoki */

// /////////////////////////////////////////////////////////////////////////////
// ボイラープレート
// /////////////////////////////////////////////////////////////////////////////
/*1.1.0:Assertion*/proc string assertTrue(int $a) {return ($a == true) ? "" : ("Assert: expected 1, got " + $a);}proc string assertFalse(int $a) {return ($a == false) ? "" : ("Assert: expected 0, got " + $a);}proc string assertFloatEqual(float $e, float $a, float $t) {return (`abs ($e - $a)` <= $t) ? "" : ("Assert: expected " + $e + ", got " + $a);}proc string assertFloatNotEqual(float $e, float $a, float $t) {return (`abs ($e - $a)` > $t) ? "" : ("Assert: expected " + $e + ", got " + $a);}proc string assertIntEqual(int $e, int $a) {return ($a == $e) ? "" : ("Assert: expected " + $e + ", got " + $a);}proc string assertIntNotEqual(int $e, int $a) {return ($a != $e) ? "" : ("Assert: expected " + $e + ", got " + $a);}proc string assertStringEqual(string $e, string $a) {return ($a == $e) ? "" : ("Assert: expected " + $e + ", got " + $a);}proc string assertStringNotEqual(string $e, string $a) {return ($a != $e) ? "" : ("Assert: expected " + $e + ", got " + $a);}proc string assertFloatArrayEqual(float $es[], float $as[], float $t) {int $numAs = `size $as`;int $isEqual = $numAs == `size $es`;if ($isEqual) {for ($i = 0; $i < $numAs; $i++) {$isEqual = `abs ($es[$i] - $as[$i])` <= $t;if (!$isEqual) break;}}return ($isEqual) ? "" : ("Assert: expected {" + floatArrayToString($es, ", ") + "}, got {" + floatArrayToString($as, ", ") + "}");}proc string assertIntArrayEqual(int $es[], int $as[]) {int $numAs = `size $as`;int $isEqual = $numAs == `size $es`;if ($isEqual) {for ($i = 0; $i < $numAs; $i++) {$isEqual = $as[$i] == $es[$i];if (!$isEqual) break;}}return ($isEqual) ? "" : ("Assert: expected {" + intArrayToString($es, ", ") + "}, got {" + intArrayToString($as, ", ") + "}");}proc string assertStringArrayEqual(string $es[], string $as[]) {int $numAs = `size $as`;int $isEqual = $numAs == `size $es`;if ($isEqual) {for ($i = 0; $i < $numAs; $i++) {$isEqual = $as[$i] == $es[$i];if (!$isEqual) break;}}return ($isEqual) ? "" : ("Assert: expected {" + stringArrayToString($es, ", ") + "}, got {" + stringArrayToString($as, ", ") + "}");}proc testNewScene() {file -f -new;}proc testOpenScene(string $filename) {file -f -op "v=0;"  -iv  -typ "mayaAscii" -pmt false -o $filename;}
/*1.13.0:Attribute*/proc int existsAttribute(string $node, string $attribute) {return (`objExists $node` && `attributeQuery -ex -n $node $attribute`);}proc string getAttributeType(string $node, string $attribute) {if (!existsAttribute($node, $attribute)) return "";return `getAttr -typ ($node + "." + $attribute)`;}proc int isAttributeType(string $node, string $attribute, string $type) {return (getAttributeType($node, $attribute) == $type);}proc int isIndependentAttribute(string $node, string $attribute) {return (existsAttribute($node, $attribute) && !`connectionInfo -id ($node + "." + $attribute)`);}proc int isAttributeLocked(string $node, string $attribute) {if (!existsAttribute($node, $attribute)) return true;return `getAttr -l ($node + "." + $attribute)`;}proc setAttributeLock(string $node, string $attribute, int $state) {if (!existsAttribute($node, $attribute)) return;setAttr -l $state ($node + "." + $attribute);}proc batchSetAttributeLock(string $nodes[], string $attributes[], int $state) {for ($n in $nodes) {for ($attribute in $attributes) {setAttributeLock($n, $attribute, $state);}}}proc int isAttributeKeyable(string $node, string $attribute) {if (!existsAttribute($node, $attribute)) return false;return `getAttr -k ($node + "." + $attribute)`;}proc setAttributeKeyable(string $node, string $attribute, int $state) {if (!existsAttribute($node, $attribute)) return;setAttr -k $state ($node + "." + $attribute);}proc batchSetAttributeKeyable(string $nodes[], string $attributes[], int $state) {for ($n in $nodes) {for ($attribute in $attributes) {setAttributeKeyable($n, $attribute, $state);}}}proc int isAttributeChannelBox(string $node, string $attribute) {if (!existsAttribute($node, $attribute)) return false;return `getAttr -cb ($node + "." + $attribute)`;}proc setAttributeChannelBox(string $node, string $attribute, int $state) {if (!existsAttribute($node, $attribute)) return;if (!$state) {setAttributeKeyable($node, $attribute, $state);}setAttr -cb $state ($node + "." + $attribute);}proc batchSetAttributeChannelBox(string $nodes[], string $attributes[], int $state) {for ($n in $nodes) {for ($attribute in $attributes) {setAttributeChannelBox($n, $attribute, $state);}}}proc string[] getEnumLabels(string $node, string $attribute) {string $labels[];if (!isAttributeType($node, $attribute, "enum")) return $labels;string $enumLabels[] = `attributeQuery -le -n $node $attribute`;if (!(`size $enumLabels` && `size $enumLabels[0]`)) return $labels;tokenize $enumLabels[0] ":" $labels;if (`size $labels` == 1 && !`size $labels[0]`) clear $labels;return $labels;}proc string attributeNameInPascalCase(string $node, string $attribute) {string $pascalName;if (!existsAttribute($node, $attribute)) return $pascalName;$pascalName = `attributeName -n ($node + "." + $attribute)`;$pascalName = substituteAllString($pascalName, " ", "");return $pascalName;}proc int hasShapeTransformAttributes(string $n) {return (isAttributeType($n, "shapeTranslate", "double3") && isAttributeType($n, "shapeTranslateX", "doubleLinear") && isAttributeType($n, "shapeTranslateY", "doubleLinear") && isAttributeType($n, "shapeTranslateZ", "doubleLinear") && isAttributeType($n, "shapeRotate", "double3") && isAttributeType($n, "shapeRotateX", "doubleAngle") && isAttributeType($n, "shapeRotateY", "doubleAngle") && isAttributeType($n, "shapeRotateZ", "doubleAngle") && isAttributeType($n, "shapeScale", "double3") && isAttributeType($n, "shapeScaleX", "double") && isAttributeType($n, "shapeScaleY", "double") && isAttributeType($n, "shapeScaleZ", "double"));}proc addShapeTransformAttributes(string $n) {if (!`objExists $n` || hasShapeTransformAttributes($n)) return;addAttr -at "double3"      -k false -ln "shapeTranslate"  -sn "st" $n;addAttr -at "doubleLinear" -k false -ln "shapeTranslateX" -sn "stx" -p "shapeTranslate" $n;addAttr -at "doubleLinear" -k false -ln "shapeTranslateY" -sn "sty" -p "shapeTranslate" $n;addAttr -at "doubleLinear" -k false -ln "shapeTranslateZ" -sn "stz" -p "shapeTranslate" $n;addAttr -at "double3"      -k false -ln "shapeRotate"     -sn "sr" $n;addAttr -at "doubleAngle"  -k false -ln "shapeRotateX"    -sn "srx" -p "shapeRotate" $n;addAttr -at "doubleAngle"  -k false -ln "shapeRotateY"    -sn "sry" -p "shapeRotate" $n;addAttr -at "doubleAngle"  -k false -ln "shapeRotateZ"    -sn "srz" -p "shapeRotate" $n;addAttr -at "double3"      -k false -ln "shapeScale"      -sn "ss" $n;addAttr -at "double"       -k false -ln "shapeScaleX"     -sn "ssx" -p "shapeScale" $n;addAttr -at "double"       -k false -ln "shapeScaleY"     -sn "ssy" -p "shapeScale" $n;addAttr -at "double"       -k false -ln "shapeScaleZ"     -sn "ssz" -p "shapeScale" $n;setAttr ($n + ".ss") -typ "double3" 1.0 1.0 1.0;}proc int hasCurveNameAttribute(string $n) {return isAttributeType($n, "curveName", "string");}proc addCurveNameAttribute(string $n) {if (!`objExists $n` || hasCurveNameAttribute($n)) return;addAttr -dt "string" -ln "curveName" -sn "cn" $n;}proc float getFloatAttribute(string $node, string $attribute, float $default) {if (!existsAttribute($node, $attribute)) return $default;return `getAttr ($node + "." + $attribute)`;}proc setFloatAttribute(string $node, string $attribute, float $value) {if (!isIndependentAttribute($node, $attribute)) return;if (`attributeQuery -mxe -n $node $attribute`) {float $max[] = `attributeQuery -max -n $node $attribute`;if ($value > $max[0]) $value = $max[0];}if (`attributeQuery -mne -n $node $attribute`) {float $min[] = `attributeQuery -min -n $node $attribute`;if ($value < $min[0]) $value = $min[0];}setAttr ($node + "." + $attribute) $value;}proc batchSetFloatAttribute(string $nodes[], string $attribute, float $value) {for ($n in $nodes) {setFloatAttribute($n, $attribute, $value);}}proc float[] getFloat3Attribute(string $node, string $attribute, float $defaults[]) {if (!existsAttribute($node, $attribute)) return $defaults;return `getAttr ($node + "." + $attribute)`;}proc setFloat3Attribute(string $node, string $attribute, float $values[]) {if (!isIndependentAttribute($node, $attribute) || `size $values` != 3) return;if (`attributeQuery -mxe -n $node $attribute`) {float $max[] = `attributeQuery -max -n $node $attribute`;if ($values[0] > $max[0]) $values[0] = $max[0];if ($values[1] > $max[1]) $values[1] = $max[1];if ($values[2] > $max[2]) $values[2] = $max[2];}if (`attributeQuery -mne -n $node $attribute`) {float $min[] = `attributeQuery -min -n $node $attribute`;if ($values[0] < $min[0]) $values[0] = $min[0];if ($values[1] < $min[1]) $values[1] = $min[1];if ($values[2] < $min[2]) $values[2] = $min[2];}setAttr ($node + "." + $attribute) $values[0] $values[1] $values[2];}proc batchSetFloat3Attribute(string $nodes[], string $attribute, float $values[]) {for ($n in $nodes) {setFloat3Attribute($n, $attribute, $values);}}proc int getIntAttribute(string $node, string $attribute, int $default) {if (!existsAttribute($node, $attribute)) return $default;return `getAttr ($node + "." + $attribute)`;}proc setIntAttribute(string $node, string $attribute, int $value) {if (!isIndependentAttribute($node, $attribute)) return;if (`attributeQuery -mxe -n $node $attribute`) {float $max[] = `attributeQuery -max -n $node $attribute`;if ($value > $max[0]) $value = (int) $max[0];}if (`attributeQuery -mne -n $node $attribute`) {float $min[] = `attributeQuery -min -n $node $attribute`;if ($value < $min[0]) $value = (int) $min[0];}setAttr ($node + "." + $attribute) $value;}proc batchSetIntAttribute(string $nodes[], string $attribute, int $value) {for ($n in $nodes) {setIntAttribute($n, $attribute, $value);}}proc int[] getInt3Attribute(string $node, string $attribute, int $defaults[]) {if (!existsAttribute($node, $attribute)) return $defaults;return `getAttr ($node + "." + $attribute)`;}proc setInt3Attribute(string $node, string $attribute, int $values[]) {if (!isIndependentAttribute($node, $attribute) || `size $values` != 3) return;if (`attributeQuery -mxe -n $node $attribute`) {float $max[] = `attributeQuery -max -n $node $attribute`;if ($values[0] > $max[0]) $values[0] = (int) $max[0];if ($values[1] > $max[1]) $values[1] = (int) $max[1];if ($values[2] > $max[2]) $values[2] = (int) $max[2];}if (`attributeQuery -mne -n $node $attribute`) {float $min[] = `attributeQuery -min -n $node $attribute`;if ($values[0] < $min[0]) $values[0] = (int) $min[0];if ($values[1] < $min[1]) $values[1] = (int) $min[1];if ($values[2] < $min[2]) $values[2] = (int) $min[2];}setAttr ($node + "." + $attribute) $values[0] $values[1] $values[2];}proc batchSetInt3Attribute(string $nodes[], string $attribute, int $values[]) {for ($n in $nodes) {setInt3Attribute($n, $attribute, $values);}}proc string getStringAttribute(string $node, string $attribute, string $default) {string $value = $default;if (!existsAttribute($node, $attribute)) return $value;$value = `getAttr ($node + "." + $attribute)`;if (!`size $value`) $value = "";return $value;}proc setStringAttribute(string $node, string $attribute, string $value) {if (!isIndependentAttribute($node, $attribute)) return;setAttr ($node + "." + $attribute) -typ "string" $value;}proc batchSetStringAttribute(string $nodes[], string $attribute, string $value) {for ($n in $nodes) {setStringAttribute($n, $attribute, $value);}}proc string[] getSourceConnections(string $n,string $attributes[],string $type,string $sourceAttributes[],string $targetAttributes[]) {string $sourceNodes[];clear $sourceAttributes;clear $targetAttributes;if (!`objExists $n`) return $sourceNodes;$n = longNameOf($n);int $typeFlag = `size $type` > 0;if (`size $attributes`) {for ($attribute in $attributes) {if (!existsAttribute($n, $attribute)) continue;string $destPath = $n + "." + $attribute;string $nodes[];if ($typeFlag) {$nodes = `listConnections -d false -p false -s true -t $type $destPath`;}else {$nodes = `listConnections -d false -p false -s true $destPath`;}$sourceNodes = stringArrayCatenate($sourceNodes, $nodes);string $plugs[];if ($typeFlag) {$plugs = `listConnections -d false -p true -s true -t $type $destPath`;}else {$plugs = `listConnections -d false -p true -s true $destPath`;}$plugs = stringArrayRemoveDuplicates($plugs);for ($plug in $plugs) {string $buffer[];if (`tokenize $plug "." $buffer` != 2) continue;string $sourcePath = longNameOf($buffer[0]) + "." + $buffer[1];$sourceAttributes[`size $sourceAttributes`] = $sourcePath;$targetAttributes[`size $targetAttributes`] = $destPath;}}}else {string $plugs[];if ($typeFlag) {$sourceNodes = `listConnections -d false -p false -s true -t $type $n`;$plugs = `listConnections -d false -p true -s true -t $type $n`;}else {$sourceNodes = `listConnections -d false -p false -s true $n`;$plugs = `listConnections -d false -p true -s true $n`;}$plugs = stringArrayRemoveDuplicates($plugs);for ($plug in $plugs) {string $buffer[];if (`tokenize $plug "." $buffer` != 2) continue;string $sourcePath = longNameOf($buffer[0]) + "." + $buffer[1];string $targetPlugs[] = `listConnections -d true -p true -s false $sourcePath`;$targetPlugs = stringArrayRemoveDuplicates($targetPlugs);for ($targetPlug in $targetPlugs) {string $targetBuffer[];if (`tokenize $targetPlug "." $targetBuffer` != 2) continue;string $targetNode = longNameOf($targetBuffer[0]);if ($targetNode != $n) continue;string $destPath = $targetNode + "." + $targetBuffer[1];$sourceAttributes[`size $sourceAttributes`] = $sourcePath;$targetAttributes[`size $targetAttributes`] = $destPath;}}}$sourceNodes = stringArrayRemoveDuplicates($sourceNodes);for ($i = 0; $i < `size $sourceNodes`; $i++) {$sourceNodes[$i] = longNameOf($sourceNodes[$i]);}return $sourceNodes;}proc string[] getDestConnections(string $n,string $attributes[],string $type,string $sourceAttributes[],string $targetAttributes[]) {string $destNodes[];clear $sourceAttributes;clear $targetAttributes;if (!`objExists $n`) return $destNodes;$n = longNameOf($n);int $typeFlag = `size $type` > 0;if (`size $attributes`) {for ($attribute in $attributes) {if (!existsAttribute($n, $attribute)) continue;string $sourcePath = $n + "." + $attribute;string $nodes[];if ($typeFlag) {$nodes = `listConnections -d true -p false -s false -t $type $sourcePath`;}else {$nodes = `listConnections -d true -p false -s false $sourcePath`;}$destNodes = stringArrayCatenate($destNodes, $nodes);string $plugs[];if ($typeFlag) {$plugs = `listConnections -d true -p true -s false -t $type $sourcePath`;}else {$plugs = `listConnections -d true -p true -s false $sourcePath`;}$plugs = stringArrayRemoveDuplicates($plugs);for ($plug in $plugs) {string $buffer[];if (`tokenize $plug "." $buffer` != 2) continue;string $destPath = longNameOf($buffer[0]) + "." + $buffer[1];$sourceAttributes[`size $sourceAttributes`] = $sourcePath;$targetAttributes[`size $targetAttributes`] = $destPath;}}}else {string $plugs[];if ($typeFlag) {$destNodes = `listConnections -d true -p false -s false -t $type $n`;$plugs = `listConnections -d true -p true -s false -t $type $n`;}else {$destNodes = `listConnections -d true -p false -s false $n`;$plugs = `listConnections -d true -p true -s false $n`;}$plugs = stringArrayRemoveDuplicates($plugs);for ($plug in $plugs) {string $buffer[];if (`tokenize $plug "." $buffer` != 2) continue;string $destPath = longNameOf($buffer[0]) + "." + $buffer[1];string $sourcePlugs[] = `listConnections -d false -p true -s true $destPath`;$sourcePlugs = stringArrayRemoveDuplicates($sourcePlugs);for ($sourcePlug in $sourcePlugs) {string $sourceBuffer[];if (`tokenize $sourcePlug "." $sourceBuffer` != 2) continue;string $sourceNode = longNameOf($sourceBuffer[0]);if ($sourceNode != $n) continue;string $sourcePath = $sourceNode + "." + $sourceBuffer[1];$sourceAttributes[`size $sourceAttributes`] = $sourcePath;$targetAttributes[`size $targetAttributes`] = $destPath;}}}$destNodes = stringArrayRemoveDuplicates($destNodes);for ($i = 0; $i < `size $destNodes`; $i++) {$destNodes[$i] = longNameOf($destNodes[$i]);}return $destNodes;}proc connectAttributes(string $sourceAttributes[],string $targetAttributes[],int $force) {int $numAttributes = `size $sourceAttributes`;if (`size $targetAttributes` != $numAttributes) return;for ($i = 0; $i < $numAttributes; $i++) {string $sourceAttribute = $sourceAttributes[$i];string $targetAttribute = $targetAttributes[$i];if (`isConnected -iuc $sourceAttribute $targetAttribute`) continue;if ($force) {connectAttr -f $sourceAttribute $targetAttribute;}else {connectAttr $sourceAttribute $targetAttribute;}}}proc disconnectAttributes(string $sourceAttributes[],string $targetAttributes[]) {int $numAttributes = `size $sourceAttributes`;if (`size $targetAttributes` != $numAttributes) return;for ($i = 0; $i < $numAttributes; $i++) {string $sourceAttribute = $sourceAttributes[$i];string $targetAttribute = $targetAttributes[$i];if (!`isConnected -iuc $sourceAttribute $targetAttribute`) continue;disconnectAttr $sourceAttribute $targetAttribute;}}proc initializeRenderStats(string $nodes[]) {if (!`size $nodes`) return;for ($n in $nodes) {if (!`objExists $n`) continue;setIntAttribute($n, "castsShadows", true);setIntAttribute($n, "receiveShadows", true);setIntAttribute($n, "holdOut", false);setIntAttribute($n, "motionBlur", true);setIntAttribute($n, "primaryVisibility", true);setIntAttribute($n, "smoothShading", true);setIntAttribute($n, "visibleInReflections", true);setIntAttribute($n, "visibleInRefractions", true);setIntAttribute($n, "doubleSided", true);setIntAttribute($n, "opposite", false);setIntAttribute($n, "geometryAntialiasingOverride", false);setIntAttribute($n, "antialiasingLevel", 1);setIntAttribute($n, "shadingSamplesOverride", false);setIntAttribute($n, "shadingSamples", 1);setIntAttribute($n, "maxShadingSamples", 1);}}proc disableRenderStats(string $nodes[]) {if (!`size $nodes`) return;for ($n in $nodes) {if (!`objExists $n`) continue;setIntAttribute($n, "castsShadows", false);setIntAttribute($n, "receiveShadows", false);setIntAttribute($n, "holdOut", false);setIntAttribute($n, "motionBlur", false);setIntAttribute($n, "primaryVisibility", false);setIntAttribute($n, "smoothShading", false);setIntAttribute($n, "visibleInReflections", false);setIntAttribute($n, "visibleInRefractions", false);setIntAttribute($n, "doubleSided", false);setIntAttribute($n, "opposite", false);setIntAttribute($n, "geometryAntialiasingOverride", false);setIntAttribute($n, "shadingSamplesOverride", false);}}proc setOutlinerColor(string $nodes[], float $color[]) {if (!`size $nodes` || `size $color` != 3) return;for ($n in $nodes) {if (!`objExists $n`) continue;setIntAttribute($n, "uocol", true);setFloat3Attribute($n, "oclr", $color);}}proc setOverrideColor(string $nodes[], int $index) {if (!(0 <= $index && $index <= 31)) return;for ($n in $nodes) {if (!`objExists $n`) continue;setIntAttribute($n, "ove", true);setIntAttribute($n, "ovrgbf", 0);setIntAttribute($n, "ovc", $index);}}
/*1.18.0:Node*/proc int nodesExists(string $nodes[]) {int $numNodes = `size $nodes`;if (!$numNodes) return false;int $count;for ($n in $nodes) {if (`objExists $n`) $count += 1;}return ($count == $numNodes);}proc int isSelected(string $n) {if (!`objExists $n`) return false;string $nodes[] = `ls -l -sl $n`;return (`size $nodes` > 0);}proc string[] getShapeNodes(string $n, string $type) {if (!`objExists $n`) return {};if (`size $type`) {return `listRelatives -f -s -typ $type $n`;}else {return `listRelatives -f -s $n`;}}proc int isType(string $n, string $types[], int $isExact) {if (!`objExists $n`) return false;if (!`size $types`) return true;if ($isExact) {if (stringArrayContains(`nodeType $n`, $types)) return true;}else {string $subtypes[] = `nodeType -i $n`;for ($subtype in $subtypes) {if (stringArrayContains($subtype, $types)) return true;}}return false;}proc int hasType(string $n, string $types[], int $isExact) {if (isType($n, $types, $isExact)) return true;string $shapeNodes[] = getShapeNodes($n, "");for ($shapeNode in $shapeNodes) {if (isType($shapeNode, $types, $isExact)) return true;}return false;}proc int isTypeContains(string $nodes[], string $types[], int $isExact) {if (!`size $nodes`) return false;if (!`size $types`) return true;for ($n in $nodes) {if (isType($n, $types, $isExact)) return true;}return false;}proc int isNodeReferenced(string $n) {return (`objExists $n` && `referenceQuery -inr $n`);}proc int isConstraintNode(string $n) {return isType($n, {"constraint"}, false);}proc int isDagNode(string $n) {return isType($n, {"dagNode"}, false);}proc int isTransformNode(string $n) {return isType($n, {"transform"}, true);}proc int isJointNode(string $n) {return isType($n, {"joint"}, true);}proc int isShapeNode(string $n) {return isType($n, {"shape"}, false);}proc int isLocatorNode(string $n) {return isType($n, {"locator"}, true);}proc int hasLocatorNode(string $n) {return hasType($n, {"locator"}, true);}proc int isNurbsSurfaceNode(string $n) {return isType($n, {"nurbsSurface"}, true);}proc int hasNurbsSurfaceNode(string $n) {return hasType($n, {"nurbsSurface"}, true);}proc int isNurbsCurveNode(string $n) {return isType($n, {"nurbsCurve"}, true);}proc int hasNurbsCurveNode(string $n) {return hasType($n, {"nurbsCurve"}, true);}proc int isBezierCurveNode(string $n) {return isType($n, {"bezierCurve"}, true);}proc int hasBezierCurveNode(string $n) {return hasType($n, {"bezierCurve"}, true);}proc int isMeshNode(string $n) {return isType($n, {"mesh"}, true);}proc int hasMeshNode(string $n) {return hasType($n, {"mesh"}, true);}proc int isLightNode(string $n) {return isType($n, {"light"}, false);}proc int hasLightNode(string $n) {return hasType($n, {"light"}, false);}proc int isCameraNode(string $n) {return isType($n, {"camera"}, false);}proc int hasCameraNode(string $n) {return hasType($n, {"camera"}, false);}proc int isUUID(string $input) {string $hex = "[A-F0-9]";string $digit4 = $hex + $hex + $hex + $hex;string $digit8 = $digit4 + $digit4;string $digit12 = $digit8 + $digit4;return (isValidString($input,$digit8 + "-" + $digit4 + "-" + $digit4 + "-" + $digit4 + "-" + $digit12));}proc string toShortName(string $path) {string $shortName;if (!`size $path`) return $shortName;string $buffer1[];int $numBuffer1 = `tokenize $path "|" $buffer1`;if ($numBuffer1 > 0) {string $buffer2[];int $numBuffer2 = `tokenize $buffer1[$numBuffer1 - 1] ":" $buffer2`;if ($numBuffer2 > 0) {$shortName = $buffer2[$numBuffer2 - 1];}}return $shortName;}proc string toUUID(string $n) {string $uuid;if (!`objExists $n`) return $uuid;string $uuids[] = `ls -uid $n`;if (`size $uuids` == 1) $uuid = $uuids[0];return $uuid;}proc string uuidToLongName(string $uuid) {string $longName;if (!isUUID($uuid)) return $longName;string $longNames[] = `ls -l $uuid`;if (`size $longNames` == 1) $longName = $longNames[0];return $longName;}proc string setNodeName(string $n, string $name) {if (!`objExists $n` || !`size $name` || isNodeReferenced($n)) return "";string $nodeId = toUUID($n);$n = uuidToLongName($nodeId);rename $n $name;$n = uuidToLongName($nodeId);return $n;}proc string getParentNode(string $n) {if (!`objExists $n`) return "";string $parents[] = `listRelatives -f -p $n`;if (!`size $parents`) return "";return $parents[0];}proc string[] setParentNode(string $nodes[], string $parentNode) {int $toWorld = `size $parentNode` == 0;int $parentIsDagNode = isDagNode($parentNode);if (!$toWorld && !$parentIsDagNode) return $nodes;string $nodeIds[];string $dagNodes[];for ($n in $nodes) {$nodeIds[`size $nodeIds`] = toUUID($n);if (isDagNode($n) && !isNodeReferenced($n)) {$dagNodes[`size $dagNodes`] = $n;}}int $numDagNodes = `size $dagNodes`;if (!$numDagNodes) return $nodes;string $selectedNodes[] = `ls -l -sl`;string $selectedNodeIds[];for ($n in $selectedNodes) {$selectedNodeIds[`size $selectedNodeIds`] = toUUID($n);}if ($numDagNodes) {if ($toWorld) {parent -w $dagNodes;}else if ($parentIsDagNode) {parent -a $dagNodes $parentNode;}}string $newNodes[];for ($id in $nodeIds) {$newNodes[`size $newNodes`] = uuidToLongName($id);}string $newSelectedNodes[];for ($id in $selectedNodeIds) {$newSelectedNodes[`size $newSelectedNodes`] = uuidToLongName($id);}select -r $newSelectedNodes;return $newNodes;}proc string getRootNode(string $n) {string $rootNode;if (!`objExists $n`) return $rootNode;$rootNode = $n;string $parentNode = getParentNode($rootNode);while (`objExists $parentNode`) {$rootNode = $parentNode;$parentNode = getParentNode($rootNode);}return $rootNode;}proc string[] collectRootNodes(string $nodes[]) {string $rootNodes[];if (!`size $nodes`) return $rootNodes;for ($n in $nodes) {string $rootNode = getRootNode($n);if (`objExists $rootNode`) {$rootNodes[`size $rootNodes`] = $rootNode;}}$rootNodes = stringArrayRemoveDuplicates($rootNodes);return $rootNodes;}proc string[] collectChildNodes(string $n) {string $childNodes[];if (!`objExists $n`) return $childNodes;$childNodes = `listRelatives -f -c $n`;return $childNodes;}proc string[] collectDescendantNodes(string $n,string $parentNode,string $types[],int $isExact,string $script) {string $descendantNodes[];if (!`objExists $n`) return $descendantNodes;$n = longNameOf($n);$parentNode = longNameOf($parentNode);string $sourceNode = $n;string $nextNode = $sourceNode;if (`exists $script` && isType($sourceNode, $types, $isExact)) {string $arg1 = "\"" + toUUID($sourceNode) + "\"";string $arg2 = "\"" + toUUID($parentNode) + "\"";string $result[] = `eval $script $arg1 $arg2`;if (`size $result` == 2 && (!`size $result[0]` || isUUID($result[0])) && (!`size $result[1]` || isUUID($result[1]))) {$sourceNode = uuidToLongName($result[0]);$nextNode = uuidToLongName($result[1]);}}if (`objExists $sourceNode`) {$descendantNodes[`size $descendantNodes`] = $sourceNode;}string $childNodes[] = collectChildNodes($nextNode);for ($c in $childNodes) {$descendantNodes = stringArrayCatenate($descendantNodes,collectDescendantNodes($c, $sourceNode, $types, $isExact, $script));}if (`size $types`) {for ($i = `size $descendantNodes` - 1; $i >= 0; $i--) {if (!isType($descendantNodes[$i], $types, $isExact)) {stringArrayRemoveAtIndex($i, $descendantNodes);}}}return $descendantNodes;}proc string[] collectHierarchyNodes(string $nodes[],string $parentNode,string $types[],int $isExact,string $script) {string $hierarchyNodes[];if (!`size $nodes`) return $hierarchyNodes;string $rootNodes[] = collectRootNodes($nodes);for ($n in $rootNodes) {$hierarchyNodes = stringArrayCatenate($hierarchyNodes,collectDescendantNodes($n, $parentNode, $types, $isExact, $script));}$hierarchyNodes = stringArrayRemoveDuplicates($hierarchyNodes);return $hierarchyNodes;}proc string[] gatherNodes(string $types[],int $isExact,int $selectedOnly,string $pattern) {if (!`size $pattern`) $pattern = "*";string $nodes[];if (`size $types`) {for ($type in $types) {if ($selectedOnly) {if ($isExact) {$nodes = stringArrayCatenate($nodes, `ls -l -sl -et $type $pattern`);}else {$nodes = stringArrayCatenate($nodes, `ls -l -sl -typ $type $pattern`);}}else {if ($isExact) {$nodes = stringArrayCatenate($nodes, `ls -l -et $type $pattern`);}else {$nodes = stringArrayCatenate($nodes, `ls -l -typ $type $pattern`);}}}}else {if ($selectedOnly) {$nodes = `ls -l -sl $pattern`;}else {$nodes = `ls -l $pattern`;}}$nodes = stringArrayRemoveDuplicates($nodes);return $nodes;}proc string nodesAsCSV(string $types[],int $isExact,int $selectedOnly,string $pattern,int $singleNodeOnly) {string $nodes[] = gatherNodes($types, $isExact, $selectedOnly, $pattern);if (`size $nodes` > 1 && $singleNodeOnly) clear $nodes;return stringArrayToString($nodes, ",");}proc string[] csvAsNodes(string $input) {string $nodes[];tokenize $input "," $nodes;if (`size $nodes` == 1 && !`size $nodes[0]`) clear $nodes;return $nodes;}proc string[] getSourceConnectionNodes(string $nodes[],string $types[],int $isExact) {string $tmpNodes[];for ($n in $nodes) {if (!`objExists $n`) continue;$tmpNodes = stringArrayCatenate($tmpNodes,`listConnections -d false -p false -s true $n`);}$tmpNodes = stringArrayRemoveDuplicates($tmpNodes);string $sourceNodes[];for ($i = 0; $i < `size $tmpNodes`; $i++) {string $tmpNode = longNameOf($tmpNodes[$i]);if (isType($tmpNode, $types, $isExact)) {$sourceNodes[`size $sourceNodes`] = $tmpNode;}}$sourceNodes = `sort $sourceNodes`;return $sourceNodes;}proc string[] getDestConnectionNodes(string $nodes[],string $types[],int $isExact) {string $tmpNodes[];for ($n in $nodes) {if (!`objExists $n`) continue;$tmpNodes = stringArrayCatenate($tmpNodes,`listConnections -d true -p false -s false $n`);}$tmpNodes = stringArrayRemoveDuplicates($tmpNodes);string $destNodes[];for ($i = 0; $i < `size $tmpNodes`; $i++) {string $tmpNode = longNameOf($tmpNodes[$i]);if (isType($tmpNode, $types, $isExact)) {$destNodes[`size $destNodes`] = $tmpNode;}}$destNodes = `sort $destNodes`;return $destNodes;}proc string buildDagNode(string $n,string $name,string $parentNode,int $maintainOffset,string $matchTransformNode,int $matchFlags[]) {if (!isDagNode($n) || isNodeReferenced($n)) return $n;string $nodeId = toUUID($n);$n = uuidToLongName($nodeId);if (isDagNode($matchTransformNode)) {int $numMatchFlags = `size $matchFlags`;if (!`size $matchFlags`) {matchTransform $n $matchTransformNode;}else {if ($matchFlags[0]) matchTransform -pos $n $matchTransformNode;if ($matchFlags[1]) matchTransform -rot $n $matchTransformNode;if ($matchFlags[2]) matchTransform -scl $n $matchTransformNode;}}string $selection[] = `ls -l -sl`;int $shouldSelect = isSelected($n);if ($shouldSelect) {$selection = stringArrayRemove({$n}, $selection);}if (isDagNode($parentNode)) {if ($maintainOffset) {parent -a $n $parentNode;}else {parent -r $n $parentNode;}$n = uuidToLongName($nodeId);}if ($shouldSelect) {$selection[`size $selection`] = $n;}select -r $selection;if (`size $name`) {rename $n $name;$n = uuidToLongName($nodeId);}return $n;}proc string createJoint(string $name,string $parentNode,int $maintainOffset,string $matchTransformNode,int $matchFlags[]) {return (buildDagNode(longNameOf(`createNode -ss "joint"`),$name,$parentNode,$maintainOffset,$matchTransformNode,$matchFlags));}proc string createLocator(string $name,string $parentNode,int $maintainOffset,string $matchTransformNode,int $matchFlags[]) {return (buildDagNode(getParentNode(longNameOf(`createNode -ss "locator"`)),$name,$parentNode,$maintainOffset,$matchTransformNode,$matchFlags));}proc string createTransform(string $name,string $parentNode,int $maintainOffset,string $matchTransformNode,int $matchFlags[]) {return (buildDagNode(longNameOf(`createNode -ss "transform"`),$name,$parentNode,$maintainOffset,$matchTransformNode,$matchFlags));}proc string getTopLevelNode(string $topLevelName, int $shouldCreate) {string $n;if (!`size $topLevelName`) return "";string $nodes[] = `ls -l ("::" + $topLevelName)`;int $numNodes = `size $nodes`;if ($numNodes > 1) return "";$n = ($numNodes == 1) ? $nodes[0] : "";if (`objExists $n`) return $n;if ($shouldCreate) {$n = createTransform($topLevelName, "", true, "", {});}return $n;}proc string getSecondLevelNode(string $topLevelName,string $secondLevelName,int $shouldCreate) {string $n;if (!`size $topLevelName` || !`size $secondLevelName`) return "";string $nodes[] = `ls -l ("|::" + $topLevelName + "|::" + $secondLevelName)`;int $numNodes = `size $nodes`;if ($numNodes > 1) return "";$n = ($numNodes == 1) ? $nodes[0] : "";if (`objExists $n`) return $n;if ($shouldCreate) {string $topLevelNode = getTopLevelNode($topLevelName, $shouldCreate);if (!`objExists $topLevelNode`) return "";$n = createTransform($secondLevelName, $topLevelNode, true, "", {});}return $n;}proc string getThirdLevelNode(string $topLevelName,string $secondLevelName,string $thirdLevelName,int $shouldCreate) {string $n;if ( !`size $topLevelName` || !`size $secondLevelName` || !`size $thirdLevelName`) return "";string $nodes[] = `ls -l ("|::" + $topLevelName + "|::" + $secondLevelName + "|::" + $thirdLevelName)`;int $numNodes = `size $nodes`;if ($numNodes > 1) return "";$n = ($numNodes == 1) ? $nodes[0] : "";if (`objExists $n`) return $n;if ($shouldCreate) {string $secondLevelNode = getSecondLevelNode($topLevelName,$secondLevelName,$shouldCreate);if (!`objExists $secondLevelNode`) return "";$n = createTransform($thirdLevelName, $secondLevelNode, true, "", {});}return $n;}proc freezeTransform(string $nodes[], int $preserveFlags[]) {string $dagNodes[];for ($n in $nodes) {if (isDagNode($n)) $dagNodes[`size $dagNodes`] = $n;}if (`size $dagNodes`) {makeIdentity -a true -n 0 -pn true -t (!$preserveFlags[0]) -r (!$preserveFlags[1]) -s (!$preserveFlags[2])$dagNodes;}}
/*1.5.0:String*/proc string escapeStringForLiteral(string $input) {string $escapedText;int $size = `size $input`;for ($i = 1; $i <= $size; $i++) {string $c = `substring $input $i $i`;switch ($c) {case "\"": $escapedText += "\\\""; break;case "\\": $escapedText += "\\\\"; break;case "\n": $escapedText += "\\n"; break;case "\r": $escapedText += "\\r"; break;case "\t": $escapedText += "\\t"; break;default: $escapedText += $c; break;}}return $escapedText;}proc string escapeStringForPythonAtString(string $input) {string $escapedText;int $size = `size $input`;for ($i = 1; $i <= $size; $i++) {string $c = `substring $input $i $i`;switch ($c) {case "\\": $escapedText += "\\\\"; break;case "'": $escapedText += "\\'"; break;case "\n": $escapedText += "\\n"; break;case "\r": $escapedText += "\\r"; break;default: $escapedText += $c; break;}}return $escapedText;}proc string booleanAsStringLiteral(int $value) {return (($value == 0) ? "false" : "true");}proc string floatAsStringLiteral(float $value) {string $literal = (string) $value;if (!`gmatch $literal "*e*"` && !`gmatch $literal "*.*"`) $literal += ".0";return $literal;}proc string intAsStringLiteral(int $value) {return ((string) $value);}proc string stringAsStringLiteral(string $value) {return ("\"" + escapeStringForLiteral($value) + "\"");}proc string booleanArrayAsStringLiteral(int $values[]) {string $stringValues[];for ($i = 0; $i < `size $values`; $i++) {$stringValues[$i] = booleanAsStringLiteral($values[$i]);}return ("{" + stringArrayToString($stringValues, ", ") + "}");}proc string floatArrayAsStringLiteral(float $values[]) {string $stringValues[];for ($i = 0; $i < `size $values`; $i++) {$stringValues[$i] = floatAsStringLiteral($values[$i]);}return ("{" + stringArrayToString($stringValues, ", ") + "}");}proc string intArrayAsStringLiteral(int $values[]) {return ("{" + intArrayToString($values, ", ") + "}");}proc string stringArrayAsStringLiteral(string $values[]) {string $stringValues[];for ($i = 0; $i < `size $values`; $i++) {$stringValues[$i] = stringAsStringLiteral($values[$i]);}return ("{" + stringArrayToString($stringValues, ", ") + "}");}proc string join(string $inputs[], string $separator, int $ignoreEmpty) {int $numInputs = `size $inputs`;if (!$numInputs || ($numInputs == 1 && !`size $inputs[0]`)) return "";if ($ignoreEmpty) {string $buffer[];for ($input in $inputs) {if (`size $input`) $buffer[`size $buffer`] = $input;}return stringArrayToString($buffer, $separator);}else {return stringArrayToString($inputs, $separator);}}proc string strip(string $input) {return `python("'" + escapeStringForPythonAtString($input) + "'.strip()")`;}proc string regexSearchGroup(string $pattern, string $input, string $flags) {$flags = (`size $flags`) ? "(?" + $flags + ")" : "";$pattern = "'" + $flags + escapeStringForPythonAtString($pattern) + "'";$input = "'" + escapeStringForPythonAtString($input) + "'";python("import re");string $result = `python("(lambda m: m.group() if m else None)(re.search(" + $pattern + ", " + $input + "))")`;return $result;}proc int[] regexSearchSpan(string $pattern, string $input, string $flags) {$flags = (`size $flags`) ? "(?" + $flags + ")" : "";$pattern = "'" + $flags + escapeStringForPythonAtString($pattern) + "'";$input = "'" + escapeStringForPythonAtString($input) + "'";python("import re");int $result[] = `python("(lambda m: m.span() if m else None)(re.search(" + $pattern + ", " + $input + "))")`;return $result;}proc string[] regexMatchGroups(string $pattern, string $input, string $flags) {$flags = (`size $flags`) ? "(?" + $flags + ")" : "";$pattern = "'" + $flags + escapeStringForPythonAtString($pattern) + "'";$input = "'" + escapeStringForPythonAtString($input) + "'";python("import re");string $result[] = `python("tuple([m.group() for m in re.finditer(" + $pattern + ", " + $input + ")])")`;return $result;}proc string[] regexMatchSubGroups(string $pattern, string $input, string $flags) {$flags = (`size $flags`) ? "(?" + $flags + ")" : "";$pattern = "'" + $flags + escapeStringForPythonAtString($pattern) + "'";$input = "'" + escapeStringForPythonAtString($input) + "'";python("import re");string $result[] = `python("sum([m.groups() for m in re.finditer(" + $pattern + ", " + $input + ")], ())")`;return $result;}proc int[] regexMatchSpans(string $pattern, string $input, string $flags) {$flags = (`size $flags`) ? "(?" + $flags + ")" : "";$pattern = "'" + $flags + escapeStringForPythonAtString($pattern) + "'";$input = "'" + escapeStringForPythonAtString($input) + "'";python("import re");int $result[] = `python("sum([m.span() for m in re.finditer(" + $pattern + ", " + $input + ")], ())")`;return $result;}proc int regexIsMatch(string $pattern, string $input, string $flags) {return (`size (regexSearchGroup($pattern, $input, $flags))` > 0);}proc string[] regexSplit(string $pattern, string $input, string $flags) {$flags = (`size $flags`) ? "(?" + $flags + ")" : "";$pattern = "'" + $flags + escapeStringForPythonAtString($pattern) + "'";$input = "'" + escapeStringForPythonAtString($input) + "'";python("import re");string $result[] = `python("tuple(re.split(" + $pattern + ", " + $input + "))")`;return $result;}proc string regexReplace(string $pattern,string $replacement,string $input,string $flags) {$flags = (`size $flags`) ? "(?" + $flags + ")" : "";$pattern = "'" + $flags + escapeStringForPythonAtString($pattern) + "'";$replacement = "'" + escapeStringForPythonAtString($replacement) + "'";$input = "'" + escapeStringForPythonAtString($input) + "'";python("import re");string $result = `python("re.sub(" + $pattern + ", " + $replacement + ", " + $input + ")")`;return $result;}proc string getClipboardText() {python("from PySide2 import QtGui");python("cb = QtGui.QClipboard()");return python("cb.text()");}proc setClipboardText(string $text) {python("from PySide2 import QtGui");python("cb = QtGui.QClipboard()");python("cb.setText('" + escapeStringForPythonAtString($text) + "')");}proc string dictSanitize(string $input) {string $pattern = "[=;]";if (regexIsMatch($pattern, $input, "")) {return regexReplace($pattern, "_", $input, "");}else {return $input;}}proc string[] dictSanitizeArray(string $input[]) {string $result[];for ($i = 0; $i < `size $input`; $i++) {$result[$i] = dictSanitize($input[$i]);}return $result;}proc string[] dictExtractItems(string $dict) {string $items[];string $buffer[] = regexSplit(";", $dict, "");for ($item in $buffer) {if (!`size $item`) continue;$items[`size $items`] = $item;}return $items;}proc int dictIsKeyEquals(string $item, string $key) {return (`size $key` && `gmatch $item ($key + "=*")`);}proc string dictExtractKey(string $item) {if (!`gmatch $item "?*=*"`) return "";return regexReplace("^([^=]+)=.*", "\\1", $item, "");}proc string dictExtractValue(string $item) {if (!`gmatch $item "?*=*"`) return "";return regexReplace("^[^=]+=", "", $item, "");}proc string dictGetValue(string $dict, string $key) {string $value;if (!`size $key`) return $value;string $items[] = dictExtractItems($dict);for ($item in $items) {if (dictIsKeyEquals($item, $key)) {$value = dictExtractValue($item);break;}}return $value;}proc string[] dictKeys(string $dict) {string $keys[];string $items[] = dictExtractItems($dict);for ($item in $items) {string $key = dictExtractKey($item);if (!`size $key`) continue;$keys[`size $keys`] = $key;}return $keys;}proc int dictContainsKey(string $dict, string $key) {if (!`size $key`) return false;string $keys[] = dictKeys($dict);return stringArrayContains($key, $keys);}proc string dictAddItem(string $dict, string $key, string $value) {if (!`size $key`) return $dict;string $newDict;int $isOverwrite;string $items[] = dictExtractItems($dict);for ($item in $items) {if (dictIsKeyEquals($item, $key)) {$isOverwrite = true;$newDict += $key + "=" + $value + ";";}else {$newDict += $item + ";";}}if (!$isOverwrite) {$newDict += $key + "=" + $value + ";";}return $newDict;}proc string dictAddBoolean(string $dict, string $key, int $value) {return dictAddItem($dict, dictSanitize($key), booleanAsStringLiteral($value));}proc string dictAddFloat(string $dict, string $key, float $value) {return dictAddItem($dict, dictSanitize($key), floatAsStringLiteral($value));}proc string dictAddInt(string $dict, string $key, int $value) {return dictAddItem($dict, dictSanitize($key), intAsStringLiteral($value));}proc string dictAddString(string $dict, string $key, string $value) {$value = dictSanitize($value);return dictAddItem($dict, dictSanitize($key), stringAsStringLiteral($value));}proc string dictAddBooleanArray(string $dict, string $key, int $value[]) {return dictAddItem($dict, dictSanitize($key), booleanArrayAsStringLiteral($value));}proc string dictAddFloatArray(string $dict, string $key, float $value[]) {return dictAddItem($dict, dictSanitize($key), floatArrayAsStringLiteral($value));}proc string dictAddIntArray(string $dict, string $key, int $value[]) {return dictAddItem($dict, dictSanitize($key), intArrayAsStringLiteral($value));}proc string dictAddStringArray(string $dict, string $key, string $value[]) {$value = dictSanitizeArray($value);return dictAddItem($dict, dictSanitize($key), stringArrayAsStringLiteral($value));}proc int dictGetBoolean(string $dict, string $key, int $default) {string $value = dictGetValue($dict, $key);if ($value == "true") {return true;}else if ($value == "false") {return false;}return $default;}proc float dictGetFloat(string $dict, string $key, float $default) {string $value = dictGetValue($dict, $key);if (`size $value`) return ((float) $value);return $default;}proc int dictGetInt(string $dict, string $key, int $default) {string $value = dictGetValue($dict, $key);if (`size $value`) return ((int) $value);return $default;}proc string dictGetString(string $dict, string $key, string $default) {string $value = dictGetValue($dict, $key);if (`size $value`) return `eval ("format -s " + $value + " \"^1s\";")`;return $default;}global int $dictBooleanArrayBuffer[];global float $dictFloatArrayBuffer[];global int $dictIntArrayBuffer[];global string $dictStringArrayBuffer[];proc int[] dictGetBooleanArray(string $dict, string $key, int $default[]) {global int $dictBooleanArrayBuffer[];clear $dictBooleanArrayBuffer;string $value = dictGetValue($dict, $key);if (`size $value`) {eval ("$dictBooleanArrayBuffer = " + $value + ";");return $dictBooleanArrayBuffer;}return $default;}proc float[] dictGetFloatArray(string $dict, string $key, float $default[]) {global float $dictFloatArrayBuffer[];clear $dictFloatArrayBuffer;string $value = dictGetValue($dict, $key);if (`size $value`) {eval ("$dictFloatArrayBuffer = " + $value + ";");return $dictFloatArrayBuffer;}return $default;}proc int[] dictGetIntArray(string $dict, string $key, int $default[]) {global int $dictIntArrayBuffer[];clear $dictIntArrayBuffer;string $value = dictGetValue($dict, $key);if (`size $value`) {eval ("$dictIntArrayBuffer = " + $value + ";");return $dictIntArrayBuffer;}return $default;}proc string[] dictGetStringArray(string $dict, string $key, string $default[]) {global string $dictStringArrayBuffer[];clear $dictStringArrayBuffer;string $value = dictGetValue($dict, $key);if (`size $value`) {eval ("$dictStringArrayBuffer = " + $value + ";");return $dictStringArrayBuffer;}return $default;}proc string dictRemove(string $dict, string $key) {if (!`size $key`) return $dict;string $newDict;string $items[] = dictExtractItems($dict);for ($item in $items) {string $itemKey = dictExtractKey($item);if ($itemKey == $key) continue;$newDict += $item + ";";}return $newDict;}
/*2.1.0:UIControl*/global string $nkUIControls[];proc appendUIControls(string $controls[]) {global string $nkUIControls[];for ($control in $controls) {$nkUIControls[`size $nkUIControls`] = $control;}}proc string getUIControl(string $root, string $end) {global string $nkUIControls[];string $path;for ($control in $nkUIControls) {string $buffer[];int $depth = `tokenize $control "|" $buffer`;string $first = ($depth > 0) ? $buffer[0] : "";string $last = ($depth > 0) ? $buffer[$depth - 1] : "";if ($first == $root && $last == $end) {$path = $control;break;}}return $path;}proc removeUIControls(string $root, string $end) {global string $nkUIControls[];string $paths[];for ($control in $nkUIControls) {string $buffer[];int $depth = `tokenize $control "|" $buffer`;string $first = ($depth > 0) ? $buffer[0] : "";string $last = ($depth > 0) ? $buffer[$depth - 1] : "";int $shouldRemove = (!`size $end`) ? $first == $root : $first == $root && $last == $end;if ($shouldRemove) $paths[`size $paths`] = $control;}if (`size $paths` > 0) {$nkUIControls = stringArrayRemove($paths, $nkUIControls);}}proc string uiControlTypeOf(string $control) {string $type = `objectTypeUI $control`;if ($type == "floatingWindow") $type = "window";return $type;}proc int qEnable(string $control) {string $type = uiControlTypeOf($control);if ($type == "window" || $type == "workspaceControl") return true;return `control -q -en $control`;}proc eEnable(int $bValue, string $control) {string $type = uiControlTypeOf($control);if ($type == "window" || $type == "workspaceControl") return;control -e -en $bValue $control;}proc int qExists(string $control) {return `control -q -ex $control`;}proc int qVisible(string $control) {return `control -q -vis $control`;}proc eVisible(int $bValue, string $control) {control -e -vis $bValue $control;}proc float qFloat(string $type, string $flag, string $control) {return `eval $type "-q" $flag $control`;}proc eFloat(string $type, string $flag, float $fValue, string $control) {eval $type "-e" $flag $fValue $control;}proc int qInt(string $type, string $flag, string $control) {return `eval $type "-q" $flag $control`;}proc eInt(string $type, string $flag, int $iValue, string $control) {eval $type "-e" $flag $iValue $control;}proc string qString(string $type, string $flag, string $control) {return `eval $type "-q" $flag $control`;}proc eString(string $type, string $flag, string $sValue, string $control) {eval $type "-e" $flag ("\"" + $sValue + "\"") $control;}proc float[] qFloatArray(string $type, string $flag, string $control) {return `eval $type "-q" $flag $control`;}proc int[] qIntArray(string $type, string $flag, string $control) {return `eval $type "-q" $flag $control`;}proc string[] qStringArray(string $type, string $flag, string $control) {return `eval $type "-q" $flag $control`;}proc eStringArray(string $type, string $flag, string $sValues[], string $control) {for ($sValue in $sValues) {eString($type, $flag, $sValue, $control);}}proc eOrderedFloat(string $type, string $flag, float $fValues[], string $control) {for ($i = 0; $i < `size $fValues`; $i++) {eFloat($type, ($flag + ($i + 1)), $fValues[$i], $control);}}proc eOrderedInt(string $type, string $flag, int $iValues[], string $control) {for ($i = 0; $i < `size $iValues`; $i++) {eInt($type, ($flag + ($i + 1)), $iValues[$i], $control);}}proc eOrderedString(string $type, string $flag, string $sValues[], string $control) {for ($i = 0; $i < `size $sValues`; $i++) {eString($type, ($flag + ($i + 1)), $sValues[$i], $control);}}proc int qIndex(string $type, string $flag, string $control) {return (qInt($type, $flag, $control) - 1);}proc eIndex(string $type, string $flag, int $index, string $control) {eInt($type, $flag, ($index + 1), $control);}proc int[] qIndexArray(string $type, string $flag, string $control) {int $indices[] = qIntArray($type, $flag, $control);for ($i = 0; $i < `size $indices`; $i++) $indices[$i] -= 1;return $indices;}proc eIndexArray(string $type, string $flag, int $indices[], string $control) {for ($i in $indices) {eInt($type, $flag, $i + 1, $control);}}proc int qFirstIndex(string $type, string $flag, string $control) {int $indices[] = qIndexArray($type, $flag, $control);return  ((`size $indices`) ? $indices[0] : -1);}proc string qFirstString(string $type, string $flag, string $control) {string $sValues[] = qStringArray($type, $flag, $control);return  ((`size $sValues`) ? $sValues[0] : "");}proc eIntString(string $type, string $flag, int $iValue, string $sValue, string $control) {eval $type "-e" $flag $iValue ("\"" + $sValue + "\"") $control;}proc eIndexString(string $type, string $flag, int $index, string $sValue, string $control) {eIntString($type, $flag, $index + 1, $sValue, $control);}proc eStringInt(string $type, string $flag, string $sValue, int $iValue, string $control) {eval $type "-e" $flag ("\"" + $sValue + "\"") $iValue $control;}proc executeUIControl(string $type, string $flag, string $control) {eval $type "-e" $flag $control;}proc string getParentableWindow(string $control) {if (uiControlTypeOf($control) == "workspaceControl" && !qInt("workspaceControl", "-fl", $control)) {return "MayaWindow";}else {return $control;}}proc windowClose(string $control) {if (qExists($control)) {string $type = uiControlTypeOf($control);switch ($type) {case "window": deleteUI $control; break;case "workspaceControl": executeUIControl("workspaceControl", "-cl", $control);break;default: break;}}}proc windowPrefRemove(string $type, string $control) {if (qExists($control)) windowClose($control);switch ($type) {case "window": if (qInt("windowPref", "-ex", $control)) {windowPref -r $control;}break;case "workspaceControl": if (qInt("workspaceControlState", "-ex", $control)) {workspaceControlState -r $control;}break;default: break;}}proc string buildWorkspaceControl(string $workspaceControlName,string $label,string $buildProcName,string $buildProcFilename) {string $control = $workspaceControlName;if (!qExists($workspaceControlName)) {string $uiScript = "if (!`exists " + $buildProcName + "`)" + " source \"" + $buildProcFilename + "\"; " + $buildProcName + "();";$control = `workspaceControl -dup false -fl true -l $label -rt false -ui $uiScript$workspaceControlName`;}return $control;}
// -----------------------------------------------------------------------------
/*1.0.0:DictAttribute*/proc int hasDictAttribute(string $n, string $attribute) {return existsAttribute($n, $attribute);}proc int lockDictAttribute(string $n, string $attribute, int $state) {if (!hasDictAttribute($n, $attribute)) return false;setAttributeLock($n, $attribute, $state);return true;}proc string addDictAttribute(string $n, string $attribute) {string $path;if (!`objExists $n`) return $path;if (!hasDictAttribute($n, $attribute)) {addAttr -dt "string" -ln $attribute $n;lockDictAttribute($n, $attribute, true);}if (hasDictAttribute($n, $attribute)) $path = $n + "." + $attribute;return $path;}proc string getDictValue(string $n, string $attribute) {return ((hasDictAttribute($n, $attribute)) ? getStringAttribute($n, $attribute, "") : "");}proc int setDictValue(string $n, string $attribute, string $value) {if (!hasDictAttribute($n, $attribute)) return false;lockDictAttribute($n, $attribute, false);setStringAttribute($n, $attribute, $value);lockDictAttribute($n, $attribute, true);return true;}proc int removeFromDict(string $n, string $attribute, string $key) {if (!hasDictAttribute($n, $attribute) || !`size $key`) return false;string $dict = getDictValue($n, $attribute);$dict = dictRemove($dict, $key);return setDictValue($n, $attribute, $dict);}proc int getBooleanFromDict(string $n, string $attribute, string $key, int $default) {return dictGetBoolean(getDictValue($n, $attribute), $key, $default);}proc float getFloatFromDict(string $n, string $attribute, string $key, float $default) {return dictGetFloat(getDictValue($n, $attribute), $key, $default);}proc int getIntFromDict(string $n, string $attribute, string $key, int $default) {return dictGetInt(getDictValue($n, $attribute), $key, $default);}proc string getStringFromDict(string $n, string $attribute, string $key, string $default) {return dictGetString(getDictValue($n, $attribute), $key, $default);}proc int setBooleanToDict(string $n, string $attribute, string $key, int $value) {if (!hasDictAttribute($n, $attribute) || !`size $key`) return false;string $dict = getDictValue($n, $attribute);$dict = dictAddBoolean($dict, $key, $value);return setDictValue($n, $attribute, $dict);}proc int setFloatToDict(string $n, string $attribute, string $key, float $value) {if (!hasDictAttribute($n, $attribute) || !`size $key`) return false;string $dict = getDictValue($n, $attribute);$dict = dictAddFloat($dict, $key, $value);return setDictValue($n, $attribute, $dict);}proc int setIntToDict(string $n, string $attribute, string $key, int $value) {if (!hasDictAttribute($n, $attribute) || !`size $key`) return false;string $dict = getDictValue($n, $attribute);$dict = dictAddInt($dict, $key, $value);return setDictValue($n, $attribute, $dict);}proc int setStringToDict(string $n, string $attribute, string $key, string $value) {if (!hasDictAttribute($n, $attribute) || !`size $key`) return false;string $dict = getDictValue($n, $attribute);$dict = dictAddString($dict, $key, $value);return setDictValue($n, $attribute, $dict);}

// /////////////////////////////////////////////////////////////////////////////
// ドメイン
// /////////////////////////////////////////////////////////////////////////////
// -----------------------------------------------------------------------------
// プラグイン
// -----------------------------------------------------------------------------
/*-
@returns <boolean>
*/
proc int isPluginLoaded() {
  // print("isPluginLoaded\n"); // debug
  return `pluginInfo -q -l "boneDynamicsNode"`;
}

/*-
@returns <>
*/
proc loadBdnPlugin() {
  // print("loadBdnPlugin\n"); // debug
  if (isPluginLoaded()) return;
  loadPlugin "boneDynamicsNode";
}

/*-
@returns <>
*/
proc unloadBdnPlugin() {
  // print("unloadBdnPlugin\n"); // debug
  if (!isPluginLoaded()) return;

  string $bdnNodes[] = `ls -typ "boneDynamicsNode"`;
  if (!`size $bdnNodes`) {
    unloadPlugin -f "boneDynamicsNode";
  }
  else {
    confirmDialog
        -b "OK" -cb "OK" -db "OK" -ds "OK"
        -m "Cannot unload because a bondDynamicsNode exists in the scene."
        -t "nkBdnTool";
  }
}

// -----------------------------------------------------------------------------
// アトリビュート
// -----------------------------------------------------------------------------
/*-
@param $sourceNodes <string[]>
@param $destNode <string>
@returns <>
*/
proc appendColliderAffectedBy(string $sourceNodes[], string $destNode) {
  if (!existsAttribute($destNode, "colliderAffectedBy")) return;

  for ($i = 0; $i < `size $sourceNodes`; $i++) {
    if (!existsAttribute($sourceNodes[$i], "message")) continue;

    int $size = `getAttr -s ($destNode + ".colliderAffectedBy")`;
    connectAttr -f
        ($sourceNodes[$i] + ".message")
        ($destNode + ".colliderAffectedBy[" + $size + "]");
  }
}

// -----------------------------------------------------------------------------
// BDNノード
// -----------------------------------------------------------------------------
/*-
@param $n <string>
@returns <string>
*/
proc string initBDNNode(string $n) {
  if (`objExists $n` && !hasDictAttribute($n, "bdnData")) {
    addDictAttribute($n, "bdnData");
    setStringToDict($n, "bdnData", "type", "bdn");
  }
  return $n;
}

/*-
@param $n <string>
@returns <string>
*/
proc string initColliderGroupNode(string $n) {
  if (`objExists $n` && !hasDictAttribute($n, "bdnData")) {
    addDictAttribute($n, "bdnData");
    setStringToDict($n, "bdnData", "type", "colliderGroup");
  }
  return $n;
}

/*-
@param $n <string>
@returns <string>
*/
proc string initColliderIdentityNode(string $n) {
  if (`objExists $n` && !hasDictAttribute($n, "bdnData")) {
    addDictAttribute($n, "bdnData");
    setStringToDict($n, "bdnData", "type", "colliderIdentity");
  }
  return $n;
}

/*-
@param $n <string>
@param $colliderType <string>
@returns <string>
*/
proc string initColliderNode(string $n, string $colliderType) {
  if (`objExists $n` && !hasDictAttribute($n, "bdnData")) {
    addDictAttribute($n, "bdnData");
    setStringToDict($n, "bdnData", "type", "collider");
    setStringToDict($n, "bdnData", "colliderType", $colliderType);
  }
  return $n;
}

/*-
@param $selectedOnly <boolean>
@returns <string[]>
*/
proc string[] gatherBdnNodes(int $selectedOnly) {
  return gatherNodes({"boneDynamicsNode"}, true, $selectedOnly, "");
}

/*-
@param $selectedOnly <boolean>
@returns <string[]>
*/
proc string[] gatherDynamicsNodes(int $selectedOnly) {
  string $dynamicsNodes[];
  return $dynamicsNodes;
}

/*-
@param $selectedOnly <boolean>
@returns <string[]>
*/
proc string[] gatherColliderNodes(int $selectedOnly) {
  string $colliderNodes[];
  return $colliderNodes;
}

/*-
@returns <>
*/
proc deleteAllBdnNodes() {
  print("deleteAllBdnNodes\n"); // debug
  string $bdnNodes[] = gatherBdnNodes(false);
  select -r $bdnNodes;
}

// -----------------------------------------------------------------------------
// コライダー
// -----------------------------------------------------------------------------
/*-
@param $bdnBaseName <string>
@param $sourceNodes <string[]>
@returns <string[]>
*/
proc string[] createInfinitePlaneCollider(
  string $bdnBaseName,
  string $sourceNodes[]
) {
  print("createInfinitePlaneCollider\n"); // debug
  print("  bdnBaseName:" + $bdnBaseName + "\n"); // debug
  print("  sourceNodes:{\n    " + stringArrayToString($sourceNodes, ",\n    ") + "\n  }\n"); // debug

  string $colliderNodes[];
  string $colliderType = "infinitePlane";
  string $colliderName = $colliderType + "Collider";

  string $bdnNodeName = join({"bdn", $bdnBaseName}, "_", true);
  string $colliderRootNode = initColliderGroupNode(getSecondLevelNode($bdnNodeName, "collider_grp", true));
  initBDNNode(getTopLevelNode($bdnNodeName, false));
  print("  colliderRootNode:" + $colliderRootNode + "\n"); // debug
  if (!`objExists $colliderRootNode`) return $colliderNodes;

  if (!`size $sourceNodes`) $sourceNodes = {""};
  int $numSourceNodes = `size $sourceNodes`;
  for ($i = 0; $i < $numSourceNodes; $i++) {
    string $sourceNode = $sourceNodes[$i];
    string $sourceShortName = toShortName($sourceNode);
    string $idtNodeName = join({$sourceShortName, $colliderName, "idt"}, "_", true);
    string $colliderNodeName = join({$sourceShortName, $colliderName}, "_", true);

    // ノード作成
    string $idtNode = initColliderIdentityNode(createTransform($idtNodeName, $colliderRootNode, true, $sourceNode, {}));
    string $planeNodes[] = `nurbsPlane -ax 0.0 1.0 0.0 -d 3 -lr 1.0 -u 1.0 -v 1.0 -w 1.0`;
    string $transformNode = buildDagNode(longNameOf($planeNodes[0]), $colliderNodeName, $idtNode, true, $idtNode, {});
    string $makeNode = longNameOf($planeNodes[1]);
    string $shapeNodes[] = getShapeNodes($transformNode, "");
    $colliderNodes[`size $colliderNodes`] = $idtNode;
    $colliderNodes[`size $colliderNodes`] = $transformNode;
    $colliderNodes[`size $colliderNodes`] = $makeNode;
    $colliderNodes = stringArrayCatenate($colliderNodes, $shapeNodes);

    // ノード初期化
    initColliderNode($transformNode, $colliderType);
    setOutlinerColor({$transformNode}, {1.0, 1.0, 0.0});
    setOverrideColor($shapeNodes, 17);

    // アトリビュート設定
    addAttr -at "message" -ln "colliderSource" $idtNode;
    addAttr -at "message" -ln "colliderAffectedBy" -m $transformNode;
    addAttr -at "double" -dv 1.0 -k true -hxv false -hnv true -min 0.001 -ln "colliderWidth" $transformNode;
    addAttr -at "double" -dv 1.0 -k true -hxv false -hnv true -min 0.001 -ln "colliderHeight" $transformNode;

    // 計算ノード作成
    string $ratioNode = uuidToLongName(toUUID(`createNode -n ($colliderNodeName + "_ratio") -ss "floatMath"`));
    $colliderNodes[`size $colliderNodes`] = $ratioNode;

    // 計算ノード設定
    setAttr ($ratioNode + ".operation") 3;

    // アトリビュート接続
    connectAttr -f ($transformNode + ".colliderWidth" ) ($makeNode  + ".width"      );
    connectAttr -f ($transformNode + ".colliderHeight") ($ratioNode + ".floatA"     );
    connectAttr -f ($transformNode + ".colliderWidth" ) ($ratioNode + ".floatB"     );
    connectAttr -f ($ratioNode     + ".outFloat"      ) ($makeNode  + ".lengthRatio");

    // ノード接続
    appendColliderAffectedBy({$makeNode}, $transformNode);
    appendColliderAffectedBy($shapeNodes, $transformNode);
    appendColliderAffectedBy({$ratioNode}, $transformNode);

    if (`objExists $sourceNode`) {
      connectAttr -f ($sourceNode + ".message") ($idtNode + ".colliderSource");
      // コンストレイント
      string $prcstNodes[] = `parentConstraint $sourceNode $idtNode`;
      if (`size $prcstNodes`) {
        $prcstNodes[0] = setNodeName($prcstNodes[0], $idtNodeName + "_prcst");
        $colliderNodes[`size $colliderNodes`] = $prcstNodes[0];
      }
    }
  }

  return $colliderNodes;
}

/*-
@param $bdnBaseName <string>
@param $sourceNodes <string[]>
@returns <string[]>
*/
proc string[] createSphereCollider(
  string $bdnBaseName,
  string $sourceNodes[]
) {
  print("createSphereCollider\n"); // debug
  print("  bdnBaseName:" + $bdnBaseName + "\n"); // debug
  print("  sourceNodes:{\n    " + stringArrayToString($sourceNodes, ",\n    ") + "\n  }\n"); // debug

  string $colliderNodes[];
  string $colliderType = "sphere";
  string $colliderName = $colliderType + "Collider";

  string $bdnNodeName = join({"bdn", $bdnBaseName}, "_", true);
  string $colliderRootNode = initColliderGroupNode(getSecondLevelNode($bdnNodeName, "collider_grp", true));
  initBDNNode(getTopLevelNode($bdnNodeName, false));
  print("  colliderRootNode:" + $colliderRootNode + "\n"); // debug
  if (!`objExists $colliderRootNode`) return $colliderNodes;

  if (!`size $sourceNodes`) $sourceNodes = {""};
  int $numSourceNodes = `size $sourceNodes`;
  for ($i = 0; $i < $numSourceNodes; $i++) {
    string $sourceNode = $sourceNodes[$i];
    string $sourceShortName = toShortName($sourceNode);
    string $idtNodeName = join({$sourceShortName, $colliderName, "idt"}, "_", true);
    string $colliderNodeName = join({$sourceShortName, $colliderName}, "_", true);

    // ノード作成
    string $idtNode = initColliderIdentityNode(createTransform($idtNodeName, $colliderRootNode, true, $sourceNode, {}));
    string $sphereNodes[] = `sphere -ax 0.0 1.0 0.0 -d 3 -hr 2.0 -r 0.5 -s 8 -nsp 4`;
    string $transformNode = buildDagNode(longNameOf($sphereNodes[0]), $colliderNodeName, $idtNode, true, $idtNode, {});
    string $makeNode = longNameOf($sphereNodes[1]);
    string $shapeNodes[] = getShapeNodes($transformNode, "");
    $colliderNodes[`size $colliderNodes`] = $idtNode;
    $colliderNodes[`size $colliderNodes`] = $transformNode;
    $colliderNodes[`size $colliderNodes`] = $makeNode;
    $colliderNodes = stringArrayCatenate($colliderNodes, $shapeNodes);

    // ノード初期化
    initColliderNode($transformNode, $colliderType);
    setOutlinerColor({$transformNode}, {1.0, 1.0, 0.0});
    setOverrideColor($shapeNodes, 17);

    // アトリビュート設定
    addAttr -at "message" -ln "colliderSource" $idtNode;
    addAttr -at "message" -ln "colliderAffectedBy" -m $transformNode;
    addAttr -at "double" -dv 0.5 -k true -hxv false -hnv true -min 0.001 -ln "colliderRadius" $transformNode;

    // アトリビュート接続
    connectAttr -f ($transformNode + ".colliderRadius") ($makeNode  + ".radius");

    // ノード接続
    appendColliderAffectedBy({$makeNode}, $transformNode);
    appendColliderAffectedBy($shapeNodes, $transformNode);

    if (`objExists $sourceNode`) {
      connectAttr -f ($sourceNode + ".message") ($idtNode + ".colliderSource");
      // コンストレイント
      string $prcstNodes[] = `parentConstraint $sourceNode $idtNode`;
      if (`size $prcstNodes`) {
        $prcstNodes[0] = setNodeName($prcstNodes[0], $idtNodeName + "_prcst");
        $colliderNodes[`size $colliderNodes`] = $prcstNodes[0];
      }
    }
  }

  return $colliderNodes;
}

/*-
@param $bdnBaseName <string>
@param $sourceNodes <string[]>
@returns <string[]>
*/
proc string[] createCapsuleCollider(
  string $bdnBaseName,
  string $sourceNodes[]
) {
  print("createCapsuleCollider\n"); // debug
  print("  bdnBaseName:" + $bdnBaseName + "\n"); // debug
  print("  sourceNodes:{\n    " + stringArrayToString($sourceNodes, ",\n    ") + "\n  }\n"); // debug

  string $colliderNodes[];
  string $colliderType = "capsule";
  string $colliderName = $colliderType + "Collider";

  string $bdnNodeName = join({"bdn", $bdnBaseName}, "_", true);
  string $colliderRootNode = initColliderGroupNode(getSecondLevelNode($bdnNodeName, "collider_grp", true));
  initBDNNode(getTopLevelNode($bdnNodeName, false));
  print("  colliderRootNode:" + $colliderRootNode + "\n"); // debug
  if (!`objExists $colliderRootNode`) return $colliderNodes;

  if (!`size $sourceNodes`) $sourceNodes = {""};
  int $numSourceNodes = `size $sourceNodes`;
  for ($i = 0; $i < $numSourceNodes; $i++) {
    string $sourceNode = $sourceNodes[$i];
    string $sourceShortName = toShortName($sourceNode);
    string $idtNodeName = join({$sourceShortName, $colliderName, "idt"}, "_", true);
    string $colliderNodeName = join({$sourceShortName, $colliderName}, "_", true);

    // ノード作成
    string $idtNode = initColliderIdentityNode(createTransform($idtNodeName, $colliderRootNode, true, $sourceNode, {}));
    string $transformNode = createTransform($colliderNodeName, $idtNode, true, $idtNode, {});
    $colliderNodes[`size $colliderNodes`] = $idtNode;
    $colliderNodes[`size $colliderNodes`] = $transformNode;

    string $sphereANodes[] = `sphere -ax 0.0 1.0 0.0 -d 3 -esw 270.0 -hr 2.0 -r 0.5 -s 4 -nsp 4 -ssw 90.0`;
    string $sphereATransformNode = buildDagNode(longNameOf($sphereANodes[0]), $colliderNodeName + "_sphereA", $transformNode, true, $transformNode, {});
    string $makeSphereANode = longNameOf($sphereANodes[1]);
    string $sphereAShapeNodes[] = getShapeNodes($sphereATransformNode, "");
    $colliderNodes[`size $colliderNodes`] = $sphereATransformNode;
    $colliderNodes[`size $colliderNodes`] = $makeSphereANode;
    $colliderNodes = stringArrayCatenate($colliderNodes, $sphereAShapeNodes);

    string $sphereBNodes[] = `sphere -ax 0.0 1.0 0.0 -d 3 -esw 90.0 -hr 2.0 -r 0.5 -s 4 -nsp 4 -ssw -90.0`;
    string $sphereBTransformNode = buildDagNode(longNameOf($sphereBNodes[0]), $colliderNodeName + "_sphereB", $transformNode, true, $transformNode, {});
    string $makeSphereBNode = longNameOf($sphereBNodes[1]);
    string $sphereBShapeNodes[] = getShapeNodes($sphereBTransformNode, "");
    $colliderNodes[`size $colliderNodes`] = $sphereBTransformNode;
    $colliderNodes[`size $colliderNodes`] = $makeSphereBNode;
    $colliderNodes = stringArrayCatenate($colliderNodes, $sphereBShapeNodes);

    string $circleANodes[] = `circle -d 3 -fp 1.0 0.0 0.0 -fc true -nr 1.0 0.0 0.0 -r 0.5 -s 8`;
    string $circleATransformNode = buildDagNode(longNameOf($circleANodes[0]), $colliderNodeName + "_circleA", $transformNode, true, $transformNode, {});
    string $makeCircleANode = longNameOf($circleANodes[1]);
    string $circleAShapeNodes[] = getShapeNodes($circleATransformNode, "");
    $colliderNodes[`size $colliderNodes`] = $circleATransformNode;
    $colliderNodes[`size $colliderNodes`] = $makeCircleANode;
    $colliderNodes = stringArrayCatenate($colliderNodes, $circleAShapeNodes);

    string $circleBNodes[] = `circle -d 3 -fp 1.0 0.0 0.0 -fc true -nr 1.0 0.0 0.0 -r 0.5 -s 8`;
    string $circleBTransformNode = buildDagNode(longNameOf($circleBNodes[0]), $colliderNodeName + "_circleB", $transformNode, true, $transformNode, {});
    string $makeCircleBNode = longNameOf($circleBNodes[1]);
    string $circleBShapeNodes[] = getShapeNodes($circleBTransformNode, "");
    $colliderNodes[`size $colliderNodes`] = $circleBTransformNode;
    $colliderNodes[`size $colliderNodes`] = $makeCircleBNode;
    $colliderNodes = stringArrayCatenate($colliderNodes, $circleBShapeNodes);

    string $loftNodes[] = `loft -d 3 -ss 1 $circleBTransformNode $circleATransformNode`;
    string $loftTransformNode = buildDagNode(longNameOf($loftNodes[0]), $colliderNodeName + "_loft", $transformNode, false, "", {});
    string $loftNode = longNameOf($loftNodes[1]);
    string $loftShapeNodes[] = getShapeNodes($loftTransformNode, "");
    $colliderNodes[`size $colliderNodes`] = $loftTransformNode;
    $colliderNodes[`size $colliderNodes`] = $loftNode;
    $colliderNodes = stringArrayCatenate($colliderNodes, $loftShapeNodes);

    // ノード初期化
    initColliderNode($transformNode, $colliderType);
    setOutlinerColor({$transformNode}, {1.0, 1.0, 0.0});
    setOverrideColor($sphereAShapeNodes, 17);
    setOverrideColor($sphereBShapeNodes, 17);
    setOverrideColor($circleAShapeNodes, 17);
    setOverrideColor($circleBShapeNodes, 17);
    setOverrideColor($loftShapeNodes, 17);

    // アトリビュート設定
    addAttr -at "message" -ln "colliderSource" $idtNode;
    addAttr -at "message" -ln "colliderAffectedBy" -m $transformNode;
    addAttr -at "double" -dv 0.5 -k true -hxv false -hnv true -min 0.001 -ln "colliderRadiusA" $transformNode;
    addAttr -at "double" -dv 0.5 -k true -hxv false -hnv true -min 0.001 -ln "colliderRadiusB" $transformNode;
    addAttr -at "double" -dv 2.0 -k true -hxv false -hnv true -min 0.001 -ln "colliderLength" $transformNode;
    addAttr -at "double" -dv 0.0 -k true -hxv false -hnv false -ln "colliderOffset" $transformNode;
    addAttr -at "enum" -dv 0 -k true -en "A:Center:B" -ln "colliderPivot" $transformNode;
    addAttr -at "matrix" -h true -k true -ln "colliderMatrixA" $transformNode;
    addAttr -at "matrix" -h true -k true -ln "colliderMatrixB" $transformNode;

    // 計算ノード作成
    string $halfLengthNode = uuidToLongName(toUUID(`createNode -n ($colliderNodeName + "_halfLength") -ss "floatMath"`));
    string $pivotNode = uuidToLongName(toUUID(`createNode -n ($colliderNodeName + "_pivot") -ss "floatMath"`));
    string $offsetANode = uuidToLongName(toUUID(`createNode -n ($colliderNodeName + "_offsetA") -ss "floatMath"`));
    string $offsetBNode = uuidToLongName(toUUID(`createNode -n ($colliderNodeName + "_offsetB") -ss "floatMath"`));
    $colliderNodes[`size $colliderNodes`] = $halfLengthNode;
    $colliderNodes[`size $colliderNodes`] = $pivotNode;
    $colliderNodes[`size $colliderNodes`] = $offsetANode;
    $colliderNodes[`size $colliderNodes`] = $offsetBNode;

    // 計算ノード設定
    setAttr ($halfLengthNode + ".operation") 2;
    setAttr ($halfLengthNode + ".floatB") -0.5;
    setAttributeLock($halfLengthNode, "floatB", true);
    setAttr ($pivotNode + ".operation") 2;
    setAttr ($offsetANode + ".operation") 0;
    setAttr ($offsetBNode + ".operation") 0;

    // アトリビュート接続
    connectAttr -f ($transformNode        + ".worldInverseMatrix") ($loftTransformNode    + ".offsetParentMatrix");
    connectAttr -f ($sphereATransformNode + ".worldMatrix"       ) ($transformNode        + ".colliderMatrixA"   );
    connectAttr -f ($sphereBTransformNode + ".worldMatrix"       ) ($transformNode        + ".colliderMatrixB"   );
    connectAttr -f ($transformNode        + ".colliderRadiusA"   ) ($makeSphereANode      + ".radius"            );
    connectAttr -f ($transformNode        + ".colliderRadiusB"   ) ($makeSphereBNode      + ".radius"            );
    connectAttr -f ($transformNode        + ".colliderRadiusA"   ) ($makeCircleANode      + ".radius"            );
    connectAttr -f ($transformNode        + ".colliderRadiusB"   ) ($makeCircleBNode      + ".radius"            );
    connectAttr -f ($transformNode        + ".colliderLength"    ) ($halfLengthNode       + ".floatA"            );
    connectAttr -f ($halfLengthNode       + ".outFloat"          ) ($pivotNode            + ".floatA"            );
    connectAttr -f ($transformNode        + ".colliderPivot"     ) ($pivotNode            + ".floatB"            );
    connectAttr -f ($pivotNode            + ".outFloat"          ) ($offsetANode          + ".floatA"            );
    connectAttr -f ($transformNode        + ".colliderOffset"    ) ($offsetANode          + ".floatB"            );
    connectAttr -f ($offsetANode          + ".outFloat"          ) ($offsetBNode          + ".floatA"            );
    connectAttr -f ($transformNode        + ".colliderLength"    ) ($offsetBNode          + ".floatB"            );
    connectAttr -f ($offsetANode          + ".outFloat"          ) ($sphereATransformNode + ".tx"                );
    connectAttr -f ($offsetANode          + ".outFloat"          ) ($circleATransformNode + ".tx"                );
    connectAttr -f ($offsetBNode          + ".outFloat"          ) ($sphereBTransformNode + ".tx"                );
    connectAttr -f ($offsetBNode          + ".outFloat"          ) ($circleBTransformNode + ".tx"                );

    // アトリビュート状態設定
    string $txNodes[] = {
      $sphereATransformNode,
      $sphereBTransformNode,
      $circleATransformNode,
      $circleBTransformNode
    };
    batchSetAttributeLock($txNodes, {"ty", "tz", "rx", "ry", "rz", "sx", "sy", "sz", "v"}, true);
    batchSetAttributeChannelBox($txNodes, {"ty", "tz", "rx", "ry", "rz", "sx", "sy", "sz", "v"}, false);
    batchSetAttributeLock({$loftTransformNode}, {"tx", "ty", "tz", "rx", "ry", "rz", "sx", "sy", "sz", "v"}, true);
    batchSetAttributeChannelBox({$loftTransformNode}, {"tx", "ty", "tz", "rx", "ry", "rz", "sx", "sy", "sz", "v"}, false);
    disableRenderStats(getShapeNodes($sphereATransformNode, ""));
    disableRenderStats(getShapeNodes($sphereBTransformNode, ""));
    disableRenderStats(getShapeNodes($loftTransformNode, ""));

    // ノード接続
    appendColliderAffectedBy({$makeSphereANode}, $transformNode);
    appendColliderAffectedBy($sphereAShapeNodes, $transformNode);
    appendColliderAffectedBy({$makeSphereBNode}, $transformNode);
    appendColliderAffectedBy($sphereBShapeNodes, $transformNode);
    appendColliderAffectedBy({$makeCircleANode}, $transformNode);
    appendColliderAffectedBy($circleAShapeNodes, $transformNode);
    appendColliderAffectedBy({$makeCircleBNode}, $transformNode);
    appendColliderAffectedBy($circleBShapeNodes, $transformNode);
    appendColliderAffectedBy({$loftNode}, $transformNode);
    appendColliderAffectedBy($loftShapeNodes, $transformNode);
    appendColliderAffectedBy({$halfLengthNode, $pivotNode, $offsetANode, $offsetBNode}, $transformNode);

    if (`objExists $sourceNode`) {
      connectAttr -f ($sourceNode + ".message") ($idtNode + ".colliderSource");
      // コンストレイント
      string $prcstNodes[] = `parentConstraint $sourceNode $idtNode`;
      if (`size $prcstNodes`) {
        $prcstNodes[0] = setNodeName($prcstNodes[0], $idtNodeName + "_prcst");
        $colliderNodes[`size $colliderNodes`] = $prcstNodes[0];
      }
    }

    // アトリビュート値設定
    if ($i < $numSourceNodes - 1) {
      string $nextSourceNode = $sourceNodes[$i + 1];
      print("nextSourceNode:" + $nextSourceNode + "\n");
      if (`objExists $nextSourceNode`) {
        setFloatAttribute(
          $transformNode,
          "colliderLength",
          getFloatAttribute($nextSourceNode, "tx", 2.0)
        );
      }
    }
  }

  return $colliderNodes;
}

// /////////////////////////////////////////////////////////////////////////////
// API
// /////////////////////////////////////////////////////////////////////////////

// /////////////////////////////////////////////////////////////////////////////
// スクリプトジョブ
// /////////////////////////////////////////////////////////////////////////////
// -----------------------------------------------------------------------------
// イベントジョブ
// -----------------------------------------------------------------------------
// /*-
// @returns <>
// */
// proc registerEventJob() {
//   print("registerEventJob\n"); // debug
// }

// /*-
// @returns <>
// */
// proc unregisterEventJob() {
//   print("unregisterEventJob\n"); // debug
// }

// -----------------------------------------------------------------------------
// ノードジョブ
// -----------------------------------------------------------------------------
// /*-
// @param $n <string>
// @returns <>
// */
// proc registerNodeJob(string $n) {
//   print("registerNodeJob\n"); // debug
//   print("  n:" + $n + "\n"); // debug
// }

// /*-
// @param $nodeId <string>
// @returns <>
// */
// proc unregisterNodeJob(string $nodeId) {
//   print("unregisterNodeJob\n"); // debug
//   print("  nodeId:" + $nodeId + "\n"); // debug
// }

// /////////////////////////////////////////////////////////////////////////////
// プレゼンテーション
// /////////////////////////////////////////////////////////////////////////////
/*-
@returns <string>
*/
proc string getBdnBaseName() {
  string $bdnBaseNameText = getUIControl("nkBdnToolWindow", "bdnBaseNameText");
  return qString("textFieldGrp", "-tx", $bdnBaseNameText);
}

// -----------------------------------------------------------------------------
// UIコントロールイベントハンドラ
// -----------------------------------------------------------------------------
/*-
@returns <>
*/
proc nkBdnToolWindowClosed() {
  print("nkBdnToolWindowClosed\n"); // debug
  removeUIControls("nkBdnToolWindow", "");
}

/*-
@returns <>
*/
proc resetWindowMenuItemSelected() {
  print("resetWindowMenuItemSelected\n"); // debug
  windowPrefRemove("window", "nkBdnToolWindow");
  nkBdnTool();
}

/*-
@returns <>
*/
proc quitMenuItemSelected() {
  print("quitMenuItemSelected\n"); // debug
  string $nkBdnToolWindow = getUIControl("nkBdnToolWindow", "nkBdnToolWindow");
  print("  nkBdnToolWindow:" + $nkBdnToolWindow + "\n"); // debug
  windowClose($nkBdnToolWindow);
}

/*-
@returns <>
*/
proc aboutMenuItemSelected() {
  print("aboutMenuItemSelected\n"); // debug
  confirmDialog
      -b "OK"
      -db "OK"
      -m (
        "nkBdnTool " + (nkBdnToolVersion())
            + "\n\nMIT License\nhttps://github.com/imaoki/nkBdnTool"
      )
      -p (getParentableWindow("nkBdnToolWindow"))
      -t "About - nkBdnTool";
}

/*-
@returns <>
*/
proc bdnPluginLoadButtonPressed() {
  // print("bdnPluginLoadButtonPressed\n"); // debug
  loadBdnPlugin();
}

/*-
@returns <>
*/
proc bdnPluginUnloadButtonPressed() {
  // print("bdnPluginUnloadButtonPressed\n"); // debug
  unloadBdnPlugin();
}

/*-
@returns <>
*/
proc deleteAllButtonPressed() {
  // print("deleteAllButtonPressed\n"); // debug
  deleteAllBdnNodes();
}

/*-
@returns <>
*/
proc controlNodeTextPressed() {
  // print("controlNodeTextPressed\n"); // debug
  string $controlNodeText = getUIControl("nkBdnToolWindow", "controlNodeText");
  eString("textFieldButtonGrp", "-tx", nodesAsCSV({"transform"}, true, true, "", false), $controlNodeText);
}

/*-
@returns <>
*/
proc selectTimeNodeButtonPressed() {
  print("selectTimeNodeButtonPressed\n"); // debug
  select -r (gatherNodes({"time"}, true, false, ""));
}

/*-
@returns <>
*/
proc selectBdnNodesFromDynamicsJointsButtonPressed() {
  print("selectBdnNodesFromDynamicsJointsButtonPressed\n"); // debug
}

/*-
@returns <>
*/
proc selectTargetJointsFromDynamicsJointsButtonPressed() {
  print("selectTargetJointsFromDynamicsJointsButtonPressed\n"); // debug
}
/*-
@returns <>
*/
proc generateDynamicsUnitButtonPressed() {
  print("generateDynamicsUnitButtonPressed\n"); // debug
}

/*-
@returns <>
*/
proc createColliderInfinitePlaneButtonPressed() {
  // print("createColliderInfinitePlaneButtonPressed\n"); // debug
  string $bdnBaseName = getBdnBaseName();
  string $sourceNodes[] = gatherNodes({"transform"}, false, true, "");
  string $colliderNodes[] = createInfinitePlaneCollider($bdnBaseName, $sourceNodes);
  print("  colliderNodes:{\n    " + stringArrayToString($colliderNodes, ",\n    ") + "\n  }\n"); // debug
  select -r $colliderNodes;
}

/*-
@returns <>
*/
proc createColliderSphereButtonPressed() {
  // print("createColliderSphereButtonPressed\n"); // debug
  string $bdnBaseName = getBdnBaseName();
  string $sourceNodes[] = gatherNodes({"transform"}, false, true, "");
  string $colliderNodes[] = createSphereCollider($bdnBaseName, $sourceNodes);
  print("  colliderNodes:{\n    " + stringArrayToString($colliderNodes, ",\n    ") + "\n  }\n"); // debug
  select -r $colliderNodes;
}

/*-
@returns <>
*/
proc createColliderCapsuleButtonPressed() {
  // print("createColliderCapsuleButtonPressed\n"); // debug
  string $bdnBaseName = getBdnBaseName();
  string $sourceNodes[] = gatherNodes({"transform"}, false, true, "");
  string $colliderNodes[] = createCapsuleCollider($bdnBaseName, $sourceNodes);
  print("  colliderNodes:{\n    " + stringArrayToString($colliderNodes, ",\n    ") + "\n  }\n"); // debug
  select -r $colliderNodes;
}

// /*-
// @returns <>
// */
// proc saveColliderSetButtonPressed() {
//   print("saveColliderSetButtonPressed\n"); // debug
// }

// /*-
// @returns <>
// */
// proc loadColliderSetButtonPressed() {
//   print("loadColliderSetButtonPressed\n"); // debug
// }

/*-
@returns <>
*/
proc bdnNodeTextPressed() {
  print("bdnNodeTextPressed\n"); // debug
  if (!isPluginLoaded()) return;

  string $bdnNodeText = getUIControl("nkBdnToolWindow", "bdnNodeText");
  eString("textFieldButtonGrp", "-tx", nodesAsCSV({"boneDynamicsNode"}, true, true, "", false), $bdnNodeText);
}

/*-
@returns <>
*/
proc appendColliderToBdnButtonPressed() {
  print("appendColliderToBdnButtonPressed\n"); // debug
}

/*-
@returns <>
*/
proc removeColliderFromBdnButtonPressed() {
  print("removeColliderFromBdnButtonPressed\n"); // debug
}

/*-
@returns <>
*/
proc bakeSelectedButtonPressed() {
  print("bakeSelectedButtonPressed\n"); // debug
}

// -----------------------------------------------------------------------------
// ウィンドウ定義
// -----------------------------------------------------------------------------
/*-
@returns <>
*/
proc buildMainWindow() {
  print("buildMainWindow\n"); // debug
  windowClose("nkBdnToolWindow");

  if (`uiTemplate -ex "nkBdnToolTemplateNarrow"`) deleteUI -uit "nkBdnToolTemplateNarrow";
  if (`uiTemplate -ex "nkBdnToolTemplateFrameList"`) deleteUI -uit "nkBdnToolTemplateFrameList";
  if (`uiTemplate -ex "nkBdnToolTemplateSubFrame"`) deleteUI -uit "nkBdnToolTemplateSubFrame";
  if (`uiTemplate -ex "nkBdnToolTemplateFlat"`) deleteUI -uit "nkBdnToolTemplateFlat";
  uiTemplate "nkBdnToolTemplateNarrow";
  uiTemplate "nkBdnToolTemplateFrameList";
  uiTemplate "nkBdnToolTemplateSubFrame";
  uiTemplate "nkBdnToolTemplateFlat";
  columnLayout -dt "nkBdnToolTemplateNarrow" -adj true -rs 0;
  frameLayout -dt "nkBdnToolTemplateFrameList" -bgs true -cll true -cl true -mh 0 -mw 4;
  columnLayout -dt "nkBdnToolTemplateFrameList" -adj true -rs 0;
  frameLayout -dt "nkBdnToolTemplateSubFrame" -bgs true -cll true -cl true -mh 4 -mw 0;
  columnLayout -dt "nkBdnToolTemplateSubFrame" -adj true -rs 4;
  frameLayout -dt "nkBdnToolTemplateFlat" -bgs true -cll true -cl true -mh 4 -mw 4;
  columnLayout -dt "nkBdnToolTemplateFlat" -adj true -rs 4;

  string $nkBdnToolWindow = `window
      -mxb false
      -mnb false
      -s true
      -t "nkBdnTool"
      "nkBdnToolWindow"`;
    string $outerForm = `formLayout "outerForm"`;
      string $menuBar = `menuBarLayout
          // -bgc 0.25 0.5 0.25
          "menuBar"`;
        string $fileMenu = `menu
            -l "File"
            "fileMenu"`;
          string $resetWindowMenuItem = `menuItem
              -l "Reset Window"
              "resetWindowMenuItem"`;
          menuItem -d true;
          string $quitMenuItem = `menuItem
              -l "Quit"
              "quitMenuItem"`;
        string $helpMenu = `menu
            -hm true
            -l "Help"
            "helpMenu"`;
          string $aboutMenuItem = `menuItem
              -l "About nkBdnTool"
              "aboutMenuItem"`;
      setParent ..;

      // string $column = `columnLayout -adj true -rs 3 "column"`;
      //   string $button = `button -l "Button" "button"`;
      // setParent ..;

      setUITemplate -pst "nkBdnToolTemplateNarrow";

      string $scroll = `scrollLayout -cr true -pe true -vsb true -w 277 "scroll"`;
        string $column = `columnLayout "column"`;

          setUITemplate -pst "nkBdnToolTemplateFlat";

          string $generalFrame = `frameLayout -l "General" -cl false "generalFrame"`;
            string $generalColumn = `columnLayout "generalColumn"`;
              string $bdnBaseNameText = `textFieldGrp
                  -adj 2
                  -cat 2 "right" -5
                  -cw2 90 10
                  -l "BDN BaseName:"
                  -tx ""
                  "bdnBaseNameText"`;
              // separator;
              // string $loadPluginButton = `button
              //     -l "Load Plug-in"
              //     "loadPluginButton"`;
              // string $unloadPluginButton = `button
              //     -l "Unload Plug-in"
              //     "unloadPluginButton"`;
              string $bdnPluginRow = `rowLayout
                  -ann "boneDynamicsNode.mll"
                  -cw3 90 75 75
                  -cat 1 "both" 0
                  -cat 2 "both" 0
                  -cat 3 "both" 0
                  -nc 3
                  "bdnPluginRow"`;
                text -al "right" -l "Plug-in:";
                string $bdnPluginLoadButton = `button -l "Load" "bdnPluginLoadButton"`;
                string $bdnPluginUnloadButton = `button -l "Unload" "bdnPluginUnloadButton"`;
              setParent ..;
              separator;
              string $deleteAllButton = `button
                  -l "Delete All"
                  "deleteAllButton"`;
            setParent ..;
          setParent ..;

          setUITemplate -pst "nkBdnToolTemplateFlat";

          string $selectFrame = `frameLayout -l "Select" -cl false "selectFrame"`;
            string $selectColumn = `columnLayout "selectColumn"`;
              string $selectTimeNodeButton = `button
                  -l "Time node"
                  "selectTimeNodeButton"`;
              string $selectBdnNodesFromDynamicsJointsButton = `button
                  -l "BDN nodes from dynamics joints"
                  "selectBdnNodesFromDynamicsJointsButton"`;
              string $selectTargetJointsFromDynamicsJointsButton = `button
                  -l "Target joints from dynamics joints"
                  "selectTargetJointsFromDynamicsJointsButton"`;
            setParent ..;
          setParent ..;

          setUITemplate -pst "nkBdnToolTemplateFlat";

          string $DynamicsUnitFrame = `frameLayout -l "Dynamics Unit" -cl false "DynamicsUnitFrame"`;
            string $DynamicsUnitColumn = `columnLayout "DynamicsUnitColumn"`;
              string $controlNodeText = `textFieldButtonGrp
                  -adj 2
                  -bl "<"
                  -ct3 "both" "both" "both"
                  -cw3 90 10 20
                  -l "Control Nodes:"
                  -tx ""
                  "controlNodeText"`;
              // text -al "left" -l "Selected control nodes is the target";
              string $generateTargetJointCheckBox = `checkBox
                  -l "Generate Target Joint"
                  -v false
                  "generateTargetJointCheckBox"`;
              string $generateEndJointCheckBox = `checkBox
                  -l "Generate End Joint"
                  -v false
                  "generateEndJointCheckBox"`;
              string $endJointOffsetField = `floatFieldGrp
                  -adj 0
                  -cw4 90 49 49 49
                  -l "End Joint Offset:"
                  -nf 3
                  -pre 3
                  -tze true
                  -v1 1.0 -v2 0.0 -v3 0.0
                  "endJointOffsetField"`;
              string $generateRadiusSphereCheckBox = `checkBox
                  -l "Generate Radius Sphere"
                  -v false
                  "generateRadiusSphereCheckBox"`;
              string $constraintTypeRadioButton = `radioButtonGrp
                  -cw3 90 60 60
                  -l "Constraint Type:"
                  -la2 "Parent" "Orient"
                  -nrb 2
                  -sl 1
                  "constraintTypeRadioButton"`;
              string $generateDynamicsUnitButton = `button -l "Generate Dynamics Unit" "generateDynamicsUnitButton"`;
            setParent ..;
          setParent ..;

          setUITemplate -pst "nkBdnToolTemplateFlat";

          string $colliderFrame = `frameLayout -l "Collider" -cl false "colliderFrame"`;
            string $colliderColumn = `columnLayout "colliderColumn"`;
              string $createColliderInfinitePlaneButton = `button -l "Infinite Plane" "createColliderInfinitePlaneButton"`;
              string $createColliderSphereButton = `button -l "Sphere" "createColliderSphereButton"`;
              string $createColliderCapsuleButton = `button -l "Capsule" "createColliderCapsuleButton"`;
              // separator;
              // string $saveColliderSetButton = `button
              //     -l "Save Collider Set"
              //     "saveColliderSetButton"`;
              // string $loadColliderSetButton = `button
              //     -l "Load Collider Set"
              //     "loadColliderSetButton"`;
              separator;
              string $bdnNodeText = `textFieldButtonGrp
                  -adj 2
                  -bl "<"
                  -ct3 "both" "both" "both"
                  -cw3 90 10 20
                  -l "BDN Nodes:"
                  -tx ""
                  "bdnNodeText"`;
              string $appendColliderToBdnButton = `button
                  -l "Append Collider to BDN"
                  "appendColliderToBdnButton"`;
              string $removeColliderFromBdnButton = `button
                  -l "Remove Collider from BDN"
                  "removeColliderFromBdnButton"`;
            setParent ..;
          setParent ..;

          setUITemplate -pst "nkBdnToolTemplateFlat";

          string $bakeFrame = `frameLayout -l "Bake" -cl false "bakeFrame"`;
            string $bakeColumn = `columnLayout "bakeColumn"`;
              string $bakeTimeRangeRadioButton = `radioButtonGrp
                  -cw3 90 78 78
                  -l "Time Range:"
                  -la2 "Time Slider" "Start/End"
                  -nrb 2
                  -sl 1
                  "bakeTimeRangeRadioButton"`;
              string $bakeStartEndField = `floatFieldGrp
                  -adj 0
                  -cw3 90 74 74
                  -l "Start/End:"
                  -nf 2
                  -pre 3
                  -tze true
                  -v1 0.0 -v2 30.0
                  "bakeStartEndField"`;
              string $bakeSelectedButton = `button
                  -l "Bake Selected"
                  "bakeSelectedButton"`;
            setParent ..;
          setParent ..;

        setParent ..;
      setParent ..;
    setParent ..;

  setUITemplate -ppt;

  formLayout -e
      -af $menuBar "top" 0
      -af $menuBar "left" 0
      -af $menuBar "right" 0
      -ac $scroll "top" 0 $menuBar
      -af $scroll "left" 0
      -af $scroll "right" 0
      -af $scroll "bottom" 0
      $outerForm;

  window -e -cc "nkBdnToolEventController(\"nkBdnToolWindow\", \"cc\", \"nkBdnToolWindow\");" $nkBdnToolWindow;
  menuItem -e -c "nkBdnToolEventController(\"nkBdnToolWindow\", \"c\", \"resetWindowMenuItem\");" $resetWindowMenuItem;
  menuItem -e -c "nkBdnToolEventController(\"nkBdnToolWindow\", \"c\", \"quitMenuItem\");" $quitMenuItem;
  menuItem -e -c "nkBdnToolEventController(\"nkBdnToolWindow\", \"c\", \"aboutMenuItem\");" $aboutMenuItem;

  button -e -c "nkBdnToolEventController(\"nkBdnToolWindow\", \"c\", \"bdnPluginLoadButton\");" $bdnPluginLoadButton;
  button -e -c "nkBdnToolEventController(\"nkBdnToolWindow\", \"c\", \"bdnPluginUnloadButton\");" $bdnPluginUnloadButton;
  button -e -c "nkBdnToolEventController(\"nkBdnToolWindow\", \"c\", \"deleteAllButton\");" $deleteAllButton;

  button -e -c "nkBdnToolEventController(\"nkBdnToolWindow\", \"c\", \"selectTimeNodeButton\");" $selectTimeNodeButton;
  button -e -c "nkBdnToolEventController(\"nkBdnToolWindow\", \"c\", \"selectBdnNodesFromDynamicsJointsButton\");" $selectBdnNodesFromDynamicsJointsButton;
  button -e -c "nkBdnToolEventController(\"nkBdnToolWindow\", \"c\", \"selectTargetJointsFromDynamicsJointsButton\");" $selectTargetJointsFromDynamicsJointsButton;

  textFieldButtonGrp -e -bc "nkBdnToolEventController(\"nkBdnToolWindow\", \"bc\", \"controlNodeText\");" $controlNodeText;
  button -e -c "nkBdnToolEventController(\"nkBdnToolWindow\", \"c\", \"generateDynamicsUnitButton\");" $generateDynamicsUnitButton;

  button -e -c "nkBdnToolEventController(\"nkBdnToolWindow\", \"c\", \"createColliderInfinitePlaneButton\");" $createColliderInfinitePlaneButton;
  button -e -c "nkBdnToolEventController(\"nkBdnToolWindow\", \"c\", \"createColliderSphereButton\");" $createColliderSphereButton;
  button -e -c "nkBdnToolEventController(\"nkBdnToolWindow\", \"c\", \"createColliderCapsuleButton\");" $createColliderCapsuleButton;
  // button -e -c "nkBdnToolEventController(\"nkBdnToolWindow\", \"c\", \"saveColliderSetButton\");" $saveColliderSetButton;
  // button -e -c "nkBdnToolEventController(\"nkBdnToolWindow\", \"c\", \"loadColliderSetButton\");" $loadColliderSetButton;
  textFieldButtonGrp -e -bc "nkBdnToolEventController(\"nkBdnToolWindow\", \"bc\", \"bdnNodeText\");" $bdnNodeText;
  button -e -c "nkBdnToolEventController(\"nkBdnToolWindow\", \"c\", \"appendColliderToBdnButton\");" $appendColliderToBdnButton;
  button -e -c "nkBdnToolEventController(\"nkBdnToolWindow\", \"c\", \"removeColliderFromBdnButton\");" $removeColliderFromBdnButton;

  button -e -c "nkBdnToolEventController(\"nkBdnToolWindow\", \"c\", \"bakeSelectedButton\");" $bakeSelectedButton;

  appendUIControls({
    $nkBdnToolWindow,
    $bdnBaseNameText,
    $controlNodeText,
    $generateTargetJointCheckBox,
    $generateEndJointCheckBox,
    $endJointOffsetField,
    $generateRadiusSphereCheckBox,
    $constraintTypeRadioButton,
    $bdnNodeText,
    $bakeTimeRangeRadioButton,
    $bakeStartEndField
  });

  showWindow $nkBdnToolWindow;
  setFocus $nkBdnToolWindow;
}

// -----------------------------------------------------------------------------
// イベントコントローラ
// -----------------------------------------------------------------------------
/*-
@param $window <string>
@param $event <string>
@param $control <string>
@returns <>
*/
global proc nkBdnToolEventController(
  string $window,
  string $event,
  string $control
) {
  // print("nkBdnToolEventController\n"); // debug
  // print("  window :" + $window + "\n"); // debug
  // print("  event  :" + $event + "\n"); // debug
  // print("  control:" + $control + "\n"); // debug
  switch ($window) {
    case "nkBdnToolWindow":
      switch ($event) {
        case "bc":
          switch ($control) {
            case "controlNodeText": controlNodeTextPressed(); break;
            case "bdnNodeText": bdnNodeTextPressed(); break;
            default: break;
          }
          break;
        case "c":
          switch ($control) {
            case "resetWindowMenuItem": resetWindowMenuItemSelected(); break;
            case "quitMenuItem": quitMenuItemSelected(); break;
            case "aboutMenuItem": aboutMenuItemSelected(); break;

            case "bdnPluginLoadButton": bdnPluginLoadButtonPressed(); break;
            case "bdnPluginUnloadButton": bdnPluginUnloadButtonPressed(); break;
            case "deleteAllButton": deleteAllButtonPressed(); break;

            case "selectTimeNodeButton": selectTimeNodeButtonPressed(); break;
            case "selectBdnNodesFromDynamicsJointsButton": selectBdnNodesFromDynamicsJointsButtonPressed(); break;
            case "selectTargetJointsFromDynamicsJointsButton": selectTargetJointsFromDynamicsJointsButtonPressed(); break;

            case "generateDynamicsUnitButton": generateDynamicsUnitButtonPressed(); break;

            case "createColliderInfinitePlaneButton": createColliderInfinitePlaneButtonPressed(); break;
            case "createColliderSphereButton": createColliderSphereButtonPressed(); break;
            case "createColliderCapsuleButton": createColliderCapsuleButtonPressed(); break;
            // case "saveColliderSetButton": saveColliderSetButtonPressed(); break;
            // case "loadColliderSetButton": loadColliderSetButtonPressed(); break;
            case "appendColliderToBdnButton": appendColliderToBdnButtonPressed(); break;
            case "removeColliderFromBdnButton": removeColliderFromBdnButtonPressed(); break;

            case "bakeSelectedButton": bakeSelectedButtonPressed(); break;
            default: break;
          }
          break;
        default: break;
      }
      break;
    default: break;
  }
}

// /////////////////////////////////////////////////////////////////////////////
// オブザーバ
// /////////////////////////////////////////////////////////////////////////////
// -----------------------------------------------------------------------------
// ドメインオブザーバ
// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// イベントオブザーバ
// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// ノードオブザーバ
// -----------------------------------------------------------------------------

// /////////////////////////////////////////////////////////////////////////////
// メイン
// /////////////////////////////////////////////////////////////////////////////
/*-
@returns <string>
*/
global proc string nkBdnToolVersion() {
  return "0.2.0";
}

/*-
@returns <>
*/
global proc nkBdnTool() {
  buildMainWindow();
  // registerEventJob();
}

/*
eval ("source \"" + `getenv "MAYA_APP_DIR"` + "/dev/nkBdnTool/nkBdnTool.mel\"");
nkBdnTool;
*/

// /////////////////////////////////////////////////////////////////////////////
// テスト
// /////////////////////////////////////////////////////////////////////////////
/*-
@returns <>
@remarks プラグイン。
*/
proc test0() {
  print("test0 start\n");
  string $r;

  // isPluginLoaded / loadBdnPlugin / unloadBdnPlugin
  {
    testNewScene();

    $r = assertFalse(isPluginLoaded()); if (`size $r`) warning $r;
    loadBdnPlugin();
    $r = assertTrue(isPluginLoaded()); if (`size $r`) warning $r;
    unloadBdnPlugin();
    $r = assertFalse(isPluginLoaded()); if (`size $r`) warning $r;
  }

  print("test0 end\n");
}

/*-
@returns <>
@remarks BDNノード。
*/
proc test1() {
  print("test1 start\n");
  string $r;
  string $n;

  // initBDNNode
  {
    testNewScene();

    $n = longNameOf(`createNode -ss "transform"`);

    $r = assertStringEqual($n, initBDNNode($n)); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $n`); if (`size $r`) warning $r;
    $r = assertStringEqual("type=\"bdn\";", getDictValue($n, "bdnData")); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l ($n + ".bdnData")`); if (`size $r`) warning $r;

    if (`objExists $n`) delete $n;
  }

  // initColliderGroupNode
  {
    testNewScene();

    $n = longNameOf(`createNode -ss "transform"`);

    $r = assertStringEqual($n, initColliderGroupNode($n)); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $n`); if (`size $r`) warning $r;
    $r = assertStringEqual("type=\"colliderGroup\";", getDictValue($n, "bdnData")); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l ($n + ".bdnData")`); if (`size $r`) warning $r;

    if (`objExists $n`) delete $n;
  }

  // initColliderIdentityNode
  {
    testNewScene();

    $n = longNameOf(`createNode -ss "transform"`);

    $r = assertStringEqual($n, initColliderIdentityNode($n)); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $n`); if (`size $r`) warning $r;
    $r = assertStringEqual("type=\"colliderIdentity\";", getDictValue($n, "bdnData")); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l ($n + ".bdnData")`); if (`size $r`) warning $r;

    if (`objExists $n`) delete $n;
  }

  // initColliderNode
  {
    testNewScene();

    $n = longNameOf(`createNode -ss "transform"`);

    $r = assertStringEqual($n, initColliderNode($n, "Test")); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $n`); if (`size $r`) warning $r;
    $r = assertStringEqual("type=\"collider\";colliderType=\"Test\";", getDictValue($n, "bdnData")); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l ($n + ".bdnData")`); if (`size $r`) warning $r;

    if (`objExists $n`) delete $n;
  }

  print("test1 end\n");
}

/*-
@returns <>
@remarks
*/
proc test2() {
  print("test2 start\n");
  string $r;

  print("test2 end\n");
}

/*-
@param $flags <boolean[]>
@returns <>
*/
global proc nkBdnToolTest(int $flags[]) {
  if ($flags[0]) test0();
  if ($flags[1]) test1();
  // if ($flags[2]) test2();
}

/*
eval ("source \"" + `getenv "MAYA_APP_DIR"` + "/dev/nkBdnTool/nkBdnTool.mel\"");
nkBdnToolTest({1, 1});
*/
