/*! © 2024 imaoki | MIT License | https://github.com/imaoki */

// /////////////////////////////////////////////////////////////////////////////
// ボイラープレート
// /////////////////////////////////////////////////////////////////////////////
/*1.0.0:Python*/proc string escapeStringForPython(string $input) {string $escapedText;int $size = `size $input`;for ($i = 1; $i <= $size; $i++) {string $c = `substring $input $i $i`;switch ($c) {case "\\": $escapedText += "\\\\"; break;case "'": $escapedText += "\\'"; break;case "\n": $escapedText += "\\n"; break;case "\r": $escapedText += "\\r"; break;default: $escapedText += $c; break;}}return $escapedText;}proc string convertStringForPythonString(string $input) {return ("'" + escapeStringForPython($input) + "'");}proc string convertStringArrayForPythonList(string $input[]) {string $literal = "[";for ($i = 0; $i < `size $input`; $i++) {if ($i > 0) {$literal += ", ";}$literal += convertStringForPythonString($input[$i]);}$literal += "]";return $literal;}proc string convertStringArrayForPythonTuple(string $input[]) {string $literal = "(";for ($i = 0; $i < `size $input`; $i++) {if ($i > 0) {$literal += ", ";}$literal += convertStringForPythonString($input[$i]);}$literal += ")";return $literal;}
// -----------------------------------------------------------------------------
/*1.1.2:Array*/global int $nkArrayIsInitialized;proc nkArrayInitializeParameters(int $force) {global int $nkArrayIsInitialized;if ($force || !$nkArrayIsInitialized) {python("import re");python("nkArrayCharSortOrder = '_-,;:!?.\\'\"()[]{}@*/\\&#%`^+<=>|~$0123456789aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ'");python("nkArrayCharTable = str.maketrans(nkArrayCharSortOrder, ''.join(sorted(nkArrayCharSortOrder)))");python("nkArrayPunctuationPattern = r'[_\\-,;:!?\\.\\'\"()\\[\\]{}@*/\\\\&#%`^+<=>|~$]'");python("nkArrayPunctuationDegitPattern = r'([_\\-,;:!?\\.\\'\"()\\[\\]{}@*/\\\\&#%`^+<=>|~$]|[0-9]+)'");$nkArrayIsInitialized = true;}}proc int minFloatArrayCount(float $a[], float $b[]) {int $numA = `size $a`;int $numB = `size $b`;return `min $numA $numB`;}proc int minIntArrayCount(int $a[], int $b[]) {int $numA = `size $a`;int $numB = `size $b`;return `min $numA $numB`;}proc int minStringArrayCount(string $a[], string $b[]) {int $numA = `size $a`;int $numB = `size $b`;return `min $numA $numB`;}proc string[] nsort(string $input[]) {string $result[] = `python("sorted(" + convertStringArrayForPythonList($input) + ", key=lambda item: [" + "(" + "0 if re.fullmatch(nkArrayPunctuationPattern, part) else " + "1 if part.isdigit() else " + "2, " + "int(part) if part.isdigit() else part.translate(nkArrayCharTable)" + ")" + " for part in re.split(nkArrayPunctuationDegitPattern, item)" + "]" + ")")`;if (`size $result` == 1 && !`size $result[0]`) clear $result;return $result;}nkArrayInitializeParameters(false);
/*1.2.0:Assertion*/proc string assertTrue(int $a) {return ($a == true) ? "" : ("Assert: expected 1, got " + $a);}proc string assertFalse(int $a) {return ($a == false) ? "" : ("Assert: expected 0, got " + $a);}proc string assertFloatEqual(float $e, float $a, float $t) {return (`abs ($e - $a)` <= $t) ? "" : ("Assert: expected " + $e + ", got " + $a);}proc string assertFloatNotEqual(float $e, float $a, float $t) {return (`abs ($e - $a)` > $t) ? "" : ("Assert: expected " + $e + ", got " + $a);}proc string assertIntEqual(int $e, int $a) {return ($a == $e) ? "" : ("Assert: expected " + $e + ", got " + $a);}proc string assertIntNotEqual(int $e, int $a) {return ($a != $e) ? "" : ("Assert: expected " + $e + ", got " + $a);}proc string assertStringEqual(string $e, string $a) {return ($a == $e) ? "" : ("Assert: expected " + $e + ", got " + $a);}proc string assertStringNotEqual(string $e, string $a) {return ($a != $e) ? "" : ("Assert: expected " + $e + ", got " + $a);}proc string assertStringMatch(string $e, string $a) {return (!`size $e` || `match $e $a` != "") ? "" : ("Assert: expected " + $e + ", got " + $a);}proc string assertStringMismatch(string $e, string $a) {return (!`size $e` || `match $e $a` == "") ? "" : ("Assert: expected " + $e + ", got " + $a);}proc string assertFloatArrayEqual(float $es[], float $as[], float $t) {int $numAs = `size $as`;int $isEqual = $numAs == `size $es`;if ($isEqual) {for ($i = 0; $i < $numAs; $i++) {$isEqual = `abs ($es[$i] - $as[$i])` <= $t;if (!$isEqual) break;}}return ($isEqual) ? "" : ("Assert: expected {" + floatArrayToString($es, ", ") + "}, got {" + floatArrayToString($as, ", ") + "}");}proc string assertIntArrayEqual(int $es[], int $as[]) {int $numAs = `size $as`;int $isEqual = $numAs == `size $es`;if ($isEqual) {for ($i = 0; $i < $numAs; $i++) {$isEqual = $as[$i] == $es[$i];if (!$isEqual) break;}}return ($isEqual) ? "" : ("Assert: expected {" + intArrayToString($es, ", ") + "}, got {" + intArrayToString($as, ", ") + "}");}proc string assertStringArrayEqual(string $es[], string $as[]) {int $numAs = `size $as`;int $isEqual = $numAs == `size $es`;if ($isEqual) {for ($i = 0; $i < $numAs; $i++) {$isEqual = $as[$i] == $es[$i];if (!$isEqual) break;}}return ($isEqual) ? "" : ("Assert: expected {" + stringArrayToString($es, ", ") + "}, got {" + stringArrayToString($as, ", ") + "}");}proc testNewScene() {file -f -new;}proc testOpenScene(string $filename) {file -f -op "v=0;"  -iv  -typ "mayaAscii" -pmt false -o $filename;}
/*1.16.0:Attribute*/proc int existsAttribute(string $node, string $attribute) {if (!`objExists $node`) return false;if (`gmatch $attribute "*\\[*\\]"`) {string $buffer[];if (`tokenize $attribute "[]" $buffer` < 2) return false;return `attributeQuery -ex -n $node $buffer[0]`;}else if (`gmatch $attribute "*.*"`) {string $buffer[];int $numBuffer = `tokenize $attribute "." $buffer`;if ($numBuffer < 2) return false;string $parentAttribute = $node;for ($i = 0; $i < $numBuffer - 1; $i++) {$parentAttribute += "." + $buffer[$i];}string $targetAttribute = $buffer[$numBuffer - 1];return `attributeQuery -ex -n $parentAttribute $targetAttribute`;}else {return `attributeQuery -ex -n $node $attribute`;}}proc string getAttributeType(string $node, string $attribute) {if (!existsAttribute($node, $attribute)) return "";return `getAttr -typ ($node + "." + $attribute)`;}proc int isAttributeType(string $node, string $attribute, string $type) {return (getAttributeType($node, $attribute) == $type);}proc int isAttributeMulti(string $node, string $attribute) {if (!existsAttribute($node, $attribute)) return false;return `attributeQuery -m -n $node $attribute`;}proc int getMultiAttributeSize(string $node, string $attribute) {if (!isAttributeMulti($node, $attribute)) return 0;return `getAttr -s ($node + "." + $attribute)`;}proc int isAttributeSettable(string $node, string $attribute) {if (!existsAttribute($node, $attribute)) return false;return `getAttr -se ($node + "." + $attribute)`;}proc int isAttributeKeyable(string $node, string $attribute) {if (!existsAttribute($node, $attribute)) return false;return `getAttr -k ($node + "." + $attribute)`;}proc setAttributeKeyable(string $node, string $attribute, int $state) {if (!existsAttribute($node, $attribute)) return;setAttr -k $state ($node + "." + $attribute);}proc batchSetAttributeKeyable(string $nodes[], string $attributes[], int $state) {for ($n in $nodes) {for ($attribute in $attributes) {setAttributeKeyable($n, $attribute, $state);}}}proc int isAttributeChannelBox(string $node, string $attribute) {if (!existsAttribute($node, $attribute)) return false;return `getAttr -cb ($node + "." + $attribute)`;}proc setAttributeChannelBox(string $node, string $attribute, int $state) {if (!existsAttribute($node, $attribute)) return;if (!$state) {setAttributeKeyable($node, $attribute, $state);}setAttr -cb $state ($node + "." + $attribute);}proc batchSetAttributeChannelBox(string $nodes[], string $attributes[], int $state) {for ($n in $nodes) {for ($attribute in $attributes) {setAttributeChannelBox($n, $attribute, $state);}}}proc int isAttributeLocked(string $node, string $attribute) {if (!existsAttribute($node, $attribute)) return true;return `getAttr -l ($node + "." + $attribute)`;}proc setAttributeLock(string $node, string $attribute, int $state) {if (!existsAttribute($node, $attribute)) return;setAttr -l $state ($node + "." + $attribute);}proc batchSetAttributeLock(string $nodes[], string $attributes[], int $state) {for ($n in $nodes) {for ($attribute in $attributes) {setAttributeLock($n, $attribute, $state);}}}proc string[] getEnumLabels(string $node, string $attribute) {string $labels[];if (!isAttributeType($node, $attribute, "enum")) return $labels;string $enumLabels[] = `attributeQuery -le -n $node $attribute`;if (!(`size $enumLabels` && `size $enumLabels[0]`)) return $labels;tokenize $enumLabels[0] ":" $labels;if (`size $labels` == 1 && !`size $labels[0]`) clear $labels;return $labels;}proc string attributeNameInPascalCase(string $node, string $attribute) {string $pascalName;if (!existsAttribute($node, $attribute)) return $pascalName;$pascalName = `attributeName -n ($node + "." + $attribute)`;$pascalName = substituteAllString($pascalName, " ", "");return $pascalName;}proc int addProxyAttributes(string $sourceNode,string $attributes[],string $proxyNode) {if ( !`objExists $sourceNode` || !`size $attributes` || !`objExists $proxyNode`) return false;for ($attribute in $attributes) {if ( !existsAttribute($sourceNode, $attribute) || existsAttribute($proxyNode, $attribute)) continue;addAttr -ln $attribute -pxy ($sourceNode + "." + $attribute) $proxyNode;}return true;}proc float getFloatAttribute(string $node, string $attribute, float $default) {if (!existsAttribute($node, $attribute)) return $default;return `getAttr ($node + "." + $attribute)`;}proc setFloatAttribute(string $node, string $attribute, float $value) {if (!isAttributeSettable($node, $attribute)) return;if (`attributeQuery -mxe -n $node $attribute`) {float $max[] = `attributeQuery -max -n $node $attribute`;if ($value > $max[0]) $value = $max[0];}if (`attributeQuery -mne -n $node $attribute`) {float $min[] = `attributeQuery -min -n $node $attribute`;if ($value < $min[0]) $value = $min[0];}setAttr ($node + "." + $attribute) $value;}proc batchSetFloatAttribute(string $nodes[], string $attribute, float $value) {for ($n in $nodes) {setFloatAttribute($n, $attribute, $value);}}proc float[] getFloat3Attribute(string $node, string $attribute, float $defaults[]) {if (!existsAttribute($node, $attribute)) return $defaults;return `getAttr ($node + "." + $attribute)`;}proc setFloat3Attribute(string $node, string $attribute, float $values[]) {if (!isAttributeSettable($node, $attribute) || `size $values` != 3) return;if (`attributeQuery -mxe -n $node $attribute`) {float $max[] = `attributeQuery -max -n $node $attribute`;if ($values[0] > $max[0]) $values[0] = $max[0];if ($values[1] > $max[1]) $values[1] = $max[1];if ($values[2] > $max[2]) $values[2] = $max[2];}if (`attributeQuery -mne -n $node $attribute`) {float $min[] = `attributeQuery -min -n $node $attribute`;if ($values[0] < $min[0]) $values[0] = $min[0];if ($values[1] < $min[1]) $values[1] = $min[1];if ($values[2] < $min[2]) $values[2] = $min[2];}setAttr ($node + "." + $attribute) $values[0] $values[1] $values[2];}proc batchSetFloat3Attribute(string $nodes[], string $attribute, float $values[]) {for ($n in $nodes) {setFloat3Attribute($n, $attribute, $values);}}proc int getIntAttribute(string $node, string $attribute, int $default) {if (!existsAttribute($node, $attribute)) return $default;return `getAttr ($node + "." + $attribute)`;}proc setIntAttribute(string $node, string $attribute, int $value) {if (!isAttributeSettable($node, $attribute)) return;if (`attributeQuery -mxe -n $node $attribute`) {float $max[] = `attributeQuery -max -n $node $attribute`;if ($value > $max[0]) $value = (int) $max[0];}if (`attributeQuery -mne -n $node $attribute`) {float $min[] = `attributeQuery -min -n $node $attribute`;if ($value < $min[0]) $value = (int) $min[0];}setAttr ($node + "." + $attribute) $value;}proc batchSetIntAttribute(string $nodes[], string $attribute, int $value) {for ($n in $nodes) {setIntAttribute($n, $attribute, $value);}}proc int[] getInt3Attribute(string $node, string $attribute, int $defaults[]) {if (!existsAttribute($node, $attribute)) return $defaults;return `getAttr ($node + "." + $attribute)`;}proc setInt3Attribute(string $node, string $attribute, int $values[]) {if (!isAttributeSettable($node, $attribute) || `size $values` != 3) return;if (`attributeQuery -mxe -n $node $attribute`) {float $max[] = `attributeQuery -max -n $node $attribute`;if ($values[0] > $max[0]) $values[0] = (int) $max[0];if ($values[1] > $max[1]) $values[1] = (int) $max[1];if ($values[2] > $max[2]) $values[2] = (int) $max[2];}if (`attributeQuery -mne -n $node $attribute`) {float $min[] = `attributeQuery -min -n $node $attribute`;if ($values[0] < $min[0]) $values[0] = (int) $min[0];if ($values[1] < $min[1]) $values[1] = (int) $min[1];if ($values[2] < $min[2]) $values[2] = (int) $min[2];}setAttr ($node + "." + $attribute) $values[0] $values[1] $values[2];}proc batchSetInt3Attribute(string $nodes[], string $attribute, int $values[]) {for ($n in $nodes) {setInt3Attribute($n, $attribute, $values);}}proc string getStringAttribute(string $node, string $attribute, string $default) {string $value = $default;if (!existsAttribute($node, $attribute)) return $value;$value = `getAttr ($node + "." + $attribute)`;if (!`size $value`) $value = "";return $value;}proc setStringAttribute(string $node, string $attribute, string $value) {if (!isAttributeSettable($node, $attribute)) return;setAttr ($node + "." + $attribute) -typ "string" $value;}proc batchSetStringAttribute(string $nodes[], string $attribute, string $value) {for ($n in $nodes) {setStringAttribute($n, $attribute, $value);}}proc string[] getSourceConnections(string $node,string $attributes[],string $type,string $sourceAttributes[],string $targetAttributes[]) {string $sourceNodes[];clear $sourceAttributes;clear $targetAttributes;if (!`objExists $node`) return $sourceNodes;string $nodeFullPath = longNameOf($node);int $typeFlag = `size $type` > 0;if (`size $attributes`) {for ($attribute in $attributes) {if (!existsAttribute($nodeFullPath, $attribute)) continue;string $destPath = $nodeFullPath + "." + $attribute;string $plugs[];if ($typeFlag) {$plugs = `listConnections -d false -p true -s true -t $type $destPath`;}else {$plugs = `listConnections -d false -p true -s true $destPath`;}$plugs = stringArrayRemoveDuplicates($plugs);for ($plug in $plugs) {string $buffer[];int $numBuffer = `tokenize $plug "." $buffer`;if ($numBuffer < 2) continue;string $sourceNode = longNameOf($buffer[0]);$sourceNodes[`size $sourceNodes`] = $sourceNode;string $sourcePath = $sourceNode;for ($i = 1; $i < $numBuffer; $i++) {$sourcePath += "." + $buffer[$i];}$sourceAttributes[`size $sourceAttributes`] = $sourcePath;$targetAttributes[`size $targetAttributes`] = $destPath;}}}else {string $plugs[];if ($typeFlag) {$plugs = `listConnections -d false -p true -s true -t $type $nodeFullPath`;}else {$plugs = `listConnections -d false -p true -s true $nodeFullPath`;}$plugs = stringArrayRemoveDuplicates($plugs);for ($plug in $plugs) {string $buffer[];int $numBuffer = `tokenize $plug "." $buffer`;if ($numBuffer < 2) continue;string $sourceNode = longNameOf($buffer[0]);$sourceNodes[`size $sourceNodes`] = $sourceNode;string $sourcePath = $sourceNode;for ($i = 1; $i < $numBuffer; $i++) {$sourcePath += "." + $buffer[$i];}string $targetPlugs[] = `listConnections -d true -p true -s false $sourcePath`;$targetPlugs = stringArrayRemoveDuplicates($targetPlugs);for ($targetPlug in $targetPlugs) {string $targetBuffer[];int $numTargetBuffer = `tokenize $targetPlug "." $targetBuffer`;if ($numTargetBuffer < 2) continue;string $targetNode = longNameOf($targetBuffer[0]);if ($targetNode != $nodeFullPath) continue;string $destPath = $targetNode;for ($i = 1; $i < $numTargetBuffer; $i++) {$destPath += "." + $targetBuffer[$i];}$sourceAttributes[`size $sourceAttributes`] = $sourcePath;$targetAttributes[`size $targetAttributes`] = $destPath;}}}$sourceNodes = stringArrayRemoveDuplicates($sourceNodes);for ($i = 0; $i < `size $sourceNodes`; $i++) {$sourceNodes[$i] = longNameOf($sourceNodes[$i]);}return $sourceNodes;}proc string[] getDestConnections(string $node,string $attributes[],string $type,string $sourceAttributes[],string $targetAttributes[]) {string $destNodes[];clear $sourceAttributes;clear $targetAttributes;if (!`objExists $node`) return $destNodes;string $nodeFullPath = longNameOf($node);int $typeFlag = `size $type` > 0;if (`size $attributes`) {for ($attribute in $attributes) {if (!existsAttribute($nodeFullPath, $attribute)) continue;string $sourcePath = $nodeFullPath + "." + $attribute;string $plugs[];if ($typeFlag) {$plugs = `listConnections -d true -p true -s false -t $type $sourcePath`;}else {$plugs = `listConnections -d true -p true -s false $sourcePath`;}$plugs = stringArrayRemoveDuplicates($plugs);for ($plug in $plugs) {string $buffer[];int $numBuffer = `tokenize $plug "." $buffer`;if ($numBuffer < 2) continue;string $destNode = longNameOf($buffer[0]);$destNodes[`size $destNodes`] = $destNode;string $destPath = $destNode;for ($i = 1; $i < $numBuffer; $i++) {$destPath += "." + $buffer[$i];}$sourceAttributes[`size $sourceAttributes`] = $sourcePath;$targetAttributes[`size $targetAttributes`] = $destPath;}}}else {string $plugs[];if ($typeFlag) {$plugs = `listConnections -d true -p true -s false -t $type $nodeFullPath`;}else {$plugs = `listConnections -d true -p true -s false $nodeFullPath`;}$plugs = stringArrayRemoveDuplicates($plugs);for ($plug in $plugs) {string $buffer[];int $numBuffer = `tokenize $plug "." $buffer`;if ($numBuffer < 2) continue;string $destNode = longNameOf($buffer[0]);$destNodes[`size $destNodes`] = $destNode;string $destPath = $destNode;for ($i = 1; $i < $numBuffer; $i++) {$destPath += "." + $buffer[$i];}string $sourcePlugs[] = `listConnections -d false -p true -s true $destPath`;$sourcePlugs = stringArrayRemoveDuplicates($sourcePlugs);for ($sourcePlug in $sourcePlugs) {string $sourceBuffer[];int $numSourceBuffer = `tokenize $sourcePlug "." $sourceBuffer`;if ($numSourceBuffer < 2) continue;string $sourceNode = longNameOf($sourceBuffer[0]);if ($sourceNode != $nodeFullPath) continue;string $sourcePath = $sourceNode;for ($i = 1; $i < $numSourceBuffer; $i++) {$sourcePath += "." + $sourceBuffer[$i];}$sourceAttributes[`size $sourceAttributes`] = $sourcePath;$targetAttributes[`size $targetAttributes`] = $destPath;}}}$destNodes = stringArrayRemoveDuplicates($destNodes);for ($i = 0; $i < `size $destNodes`; $i++) {$destNodes[$i] = longNameOf($destNodes[$i]);}return $destNodes;}proc connectAttributes(string $sourceAttributes[],string $targetAttributes[],int $force) {int $numAttributes = `size $sourceAttributes`;if (`size $targetAttributes` != $numAttributes) return;for ($i = 0; $i < $numAttributes; $i++) {string $sourceAttribute = $sourceAttributes[$i];string $targetAttribute = $targetAttributes[$i];if (`isConnected -iuc $sourceAttribute $targetAttribute`) continue;if ($force) {connectAttr -f $sourceAttribute $targetAttribute;}else {connectAttr $sourceAttribute $targetAttribute;}}}proc disconnectAttributes(string $sourceAttributes[],string $targetAttributes[]) {int $numAttributes = `size $sourceAttributes`;if (`size $targetAttributes` != $numAttributes) return;for ($i = 0; $i < $numAttributes; $i++) {string $sourceAttribute = $sourceAttributes[$i];string $targetAttribute = $targetAttributes[$i];if (!`isConnected -iuc $sourceAttribute $targetAttribute`) continue;disconnectAttr $sourceAttribute $targetAttribute;}}proc string getMessageSource(string $node, string $attribute) {string $sourceNode;if (!(isAttributeType($node, $attribute, "message") && !isAttributeMulti($node, $attribute))) return $sourceNode;string $sourceNodes[] = getSourceConnections($node, {$attribute}, "", {}, {});if (`size $sourceNodes` != 1) return $sourceNode;return longNameOf($sourceNodes[0]);}proc connectMessage(string $sourceNode, string $node, string $attribute) {if (!(existsAttribute($sourceNode, "message") && isAttributeType($node, $attribute, "message") && !isAttributeMulti($node, $attribute))) return;connectAttributes({$sourceNode + ".message"}, {$node + "." + $attribute}, true);}proc disconnectMessage(string $sourceNode, string $node, string $attribute) {if (!(existsAttribute($sourceNode, "message") && isAttributeType($node, $attribute, "message") && !isAttributeMulti($node, $attribute))) return;disconnectAttributes({$sourceNode + ".message"}, {$node + "." + $attribute});}proc string[] getMultiMessageSources(string $node, string $attribute) {string $sourceNodes[];if (!(isAttributeType($node, $attribute, "message") && isAttributeMulti($node, $attribute))) return $sourceNodes;$sourceNodes = getSourceConnections($node, {$attribute}, "", {}, {});return stringArrayRemoveDuplicates($sourceNodes);}proc appendMultiMessage(string $sourceNodes[], string $node, string $attribute) {if (!(isAttributeType($node, $attribute, "message") && isAttributeMulti($node, $attribute))) return;string $newNodes[];int $size = getMultiAttributeSize($node, $attribute);for ($i = 0; $i < $size; $i++) {$newNodes = stringArrayCatenate($newNodes,getSourceConnections($node, {$attribute + "[" + $i + "]"}, "", {}, {}));removeMultiInstance -b true ($node + "." + $attribute + "[" + $i + "]");}$newNodes = stringArrayCatenate($newNodes, $sourceNodes);$newNodes = stringArrayRemoveDuplicates($newNodes);for ($i = 0; $i < `size $newNodes`; $i++) {if (!existsAttribute($newNodes[$i], "message")) continue;connectAttributes({$newNodes[$i] + ".message"},{$node + "." + $attribute + "[" + $i + "]"},true);}}proc removeMultiMessage(string $sourceNodes[], string $node, string $attribute) {if (!(isAttributeType($node, $attribute, "message") && isAttributeMulti($node, $attribute))) return;string $newNodes[];int $size = getMultiAttributeSize($node, $attribute);for ($i = 0; $i < $size; $i++) {$newNodes = stringArrayCatenate($newNodes,getSourceConnections($node, {$attribute + "[" + $i + "]"}, "", {}, {}));removeMultiInstance -b true ($node + "." + $attribute + "[" + $i + "]");}$newNodes = `stringArrayRemove $sourceNodes $newNodes`;$newNodes = stringArrayRemoveDuplicates($newNodes);for ($i = 0; $i < `size $newNodes`; $i++) {if (!existsAttribute($newNodes[$i], "message")) continue;connectAttributes({$newNodes[$i] + ".message"},{$node + "." + $attribute + "[" + $i + "]"},true);}}proc initializeRenderStats(string $nodes[]) {if (!`size $nodes`) return;for ($n in $nodes) {if (!`objExists $n`) continue;setIntAttribute($n, "castsShadows", true);setIntAttribute($n, "receiveShadows", true);setIntAttribute($n, "holdOut", false);setIntAttribute($n, "motionBlur", true);setIntAttribute($n, "primaryVisibility", true);setIntAttribute($n, "smoothShading", true);setIntAttribute($n, "visibleInReflections", true);setIntAttribute($n, "visibleInRefractions", true);setIntAttribute($n, "doubleSided", true);setIntAttribute($n, "opposite", false);setIntAttribute($n, "geometryAntialiasingOverride", false);setIntAttribute($n, "antialiasingLevel", 1);setIntAttribute($n, "shadingSamplesOverride", false);setIntAttribute($n, "shadingSamples", 1);setIntAttribute($n, "maxShadingSamples", 1);}}proc disableRenderStats(string $nodes[]) {if (!`size $nodes`) return;for ($n in $nodes) {if (!`objExists $n`) continue;setIntAttribute($n, "castsShadows", false);setIntAttribute($n, "receiveShadows", false);setIntAttribute($n, "holdOut", false);setIntAttribute($n, "motionBlur", false);setIntAttribute($n, "primaryVisibility", false);setIntAttribute($n, "smoothShading", false);setIntAttribute($n, "visibleInReflections", false);setIntAttribute($n, "visibleInRefractions", false);setIntAttribute($n, "doubleSided", false);setIntAttribute($n, "opposite", false);setIntAttribute($n, "geometryAntialiasingOverride", false);setIntAttribute($n, "shadingSamplesOverride", false);}}proc setOutlinerColor(string $nodes[], float $color[]) {if (!`size $nodes` || `size $color` != 3) return;for ($n in $nodes) {if (!`objExists $n`) continue;setIntAttribute($n, "uocol", true);setFloat3Attribute($n, "oclr", $color);}}proc setOverrideColor(string $nodes[], int $index) {if (!(0 <= $index && $index <= 31)) return;for ($n in $nodes) {if (!`objExists $n`) continue;setIntAttribute($n, "ove", true);setIntAttribute($n, "ovrgbf", 0);setIntAttribute($n, "ovc", $index);}}proc int hasShapeTransformAttributes(string $n) {return (isAttributeType($n, "shapeTranslate", "double3") && isAttributeType($n, "shapeTranslateX", "doubleLinear") && isAttributeType($n, "shapeTranslateY", "doubleLinear") && isAttributeType($n, "shapeTranslateZ", "doubleLinear") && isAttributeType($n, "shapeRotate", "double3") && isAttributeType($n, "shapeRotateX", "doubleAngle") && isAttributeType($n, "shapeRotateY", "doubleAngle") && isAttributeType($n, "shapeRotateZ", "doubleAngle") && isAttributeType($n, "shapeScale", "double3") && isAttributeType($n, "shapeScaleX", "double") && isAttributeType($n, "shapeScaleY", "double") && isAttributeType($n, "shapeScaleZ", "double"));}proc addShapeTransformAttributes(string $n) {if (!`objExists $n` || hasShapeTransformAttributes($n)) return;addAttr -at "double3"      -k false -ln "shapeTranslate"  -sn "st" $n;addAttr -at "doubleLinear" -k false -ln "shapeTranslateX" -sn "stx" -p "shapeTranslate" $n;addAttr -at "doubleLinear" -k false -ln "shapeTranslateY" -sn "sty" -p "shapeTranslate" $n;addAttr -at "doubleLinear" -k false -ln "shapeTranslateZ" -sn "stz" -p "shapeTranslate" $n;addAttr -at "double3"      -k false -ln "shapeRotate"     -sn "sr" $n;addAttr -at "doubleAngle"  -k false -ln "shapeRotateX"    -sn "srx" -p "shapeRotate" $n;addAttr -at "doubleAngle"  -k false -ln "shapeRotateY"    -sn "sry" -p "shapeRotate" $n;addAttr -at "doubleAngle"  -k false -ln "shapeRotateZ"    -sn "srz" -p "shapeRotate" $n;addAttr -at "double3"      -k false -ln "shapeScale"      -sn "ss" $n;addAttr -at "double"       -k false -ln "shapeScaleX"     -sn "ssx" -p "shapeScale" $n;addAttr -at "double"       -k false -ln "shapeScaleY"     -sn "ssy" -p "shapeScale" $n;addAttr -at "double"       -k false -ln "shapeScaleZ"     -sn "ssz" -p "shapeScale" $n;setAttr ($n + ".ss") -typ "double3" 1.0 1.0 1.0;}proc int hasCurveNameAttribute(string $n) {return isAttributeType($n, "curveName", "string");}proc addCurveNameAttribute(string $n) {if (!`objExists $n` || hasCurveNameAttribute($n)) return;addAttr -dt "string" -ln "curveName" -sn "cn" $n;}
/*1.6.0:File*/proc int isValidFilename(string $input) {return (`match "[:\?\"\*/\\<>\|\n\r\t]" $input` == "");}proc string escapeInvalidFileNameChars(string $input, string $replacement) {python("import re");string $result = `python("re.sub(r" + convertStringForPythonString("[:\?\"\*/\\<>\|\n\r\t]") + ", " + convertStringForPythonString($replacement) + ", " + convertStringForPythonString($input) + ")")`;return $result;}proc string getSourceFilename(string $procName) {string $filename;string $thisIs = `whatIs $procName`;string $pattern1 = "^Mel procedure found in: *";string $pattern2 = "^Script found in: *";if (`match $pattern1 $thisIs` != "") {$filename = `substitute $pattern1 $thisIs ""`;}else if (`match $pattern2 $thisIs` != "") {$filename = `substitute $pattern2 $thisIs ""`;}return $filename;}proc string getSourceDirname(string $procName) {return dirname(getSourceFilename($procName));}proc int existsDirname(string $dirname) {return `filetest -d $dirname`;}proc int existsFilename(string $filename) {return `filetest -f $filename`;}proc string[] getDirnames(string $dirname) {string $subDirnames[];string $filenames[] = `getFileList -fld $dirname`;for ($i = 0; $i < `size $filenames`; $i++) {string $subDirname = $dirname + "/" + $filenames[$i];if (existsDirname($subDirname)) {$subDirnames[`size $subDirnames`] = $subDirname;}}$subDirnames = `sortCaseInsensitive $subDirnames`;return $subDirnames;}proc string[] getFilenames(string $dirname, string $filenamePattern) {string $filenames[] = `getFileList -fs $filenamePattern -fld $dirname`;for ($i = 0; $i < `size $filenames`; $i++) {$filenames[$i] = $dirname + "/" + $filenames[$i];}$filenames = `sortCaseInsensitive $filenames`;return $filenames;}proc string getOpenFilename(string $caption, string $fileFilter) {string $filename;string $filenames[] = `fileDialog2 -cap $caption -ds 2 -ff $fileFilter -fm 1`;if (`size $filenames`) $filename = $filenames[0];return $filename;}proc string getSaveFilename(string $caption, string $fileFilter) {string $filename;string $filenames[] = `fileDialog2 -cap $caption -ds 2 -ff $fileFilter -fm 0`;if (`size $filenames`) $filename = $filenames[0];return $filename;}proc string[] readAllLines(string $filename, string $encoding) {if (!`size $encoding`) $encoding = "utf-8";string $lines[];if (!existsFilename($filename)) return $lines;python("with open('" + $filename + "', 'r', encoding='" + $encoding + "') as f:" + " lines = tuple(s.rstrip('\\r\\n') for s in f.readlines())");$lines = `python("lines")`;return $lines;}proc string readAllText(string $filename, string $encoding) {if (!`size $encoding`) $encoding = "utf-8";string $text;if (!existsFilename($filename)) return $text;python("with open('" + $filename + "', 'r', encoding='" + $encoding + "') as f: text = f.read()");$text = `python("text")`;return $text;}proc int writeAllText(string $filename, string $encoding, string $input) {string $dirname = dirname($filename);if (!existsDirname($dirname)) return false;if (!`size $encoding`) $encoding = "utf-8";python("with open(" + convertStringForPythonString($filename) + ", 'w', encoding=" + convertStringForPythonString($encoding) + ") as f:" + " num = f.write(" + convertStringForPythonString($input) + ")");return (existsFilename($filename));}proc int writeAllLines(string $filename, string $encoding, string $lines[]) {string $text = stringArrayToString($lines, "\n");if (`size $lines`) $text += "\n";return (writeAllText($filename, $encoding, $text));}proc int makeDirs(string $dirname) {if (existsDirname($dirname)) return true;if (existsFilename($dirname)) return false;python("import os");python("os.makedirs('" + $dirname + "')");return (existsDirname($dirname));}proc int moveDir(string $sourceDirname, string $destDirname) {if (!existsDirname($sourceDirname)) return false;if (existsDirname($destDirname) || existsFilename($destDirname)) return false;python("import os");python("os.rename('" + $sourceDirname + "', '" + $destDirname +"')");return (!existsDirname($sourceDirname) && existsDirname($destDirname));}proc int moveFile(string $sourceFilename, string $destFilename) {if (!existsFilename($sourceFilename)) return false;if (existsDirname($destFilename) || existsFilename($destFilename)) return false;python("import os");python("os.rename('" + $sourceFilename + "', '" + $destFilename +"')");return (!existsFilename($sourceFilename) && existsFilename($destFilename));}proc int deleteDir(string $dirname) {if (!existsDirname($dirname)) return false;python("import os");python("if len(os.listdir('" + $dirname + "')) == 0:" + " os.rmdir('" + $dirname + "')");return (!existsDirname($dirname));}proc int deleteFile(string $filename) {if (!existsFilename($filename)) return false;python("import os");python("os.remove('" + $filename + "')");return (!existsFilename($filename));}
/*1.20.3:Node*/proc int nodesExists(string $nodes[]) {int $numNodes = `size $nodes`;if (!$numNodes) return false;int $count;for ($n in $nodes) {if (`objExists $n`) $count += 1;}return ($count == $numNodes);}proc int isSelected(string $n) {if (!`objExists $n`) return false;string $nodes[] = `ls -l -sl $n`;return (`size $nodes` > 0);}proc string[] getShapeNodes(string $n, string $type) {if (!`objExists $n`) return {};if (`size $type`) {return `listRelatives -f -s -typ $type $n`;}else {return `listRelatives -f -s $n`;}}proc int isType(string $n, string $types[], int $isExact) {if (!`objExists $n`) return false;if (!`size $types`) return true;if ($isExact) {if (stringArrayContains(`nodeType $n`, $types)) return true;}else {string $subtypes[] = `nodeType -i $n`;for ($subtype in $subtypes) {if (stringArrayContains($subtype, $types)) return true;}}return false;}proc int hasType(string $n, string $types[], int $isExact) {if (isType($n, $types, $isExact)) return true;string $shapeNodes[] = getShapeNodes($n, "");for ($shapeNode in $shapeNodes) {if (isType($shapeNode, $types, $isExact)) return true;}return false;}proc int isTypeContains(string $nodes[], string $types[], int $isExact) {if (!`size $nodes`) return false;if (!`size $types`) return true;for ($n in $nodes) {if (isType($n, $types, $isExact)) return true;}return false;}proc int isNodeReferenced(string $n) {return (`objExists $n` && `referenceQuery -inr $n`);}proc int isConstraintNode(string $n) {return isType($n, {"constraint"}, false);}proc int isDagNode(string $n) {return isType($n, {"dagNode"}, false);}proc int isTransformNode(string $n) {return isType($n, {"transform"}, true);}proc int isJointNode(string $n) {return isType($n, {"joint"}, true);}proc int isShapeNode(string $n) {return isType($n, {"shape"}, false);}proc int isLocatorNode(string $n) {return isType($n, {"locator"}, true);}proc int hasLocatorNode(string $n) {return hasType($n, {"locator"}, true);}proc int isNurbsSurfaceNode(string $n) {return isType($n, {"nurbsSurface"}, true);}proc int hasNurbsSurfaceNode(string $n) {return hasType($n, {"nurbsSurface"}, true);}proc int isNurbsCurveNode(string $n) {return isType($n, {"nurbsCurve"}, true);}proc int hasNurbsCurveNode(string $n) {return hasType($n, {"nurbsCurve"}, true);}proc int isBezierCurveNode(string $n) {return isType($n, {"bezierCurve"}, true);}proc int hasBezierCurveNode(string $n) {return hasType($n, {"bezierCurve"}, true);}proc int isMeshNode(string $n) {return isType($n, {"mesh"}, true);}proc int hasMeshNode(string $n) {return hasType($n, {"mesh"}, true);}proc int isLightNode(string $n) {return isType($n, {"light"}, false);}proc int hasLightNode(string $n) {return hasType($n, {"light"}, false);}proc int isCameraNode(string $n) {return isType($n, {"camera"}, false);}proc int hasCameraNode(string $n) {return hasType($n, {"camera"}, false);}proc int isUUID(string $input) {string $hex = "[A-F0-9]";string $digit4 = $hex + $hex + $hex + $hex;string $digit8 = $digit4 + $digit4;string $digit12 = $digit8 + $digit4;return (isValidString($input,$digit8 + "-" + $digit4 + "-" + $digit4 + "-" + $digit4 + "-" + $digit12));}proc string toShortName(string $path) {string $shortName;if (!`size $path`) return $shortName;string $buffer1[];int $numBuffer1 = `tokenize $path "|" $buffer1`;if ($numBuffer1 > 0) {string $buffer2[];int $numBuffer2 = `tokenize $buffer1[$numBuffer1 - 1] ":" $buffer2`;if ($numBuffer2 > 0) {$shortName = $buffer2[$numBuffer2 - 1];}}return $shortName;}proc string toUUID(string $n) {string $uuid;if (!`objExists $n`) return $uuid;string $uuids[] = `ls -uid $n`;if (`size $uuids` == 1) $uuid = $uuids[0];return $uuid;}proc string uuidToLongName(string $uuid) {string $longName;if (!isUUID($uuid)) return $longName;string $nodes[] = `ls -l $uuid`;int $numNodes = `size $nodes`;if ($numNodes == 1) {$longName = $nodes[0];}else if ($numNodes > 1) {string $editableNodes[];for ($node in $nodes) {if (isNodeReferenced($node)) continue;$editableNodes[`size $editableNodes`] = $node;}if (`size $editableNodes` == 1) {$longName = $editableNodes[0];}}return $longName;}proc string setNodeName(string $n, string $newName, int $inheritNamespace) {if (!`objExists $n` || !`size $newName` || isNodeReferenced($n)) return $n;string $namespace;if ($inheritNamespace) {string $names[] = `ls -sns $n`;if (`size $names` == 2 && $names[1] != ":") {$namespace += $names[1];}}$newName = `substitute "^:+" $newName ""`;if (`gmatch $newName "*:*"`) {string $newNamespace;$newNamespace = `substitute ":[^:]+$" $newName ""`;if (`size $newNamespace`) {$namespace += ((`size $namespace`) ? ":" : "") + $newNamespace;}if (!`namespace -ex $namespace`) {namespace -add $namespace;}$newName = `match "[^:]+$" $newName`;}if (`size $namespace`) {$newName = ":" + $namespace + ":" + $newName;}string $nodeId = toUUID($n);$n = uuidToLongName($nodeId);rename $n $newName;$n = uuidToLongName($nodeId);return $n;}proc string getParentNode(string $n) {if (!`objExists $n`) return "";string $parents[] = `listRelatives -f -p $n`;if (!`size $parents`) return "";return $parents[0];}proc string[] setParentNode(string $nodes[], string $parentNode) {int $toWorld = `size $parentNode` == 0;int $parentIsDagNode = isDagNode($parentNode);if (!$toWorld && !$parentIsDagNode) return $nodes;string $nodeIds[];string $dagNodes[];for ($n in $nodes) {$nodeIds[`size $nodeIds`] = toUUID($n);if (isDagNode($n) && !isNodeReferenced($n)) {$dagNodes[`size $dagNodes`] = $n;}}int $numDagNodes = `size $dagNodes`;if (!$numDagNodes) return $nodes;string $selectedNodes[] = `ls -l -sl`;string $selectedNodeIds[];for ($n in $selectedNodes) {$selectedNodeIds[`size $selectedNodeIds`] = toUUID($n);}if ($numDagNodes) {if ($toWorld) {parent -w $dagNodes;}else if ($parentIsDagNode) {parent -a $dagNodes $parentNode;}}string $newNodes[];for ($id in $nodeIds) {$newNodes[`size $newNodes`] = uuidToLongName($id);}string $newSelectedNodes[];for ($id in $selectedNodeIds) {$newSelectedNodes[`size $newSelectedNodes`] = uuidToLongName($id);}select -r $newSelectedNodes;return $newNodes;}proc string getRootNode(string $n) {string $rootNode;if (!`objExists $n`) return $rootNode;$rootNode = $n;string $parentNode = getParentNode($rootNode);while (`objExists $parentNode`) {$rootNode = $parentNode;$parentNode = getParentNode($rootNode);}return $rootNode;}proc string[] collectRootNodes(string $nodes[]) {string $rootNodes[];if (!`size $nodes`) return $rootNodes;for ($n in $nodes) {string $rootNode = getRootNode($n);if (`objExists $rootNode`) {$rootNodes[`size $rootNodes`] = $rootNode;}}$rootNodes = stringArrayRemoveDuplicates($rootNodes);return $rootNodes;}proc string[] collectChildNodes(string $n) {string $childNodes[];if (!`objExists $n`) return $childNodes;$childNodes = `listRelatives -f -c $n`;return $childNodes;}proc string[] collectDescendantNodes(string $n,string $parentNode,string $types[],int $isExact,string $script) {string $descendantNodes[];if (!`objExists $n`) return $descendantNodes;$n = longNameOf($n);$parentNode = longNameOf($parentNode);string $sourceNode = $n;string $nextNode = $sourceNode;if (`exists $script` && isType($sourceNode, $types, $isExact)) {string $arg1 = "\"" + toUUID($sourceNode) + "\"";string $arg2 = "\"" + toUUID($parentNode) + "\"";string $result[] = `eval $script $arg1 $arg2`;if (`size $result` == 2 && (!`size $result[0]` || isUUID($result[0])) && (!`size $result[1]` || isUUID($result[1]))) {$sourceNode = uuidToLongName($result[0]);$nextNode = uuidToLongName($result[1]);}}if (`objExists $sourceNode`) {$descendantNodes[`size $descendantNodes`] = $sourceNode;}string $childNodes[] = collectChildNodes($nextNode);for ($c in $childNodes) {$descendantNodes = stringArrayCatenate($descendantNodes,collectDescendantNodes($c, $sourceNode, $types, $isExact, $script));}if (`size $types`) {for ($i = `size $descendantNodes` - 1; $i >= 0; $i--) {if (!isType($descendantNodes[$i], $types, $isExact)) {stringArrayRemoveAtIndex($i, $descendantNodes);}}}return $descendantNodes;}proc string[] collectHierarchyNodes(string $nodes[],string $parentNode,string $types[],int $isExact,string $script) {string $hierarchyNodes[];if (!`size $nodes`) return $hierarchyNodes;string $rootNodes[] = collectRootNodes($nodes);for ($n in $rootNodes) {$hierarchyNodes = stringArrayCatenate($hierarchyNodes,collectDescendantNodes($n, $parentNode, $types, $isExact, $script));}$hierarchyNodes = stringArrayRemoveDuplicates($hierarchyNodes);return $hierarchyNodes;}proc string[] gatherNodes(string $types[],int $isExact,int $selectedOnly,string $pattern) {if (!`size $pattern`) $pattern = "::*";string $nodes[];if (`size $types`) {for ($type in $types) {if ($selectedOnly) {if ($isExact) {$nodes = stringArrayCatenate($nodes, `ls -l -sl -et $type $pattern`);}else {$nodes = stringArrayCatenate($nodes, `ls -l -sl -typ $type $pattern`);}}else {if ($isExact) {$nodes = stringArrayCatenate($nodes, `ls -l -et $type $pattern`);}else {$nodes = stringArrayCatenate($nodes, `ls -l -typ $type $pattern`);}}}}else {if ($selectedOnly) {$nodes = `ls -l -sl $pattern`;}else {$nodes = `ls -l $pattern`;}}$nodes = stringArrayRemoveDuplicates($nodes);return $nodes;}proc string nodesAsCSV(string $types[],int $isExact,int $selectedOnly,string $pattern,int $singleNodeOnly) {string $nodes[] = gatherNodes($types, $isExact, $selectedOnly, $pattern);if (`size $nodes` > 1 && $singleNodeOnly) clear $nodes;return stringArrayToString($nodes, ",");}proc string[] csvAsNodes(string $input) {string $nodes[];tokenize $input "," $nodes;if (`size $nodes` == 1 && !`size $nodes[0]`) clear $nodes;return $nodes;}proc string[] getSourceConnectionNodes(string $nodes[],string $types[],int $isExact) {string $tmpNodes[];for ($n in $nodes) {if (!`objExists $n`) continue;$tmpNodes = stringArrayCatenate($tmpNodes,`listConnections -d false -p false -s true $n`);}$tmpNodes = stringArrayRemoveDuplicates($tmpNodes);string $sourceNodes[];for ($i = 0; $i < `size $tmpNodes`; $i++) {string $tmpNode = longNameOf($tmpNodes[$i]);if (isType($tmpNode, $types, $isExact)) {$sourceNodes[`size $sourceNodes`] = $tmpNode;}}$sourceNodes = `sort $sourceNodes`;return $sourceNodes;}proc string[] getDestConnectionNodes(string $nodes[],string $types[],int $isExact) {string $tmpNodes[];for ($n in $nodes) {if (!`objExists $n`) continue;$tmpNodes = stringArrayCatenate($tmpNodes,`listConnections -d true -p false -s false $n`);}$tmpNodes = stringArrayRemoveDuplicates($tmpNodes);string $destNodes[];for ($i = 0; $i < `size $tmpNodes`; $i++) {string $tmpNode = longNameOf($tmpNodes[$i]);if (isType($tmpNode, $types, $isExact)) {$destNodes[`size $destNodes`] = $tmpNode;}}$destNodes = `sort $destNodes`;return $destNodes;}proc string buildDagNode(string $n,string $name,string $parentNode,int $maintainOffset,string $matchTransformNode,int $matchFlags[]) {if (!isDagNode($n) || isNodeReferenced($n)) return $n;string $nodeId = toUUID($n);$n = uuidToLongName($nodeId);if (isDagNode($matchTransformNode)) {int $numMatchFlags = `size $matchFlags`;if (!`size $matchFlags`) {matchTransform $n $matchTransformNode;}else {if ($matchFlags[0]) matchTransform -pos $n $matchTransformNode;if ($matchFlags[1]) matchTransform -rot $n $matchTransformNode;if ($matchFlags[2]) matchTransform -scl $n $matchTransformNode;}}string $selection[] = `ls -l -sl`;int $shouldSelect = isSelected($n);if ($shouldSelect) {$selection = stringArrayRemove({$n}, $selection);}if (isDagNode($parentNode)) {if ($maintainOffset) {parent -a $n $parentNode;}else {parent -r $n $parentNode;}$n = uuidToLongName($nodeId);}if ($shouldSelect) {$selection[`size $selection`] = $n;}select -r $selection;if (`size $name`) {rename $n $name;$n = uuidToLongName($nodeId);}return $n;}proc string createJoint(string $name,string $parentNode,int $maintainOffset,string $matchTransformNode,int $matchFlags[]) {return (buildDagNode(longNameOf(`createNode -ss "joint"`),$name,$parentNode,$maintainOffset,$matchTransformNode,$matchFlags));}proc string createLocator(string $name,string $parentNode,int $maintainOffset,string $matchTransformNode,int $matchFlags[]) {return (buildDagNode(getParentNode(longNameOf(`createNode -ss "locator"`)),$name,$parentNode,$maintainOffset,$matchTransformNode,$matchFlags));}proc string createTransform(string $name,string $parentNode,int $maintainOffset,string $matchTransformNode,int $matchFlags[]) {return (buildDagNode(longNameOf(`createNode -ss "transform"`),$name,$parentNode,$maintainOffset,$matchTransformNode,$matchFlags));}proc string getTopLevelNode(string $topLevelName,int $shouldCreate,int $ignoreReference) {string $n;if (!`size $topLevelName`) return "";string $nodes[] = `ls -l ("::" + $topLevelName)`;int $numNodes = `size $nodes`;if ($ignoreReference) {for ($i = $numNodes - 1; $i >= 0; $i--) {if (isNodeReferenced($nodes[$i])) {$nodes = `stringArrayRemove {$nodes[$i]} $nodes`;$numNodes--;}}}if ($numNodes > 1) return "";$n = ($numNodes == 1) ? $nodes[0] : "";if (`objExists $n`) return $n;if ($shouldCreate) {$n = createTransform($topLevelName, "", true, "", {});}return $n;}proc string getSecondLevelNode(string $topLevelName,string $secondLevelName,int $shouldCreate,int $ignoreReference) {string $n;if (!`size $topLevelName` || !`size $secondLevelName`) return "";string $nodes[] = `ls -l ("|::" + $topLevelName + "|::" + $secondLevelName)`;int $numNodes = `size $nodes`;if ($ignoreReference) {for ($i = $numNodes - 1; $i >= 0; $i--) {if (isNodeReferenced($nodes[$i])) {$nodes = `stringArrayRemove {$nodes[$i]} $nodes`;$numNodes--;}}}if ($numNodes > 1) return "";$n = ($numNodes == 1) ? $nodes[0] : "";if (`objExists $n`) return $n;if ($shouldCreate) {string $topLevelNode = getTopLevelNode($topLevelName,$shouldCreate,$ignoreReference);if (!`objExists $topLevelNode`) return "";$n = createTransform($secondLevelName, $topLevelNode, true, "", {});}return $n;}proc string getThirdLevelNode(string $topLevelName,string $secondLevelName,string $thirdLevelName,int $shouldCreate,int $ignoreReference) {string $n;if ( !`size $topLevelName` || !`size $secondLevelName` || !`size $thirdLevelName`) return "";string $nodes[] = `ls -l ("|::" + $topLevelName + "|::" + $secondLevelName + "|::" + $thirdLevelName)`;int $numNodes = `size $nodes`;if ($ignoreReference) {for ($i = $numNodes - 1; $i >= 0; $i--) {if (isNodeReferenced($nodes[$i])) {$nodes = `stringArrayRemove {$nodes[$i]} $nodes`;$numNodes--;}}}if ($numNodes > 1) return "";$n = ($numNodes == 1) ? $nodes[0] : "";if (`objExists $n`) return $n;if ($shouldCreate) {string $secondLevelNode = getSecondLevelNode($topLevelName,$secondLevelName,$shouldCreate,$ignoreReference);if (!`objExists $secondLevelNode`) return "";$n = createTransform($thirdLevelName, $secondLevelNode, true, "", {});}return $n;}proc freezeTransform(string $nodes[], int $preserveFlags[]) {string $dagNodes[];for ($n in $nodes) {if (isDagNode($n)) $dagNodes[`size $dagNodes`] = $n;}if (`size $dagNodes`) {makeIdentity -a true -n 0 -pn true -t (!$preserveFlags[0]) -r (!$preserveFlags[1]) -s (!$preserveFlags[2])$dagNodes;}}
/*1.1.0:Observer*/global string $nkObservers[];proc string escapeStringParam(string $input) {string $escapedText;int $size = `size $input`;for ($i = 1; $i <= $size; $i++) {string $c = `substring $input $i $i`;switch ($c) {case "\\": $escapedText += "\\\\"; break;case "\"": $escapedText += "\\\""; break;case "\n": $escapedText += "\\n"; break;case "\r": $escapedText += "\\r"; break;case "\t": $escapedText += "\\t"; break;default: $escapedText += $c; break;}}return $escapedText;}proc string[] escapeStringParams(string $input[]) {string $escapedArray[];for ($s in $input) {$escapedArray[`size $escapedArray`] = escapeStringParam($s);}return $escapedArray;}proc string floatParamsToString(float $params[]) {string $param = "{";int $numParams = `size $params`;for ($i = 0; $i < $numParams; $i++) {string $floatString = (string) $params[$i];if (!`gmatch $floatString "*.*"`) $floatString += ".0";$param += $floatString + (($i < $numParams - 1) ? ", " : "");}$param += "}";return $param;}proc string intParamsToString(int $params[]) {string $param = "{}";if (`size $param`) {$param = "{" + intArrayToString($params, ", ") + "}";}return $param;}proc string stringParamsToString(string $params[]) {string $param = "{}";if (`size $params`) {$param = "{\"" + stringArrayToString(escapeStringParams($params), "\", \"") + "\"}";}return $param;}proc clearObservers() {global string $nkObservers[];clear $nkObservers;}proc int isValidObserverEvent(string $event) {return (isValidString($event, "^[^;]+$"));}proc int isValidObserverProc(string $proc) {return (isValidString($proc, "^[a-zA-Z\|:\._][a-zA-Z0-9\|:\._]*$"));}proc int isValidObserver(string $observer) {return (isValidString($observer, "^[^;]+;[a-zA-Z\|:\._][a-zA-Z0-9\|:\._]*$"));}proc string makeObserver(string $event, string $proc) {string $observer;if (isValidObserverEvent($event) && isValidObserverProc($proc)) {$observer = $event + ";" + $proc;}return $observer;}proc string extractObserverEvent(string $observer) {string $event;string $buffer[];if (`tokenize $observer ";" $buffer` == 2) {$event = $buffer[0];}return $event;}proc string extractObserverProc(string $observer) {string $proc;string $buffer[];if (`tokenize $observer ";" $buffer` == 2) {$proc = $buffer[1];}return $proc;}proc int findObserver(string $observer) {global string $nkObservers[];int $index = -1;for ($i = 0; $i < `size $nkObservers`; $i++) {if ($observer == $nkObservers[$i]) {$index = $i;break;}}return $index;}proc int existsObserver(string $observer) {return (findObserver($observer) >= 0);}proc string[] getObserverProcs(string $event) {global string $nkObservers[];string $procs[];if (!isValidObserverEvent($event)) return $procs;for ($observer in $nkObservers) {if (extractObserverEvent($observer) == $event) {$procs[`size $procs`] = extractObserverProc($observer);}}return $procs;}proc int subscribe(string $event, string $proc) {global string $nkObservers[];string $observer = makeObserver($event, $proc);if (!isValidObserver($observer)) return false;if (existsObserver($observer)) return false;$nkObservers[`size $nkObservers`] = $observer;return true;}proc int unsubscribe(string $event, string $proc) {global string $nkObservers[];string $observer = makeObserver($event, $proc);if (!isValidObserver($observer)) return false;int $index = findObserver($observer);if ($index < 0) return false;stringArrayRemoveAtIndex($index, $nkObservers);return true;}proc notify(string $event) {string $procs[] = getObserverProcs($event);for ($proc in $procs) {if (`exists $proc`) {eval $proc;}}}proc notifyFloat(string $event, float $param) {string $procs[] = getObserverProcs($event);for ($proc in $procs) {if (`exists $proc`) {eval $proc $param;}}}proc notifyInt(string $event, int $param) {string $procs[] = getObserverProcs($event);for ($proc in $procs) {if (`exists $proc`) {eval $proc $param;}}}proc notifyString(string $event, string $param) {string $procs[] = getObserverProcs($event);for ($proc in $procs) {if (`exists $proc`) {eval $proc ("\"" + $param + "\"");}}}proc notifyFloatArray(string $event, float $params[]) {string $param = floatParamsToString($params);string $procs[] = getObserverProcs($event);for ($proc in $procs) {if (`exists $proc`) {eval ($proc + "(" + $param + ")");}}}proc notifyIntArray(string $event, int $params[]) {string $param = intParamsToString($params);string $procs[] = getObserverProcs($event);for ($proc in $procs) {if (`exists $proc`) {eval ($proc + "(" + $param + ")");}}}proc notifyStringArray(string $event, string $params[]) {string $param = stringParamsToString($params);string $procs[] = getObserverProcs($event);for ($proc in $procs) {if (`exists $proc`) {eval ($proc + "(" + $param + ")");}}}
/*1.6.0:String*/proc string escapeStringForLiteral(string $input) {string $escapedText;int $size = `size $input`;for ($i = 1; $i <= $size; $i++) {string $c = `substring $input $i $i`;switch ($c) {case "\"": $escapedText += "\\\""; break;case "\\": $escapedText += "\\\\"; break;case "\n": $escapedText += "\\n"; break;case "\r": $escapedText += "\\r"; break;case "\t": $escapedText += "\\t"; break;default: $escapedText += $c; break;}}return $escapedText;}proc string booleanAsStringLiteral(int $value) {return (($value == 0) ? "false" : "true");}proc string floatAsStringLiteral(float $value) {string $literal = (string) $value;if (!`gmatch $literal "*e*"` && !`gmatch $literal "*.*"`) $literal += ".0";return $literal;}proc string intAsStringLiteral(int $value) {return ((string) $value);}proc string stringAsStringLiteral(string $value) {return ("\"" + escapeStringForLiteral($value) + "\"");}proc string booleanArrayAsStringLiteral(int $values[]) {string $stringValues[];for ($i = 0; $i < `size $values`; $i++) {$stringValues[$i] = booleanAsStringLiteral($values[$i]);}return ("{" + stringArrayToString($stringValues, ", ") + "}");}proc string floatArrayAsStringLiteral(float $values[]) {string $stringValues[];for ($i = 0; $i < `size $values`; $i++) {$stringValues[$i] = floatAsStringLiteral($values[$i]);}return ("{" + stringArrayToString($stringValues, ", ") + "}");}proc string intArrayAsStringLiteral(int $values[]) {return ("{" + intArrayToString($values, ", ") + "}");}proc string stringArrayAsStringLiteral(string $values[]) {string $stringValues[];for ($i = 0; $i < `size $values`; $i++) {$stringValues[$i] = stringAsStringLiteral($values[$i]);}return ("{" + stringArrayToString($stringValues, ", ") + "}");}proc string join(string $inputs[], string $separator, int $ignoreEmpty) {int $numInputs = `size $inputs`;if (!$numInputs || ($numInputs == 1 && !`size $inputs[0]`)) return "";if ($ignoreEmpty) {string $buffer[];for ($input in $inputs) {if (`size $input`) $buffer[`size $buffer`] = $input;}return stringArrayToString($buffer, $separator);}else {return stringArrayToString($inputs, $separator);}}proc string strip(string $input) {return `python(convertStringForPythonString($input) + ".strip()")`;}proc string regexSearchGroup(string $pattern, string $input, string $flags) {$flags = (`size $flags`) ? "(?" + $flags + ")" : "";python("import re");string $result = `python("(lambda m: m.group() if m else None)(re.search(" + convertStringForPythonString($flags + $pattern) + ", " + convertStringForPythonString($input) + "))")`;return $result;}proc int[] regexSearchSpan(string $pattern, string $input, string $flags) {$flags = (`size $flags`) ? "(?" + $flags + ")" : "";python("import re");int $result[] = `python("(lambda m: m.span() if m else None)(re.search(" + convertStringForPythonString($flags + $pattern) + ", " + convertStringForPythonString($input) + "))")`;return $result;}proc string[] regexMatchGroups(string $pattern, string $input, string $flags) {$flags = (`size $flags`) ? "(?" + $flags + ")" : "";python("import re");string $result[] = `python("tuple([m.group() for m in re.finditer(" + convertStringForPythonString($flags + $pattern) + ", " + convertStringForPythonString($input) + ")])")`;return $result;}proc string[] regexMatchSubGroups(string $pattern, string $input, string $flags) {$flags = (`size $flags`) ? "(?" + $flags + ")" : "";python("import re");string $result[] = `python("sum([m.groups() for m in re.finditer(" + convertStringForPythonString($flags + $pattern) + ", " + convertStringForPythonString($input) + ")], ())")`;return $result;}proc int[] regexMatchSpans(string $pattern, string $input, string $flags) {$flags = (`size $flags`) ? "(?" + $flags + ")" : "";python("import re");int $result[] = `python("sum([m.span() for m in re.finditer(" + convertStringForPythonString($flags + $pattern) + ", " + convertStringForPythonString($input) + ")], ())")`;return $result;}proc int regexIsMatch(string $pattern, string $input, string $flags) {return (`size (regexSearchGroup($pattern, $input, $flags))` > 0);}proc string[] regexSplit(string $pattern, string $input, string $flags) {$flags = (`size $flags`) ? "(?" + $flags + ")" : "";python("import re");string $result[] = `python("tuple(re.split(" + convertStringForPythonString($flags + $pattern) + ", " + convertStringForPythonString($input) + "))")`;return $result;}proc string regexReplace(string $pattern,string $replacement,string $input,string $flags) {$flags = (`size $flags`) ? "(?" + $flags + ")" : "";python("import re");string $result = `python("re.sub(" + convertStringForPythonString($flags + $pattern) + ", " + convertStringForPythonString($replacement) + ", " + convertStringForPythonString($input) + ")")`;return $result;}proc string getClipboardText() {python("from PySide2 import QtGui");return python("QtGui.QClipboard().text()");}proc setClipboardText(string $text) {python("from PySide2 import QtGui");python("QtGui.QClipboard().setText(" + convertStringForPythonString($text) + ")");}proc string dictSanitize(string $input) {string $pattern = "[=;]";if (regexIsMatch($pattern, $input, "")) {return regexReplace($pattern, "_", $input, "");}else {return $input;}}proc string[] dictSanitizeArray(string $input[]) {string $result[];for ($i = 0; $i < `size $input`; $i++) {$result[$i] = dictSanitize($input[$i]);}return $result;}proc string[] dictExtractItems(string $dict) {string $items[];string $buffer[] = regexSplit(";", $dict, "");for ($item in $buffer) {if (!`size $item`) continue;$items[`size $items`] = $item;}return $items;}proc int dictIsKeyEquals(string $item, string $key) {return (`size $key` && `gmatch $item ($key + "=*")`);}proc string dictExtractKey(string $item) {if (!`gmatch $item "?*=*"`) return "";return regexReplace("^([^=]+)=.*", "\\1", $item, "");}proc string dictExtractValue(string $item) {if (!`gmatch $item "?*=*"`) return "";return regexReplace("^[^=]+=", "", $item, "");}proc string dictGetValue(string $dict, string $key) {string $value;if (!`size $key`) return $value;string $items[] = dictExtractItems($dict);for ($item in $items) {if (dictIsKeyEquals($item, $key)) {$value = dictExtractValue($item);break;}}return $value;}proc string[] dictKeys(string $dict) {string $keys[];string $items[] = dictExtractItems($dict);for ($item in $items) {string $key = dictExtractKey($item);if (!`size $key`) continue;$keys[`size $keys`] = $key;}return $keys;}proc int dictContainsKey(string $dict, string $key) {if (!`size $key`) return false;string $keys[] = dictKeys($dict);return stringArrayContains($key, $keys);}proc string dictAddItem(string $dict, string $key, string $value) {if (!`size $key`) return $dict;string $newDict;int $isOverwrite;string $items[] = dictExtractItems($dict);for ($item in $items) {if (dictIsKeyEquals($item, $key)) {$isOverwrite = true;$newDict += $key + "=" + $value + ";";}else {$newDict += $item + ";";}}if (!$isOverwrite) {$newDict += $key + "=" + $value + ";";}return $newDict;}proc string dictAddBoolean(string $dict, string $key, int $value) {return dictAddItem($dict, dictSanitize($key), booleanAsStringLiteral($value));}proc string dictAddFloat(string $dict, string $key, float $value) {return dictAddItem($dict, dictSanitize($key), floatAsStringLiteral($value));}proc string dictAddInt(string $dict, string $key, int $value) {return dictAddItem($dict, dictSanitize($key), intAsStringLiteral($value));}proc string dictAddString(string $dict, string $key, string $value) {$value = dictSanitize($value);return dictAddItem($dict, dictSanitize($key), stringAsStringLiteral($value));}proc string dictAddBooleanArray(string $dict, string $key, int $value[]) {return dictAddItem($dict, dictSanitize($key), booleanArrayAsStringLiteral($value));}proc string dictAddFloatArray(string $dict, string $key, float $value[]) {return dictAddItem($dict, dictSanitize($key), floatArrayAsStringLiteral($value));}proc string dictAddIntArray(string $dict, string $key, int $value[]) {return dictAddItem($dict, dictSanitize($key), intArrayAsStringLiteral($value));}proc string dictAddStringArray(string $dict, string $key, string $value[]) {$value = dictSanitizeArray($value);return dictAddItem($dict, dictSanitize($key), stringArrayAsStringLiteral($value));}proc int dictGetBoolean(string $dict, string $key, int $default) {string $value = dictGetValue($dict, $key);if ($value == "true") {return true;}else if ($value == "false") {return false;}return $default;}proc float dictGetFloat(string $dict, string $key, float $default) {string $value = dictGetValue($dict, $key);if (`size $value`) return ((float) $value);return $default;}proc int dictGetInt(string $dict, string $key, int $default) {string $value = dictGetValue($dict, $key);if (`size $value`) return ((int) $value);return $default;}proc string dictGetString(string $dict, string $key, string $default) {string $value = dictGetValue($dict, $key);if (`size $value`) return `eval ("format -s " + $value + " \"^1s\";")`;return $default;}global int $dictBooleanArrayBuffer[];global float $dictFloatArrayBuffer[];global int $dictIntArrayBuffer[];global string $dictStringArrayBuffer[];proc int[] dictGetBooleanArray(string $dict, string $key, int $default[]) {global int $dictBooleanArrayBuffer[];clear $dictBooleanArrayBuffer;string $value = dictGetValue($dict, $key);if (`size $value`) {eval ("$dictBooleanArrayBuffer = " + $value + ";");return $dictBooleanArrayBuffer;}return $default;}proc float[] dictGetFloatArray(string $dict, string $key, float $default[]) {global float $dictFloatArrayBuffer[];clear $dictFloatArrayBuffer;string $value = dictGetValue($dict, $key);if (`size $value`) {eval ("$dictFloatArrayBuffer = " + $value + ";");return $dictFloatArrayBuffer;}return $default;}proc int[] dictGetIntArray(string $dict, string $key, int $default[]) {global int $dictIntArrayBuffer[];clear $dictIntArrayBuffer;string $value = dictGetValue($dict, $key);if (`size $value`) {eval ("$dictIntArrayBuffer = " + $value + ";");return $dictIntArrayBuffer;}return $default;}proc string[] dictGetStringArray(string $dict, string $key, string $default[]) {global string $dictStringArrayBuffer[];clear $dictStringArrayBuffer;string $value = dictGetValue($dict, $key);if (`size $value`) {eval ("$dictStringArrayBuffer = " + $value + ";");return $dictStringArrayBuffer;}return $default;}proc string dictRemove(string $dict, string $key) {if (!`size $key`) return $dict;string $newDict;string $items[] = dictExtractItems($dict);for ($item in $items) {string $itemKey = dictExtractKey($item);if ($itemKey == $key) continue;$newDict += $item + ";";}return $newDict;}
/*2.1.0:UIControl*/global string $nkUIControls[];proc appendUIControls(string $controls[]) {global string $nkUIControls[];for ($control in $controls) {$nkUIControls[`size $nkUIControls`] = $control;}}proc string getUIControl(string $root, string $end) {global string $nkUIControls[];string $path;for ($control in $nkUIControls) {string $buffer[];int $depth = `tokenize $control "|" $buffer`;string $first = ($depth > 0) ? $buffer[0] : "";string $last = ($depth > 0) ? $buffer[$depth - 1] : "";if ($first == $root && $last == $end) {$path = $control;break;}}return $path;}proc removeUIControls(string $root, string $end) {global string $nkUIControls[];string $paths[];for ($control in $nkUIControls) {string $buffer[];int $depth = `tokenize $control "|" $buffer`;string $first = ($depth > 0) ? $buffer[0] : "";string $last = ($depth > 0) ? $buffer[$depth - 1] : "";int $shouldRemove = (!`size $end`) ? $first == $root : $first == $root && $last == $end;if ($shouldRemove) $paths[`size $paths`] = $control;}if (`size $paths` > 0) {$nkUIControls = stringArrayRemove($paths, $nkUIControls);}}proc string uiControlTypeOf(string $control) {string $type = `objectTypeUI $control`;if ($type == "floatingWindow") $type = "window";return $type;}proc int qEnable(string $control) {string $type = uiControlTypeOf($control);if ($type == "window" || $type == "workspaceControl") return true;return `control -q -en $control`;}proc eEnable(int $bValue, string $control) {string $type = uiControlTypeOf($control);if ($type == "window" || $type == "workspaceControl") return;control -e -en $bValue $control;}proc int qExists(string $control) {return `control -q -ex $control`;}proc int qVisible(string $control) {return `control -q -vis $control`;}proc eVisible(int $bValue, string $control) {control -e -vis $bValue $control;}proc float qFloat(string $type, string $flag, string $control) {return `eval $type "-q" $flag $control`;}proc eFloat(string $type, string $flag, float $fValue, string $control) {eval $type "-e" $flag $fValue $control;}proc int qInt(string $type, string $flag, string $control) {return `eval $type "-q" $flag $control`;}proc eInt(string $type, string $flag, int $iValue, string $control) {eval $type "-e" $flag $iValue $control;}proc string qString(string $type, string $flag, string $control) {return `eval $type "-q" $flag $control`;}proc eString(string $type, string $flag, string $sValue, string $control) {eval $type "-e" $flag ("\"" + $sValue + "\"") $control;}proc float[] qFloatArray(string $type, string $flag, string $control) {return `eval $type "-q" $flag $control`;}proc int[] qIntArray(string $type, string $flag, string $control) {return `eval $type "-q" $flag $control`;}proc string[] qStringArray(string $type, string $flag, string $control) {return `eval $type "-q" $flag $control`;}proc eStringArray(string $type, string $flag, string $sValues[], string $control) {for ($sValue in $sValues) {eString($type, $flag, $sValue, $control);}}proc eOrderedFloat(string $type, string $flag, float $fValues[], string $control) {for ($i = 0; $i < `size $fValues`; $i++) {eFloat($type, ($flag + ($i + 1)), $fValues[$i], $control);}}proc eOrderedInt(string $type, string $flag, int $iValues[], string $control) {for ($i = 0; $i < `size $iValues`; $i++) {eInt($type, ($flag + ($i + 1)), $iValues[$i], $control);}}proc eOrderedString(string $type, string $flag, string $sValues[], string $control) {for ($i = 0; $i < `size $sValues`; $i++) {eString($type, ($flag + ($i + 1)), $sValues[$i], $control);}}proc int qIndex(string $type, string $flag, string $control) {return (qInt($type, $flag, $control) - 1);}proc eIndex(string $type, string $flag, int $index, string $control) {eInt($type, $flag, ($index + 1), $control);}proc int[] qIndexArray(string $type, string $flag, string $control) {int $indices[] = qIntArray($type, $flag, $control);for ($i = 0; $i < `size $indices`; $i++) $indices[$i] -= 1;return $indices;}proc eIndexArray(string $type, string $flag, int $indices[], string $control) {for ($i in $indices) {eInt($type, $flag, $i + 1, $control);}}proc int qFirstIndex(string $type, string $flag, string $control) {int $indices[] = qIndexArray($type, $flag, $control);return  ((`size $indices`) ? $indices[0] : -1);}proc string qFirstString(string $type, string $flag, string $control) {string $sValues[] = qStringArray($type, $flag, $control);return  ((`size $sValues`) ? $sValues[0] : "");}proc eIntString(string $type, string $flag, int $iValue, string $sValue, string $control) {eval $type "-e" $flag $iValue ("\"" + $sValue + "\"") $control;}proc eIndexString(string $type, string $flag, int $index, string $sValue, string $control) {eIntString($type, $flag, $index + 1, $sValue, $control);}proc eStringInt(string $type, string $flag, string $sValue, int $iValue, string $control) {eval $type "-e" $flag ("\"" + $sValue + "\"") $iValue $control;}proc executeUIControl(string $type, string $flag, string $control) {eval $type "-e" $flag $control;}proc string getParentableWindow(string $control) {if (uiControlTypeOf($control) == "workspaceControl" && !qInt("workspaceControl", "-fl", $control)) {return "MayaWindow";}else {return $control;}}proc windowClose(string $control) {if (qExists($control)) {string $type = uiControlTypeOf($control);switch ($type) {case "window": deleteUI $control; break;case "workspaceControl": executeUIControl("workspaceControl", "-cl", $control);break;default: break;}}}proc windowPrefRemove(string $type, string $control) {if (qExists($control)) windowClose($control);switch ($type) {case "window": if (qInt("windowPref", "-ex", $control)) {windowPref -r $control;}break;case "workspaceControl": if (qInt("workspaceControlState", "-ex", $control)) {workspaceControlState -r $control;}break;default: break;}}proc string buildWorkspaceControl(string $workspaceControlName,string $label,string $buildProcName,string $buildProcFilename) {string $control = $workspaceControlName;if (!qExists($workspaceControlName)) {string $uiScript = "if (!`exists " + $buildProcName + "`)" + " source \"" + $buildProcFilename + "\"; " + $buildProcName + "();";$control = `workspaceControl -dup false -fl true -l $label -rt false -ui $uiScript$workspaceControlName`;}return $control;}
// -----------------------------------------------------------------------------
/*1.0.0:DictAttribute*/proc int hasDictAttribute(string $n, string $attribute) {return existsAttribute($n, $attribute);}proc int lockDictAttribute(string $n, string $attribute, int $state) {if (!hasDictAttribute($n, $attribute)) return false;setAttributeLock($n, $attribute, $state);return true;}proc string addDictAttribute(string $n, string $attribute) {string $path;if (!`objExists $n`) return $path;if (!hasDictAttribute($n, $attribute)) {addAttr -dt "string" -ln $attribute $n;lockDictAttribute($n, $attribute, true);}if (hasDictAttribute($n, $attribute)) $path = $n + "." + $attribute;return $path;}proc string getDictValue(string $n, string $attribute) {return ((hasDictAttribute($n, $attribute)) ? getStringAttribute($n, $attribute, "") : "");}proc int setDictValue(string $n, string $attribute, string $value) {if (!hasDictAttribute($n, $attribute)) return false;lockDictAttribute($n, $attribute, false);setStringAttribute($n, $attribute, $value);lockDictAttribute($n, $attribute, true);return true;}proc int removeFromDict(string $n, string $attribute, string $key) {if (!hasDictAttribute($n, $attribute) || !`size $key`) return false;string $dict = getDictValue($n, $attribute);$dict = dictRemove($dict, $key);return setDictValue($n, $attribute, $dict);}proc int getBooleanFromDict(string $n, string $attribute, string $key, int $default) {return dictGetBoolean(getDictValue($n, $attribute), $key, $default);}proc float getFloatFromDict(string $n, string $attribute, string $key, float $default) {return dictGetFloat(getDictValue($n, $attribute), $key, $default);}proc int getIntFromDict(string $n, string $attribute, string $key, int $default) {return dictGetInt(getDictValue($n, $attribute), $key, $default);}proc string getStringFromDict(string $n, string $attribute, string $key, string $default) {return dictGetString(getDictValue($n, $attribute), $key, $default);}proc int setBooleanToDict(string $n, string $attribute, string $key, int $value) {if (!hasDictAttribute($n, $attribute) || !`size $key`) return false;string $dict = getDictValue($n, $attribute);$dict = dictAddBoolean($dict, $key, $value);return setDictValue($n, $attribute, $dict);}proc int setFloatToDict(string $n, string $attribute, string $key, float $value) {if (!hasDictAttribute($n, $attribute) || !`size $key`) return false;string $dict = getDictValue($n, $attribute);$dict = dictAddFloat($dict, $key, $value);return setDictValue($n, $attribute, $dict);}proc int setIntToDict(string $n, string $attribute, string $key, int $value) {if (!hasDictAttribute($n, $attribute) || !`size $key`) return false;string $dict = getDictValue($n, $attribute);$dict = dictAddInt($dict, $key, $value);return setDictValue($n, $attribute, $dict);}proc int setStringToDict(string $n, string $attribute, string $key, string $value) {if (!hasDictAttribute($n, $attribute) || !`size $key`) return false;string $dict = getDictValue($n, $attribute);$dict = dictAddString($dict, $key, $value);return setDictValue($n, $attribute, $dict);}
/*1.0.1:OpenMaya*/global int $nkOpenMayaIsInitialized;global string $nkOpenMayaNodeObservers[];global string $nkOpenMayaNodeCallbackIds[];global string $nkOpenMayaNodeAddedQueueNodes[];global int $nkOpenMayaNodeAddedJobId;global float $nkOpenMayaNodeAddedStartTime;global string $nkOpenMayaNodeRemovedQueueNodes[];global int $nkOpenMayaNodeRemovedJobId;global float $nkOpenMayaNodeRemovedStartTime;proc nkOpenMayaInitializeNodeAddedParameters() {global string $nkOpenMayaNodeAddedQueueNodes[];global int $nkOpenMayaNodeAddedJobId;global float $nkOpenMayaNodeAddedStartTime;clear $nkOpenMayaNodeAddedQueueNodes;$nkOpenMayaNodeAddedJobId = -1;$nkOpenMayaNodeAddedStartTime = -1.0;}proc nkOpenMayaInitializeNodeRemovedParameters() {global string $nkOpenMayaNodeRemovedQueueNodes[];global int $nkOpenMayaNodeRemovedJobId;global float $nkOpenMayaNodeRemovedStartTime;clear $nkOpenMayaNodeRemovedQueueNodes;$nkOpenMayaNodeRemovedJobId = -1;$nkOpenMayaNodeRemovedStartTime = -1.0;}proc nkOpenMayaInitializeParameters(int $force) {global int $nkOpenMayaIsInitialized;global string $nkOpenMayaNodeObservers[];global string $nkOpenMayaNodeCallbackIds[];if ($force || !$nkOpenMayaIsInitialized) {python("import maya.api.OpenMaya");python("import maya.mel");for ($event in {"Added", "Removed"}) {python("def nkOpenMayaNode" + $event + "(object, deferred):" + " maya.mel.eval(" + "'nkOpenMayaNode" + $event + "(\\\"'" + " + maya.api.OpenMaya.MFnDependencyNode(object).uniqueName()" + " + '\\\", ' + str(deferred) + ')'" + ")");}$nkOpenMayaIsInitialized = true;clear $nkOpenMayaNodeObservers;clear $nkOpenMayaNodeCallbackIds;nkOpenMayaInitializeNodeAddedParameters();nkOpenMayaInitializeNodeRemovedParameters();}}global proc nkOpenMayaNodeAddedDeferred() {global string $nkOpenMayaNodeAddedQueueNodes[];global int $nkOpenMayaNodeAddedJobId;global float $nkOpenMayaNodeAddedStartTime;if ($nkOpenMayaNodeAddedJobId < 0 || $nkOpenMayaNodeAddedStartTime < 0.0) {nkOpenMayaInitializeNodeAddedParameters();return;}float $elapsedTime = `timerX -st $nkOpenMayaNodeAddedStartTime`;if ($elapsedTime > 0.0) {evalDeferred ("scriptJob -f -k " + $nkOpenMayaNodeAddedJobId);notifyStringArray("nkOpenMayaNodeAdded", $nkOpenMayaNodeAddedQueueNodes);nkOpenMayaInitializeNodeAddedParameters();}}global proc nkOpenMayaNodeRemovedDeferred() {global string $nkOpenMayaNodeRemovedQueueNodes[];global int $nkOpenMayaNodeRemovedJobId;global float $nkOpenMayaNodeRemovedStartTime;if ($nkOpenMayaNodeRemovedJobId < 0 || $nkOpenMayaNodeRemovedStartTime < 0.0) {nkOpenMayaInitializeNodeRemovedParameters();return;}float $elapsedTime = `timerX -st $nkOpenMayaNodeRemovedStartTime`;if ($elapsedTime > 0.0) {evalDeferred ("scriptJob -f -k " + $nkOpenMayaNodeRemovedJobId);notifyStringArray("nkOpenMayaNodeRemoved", $nkOpenMayaNodeRemovedQueueNodes);nkOpenMayaInitializeNodeRemovedParameters();}}proc updateNodeAddedDeferred(string $node) {global string $nkOpenMayaNodeAddedQueueNodes[];global int $nkOpenMayaNodeAddedJobId;global float $nkOpenMayaNodeAddedStartTime;if (`size $node`) {$nkOpenMayaNodeAddedQueueNodes[`size $nkOpenMayaNodeAddedQueueNodes`] = $node;}$nkOpenMayaNodeAddedStartTime = `timerX`;if ($nkOpenMayaNodeAddedJobId < 0) {$nkOpenMayaNodeAddedJobId = `scriptJob -e "idle" "nkOpenMayaNodeAddedDeferred"`;}}proc updateNodeRemovedDeferred(string $node) {global string $nkOpenMayaNodeRemovedQueueNodes[];global int $nkOpenMayaNodeRemovedJobId;global float $nkOpenMayaNodeRemovedStartTime;if (`size $node`) {$nkOpenMayaNodeRemovedQueueNodes[`size $nkOpenMayaNodeRemovedQueueNodes`] = $node;}$nkOpenMayaNodeRemovedStartTime = `timerX`;if ($nkOpenMayaNodeRemovedJobId < 0) {$nkOpenMayaNodeRemovedJobId = `scriptJob -e "idle" "nkOpenMayaNodeRemovedDeferred"`;}}global proc nkOpenMayaNodeAdded(string $node, int $deferred) {if ($deferred) {updateNodeAddedDeferred($node);}else {notifyStringArray("nkOpenMayaNodeAdded", {$node});}}global proc nkOpenMayaNodeRemoved(string $node, int $deferred) {if ($deferred) {updateNodeRemovedDeferred($node);}else {notifyStringArray("nkOpenMayaNodeRemoved", {$node});}}proc clearNodeObservers() {global string $nkOpenMayaNodeObservers[];global string $nkOpenMayaNodeCallbackIds[];if (`size $nkOpenMayaNodeCallbackIds`) {for ($callbackId in $nkOpenMayaNodeCallbackIds) {python("maya.api.OpenMaya.MMessage.removeCallback(" + $callbackId + ")");}}clear $nkOpenMayaNodeObservers;clear $nkOpenMayaNodeCallbackIds;}proc int isValidNodeObserverType(string $type) {return (isValidString($type, "^[a-zA-Z][a-zA-Z0-9]*$"));}proc int isValidNodeObserver(string $nodeObserver) {return (isValidString($nodeObserver, "^[^;]+;[a-zA-Z\|:\._][a-zA-Z0-9\|:\._]*;[a-zA-Z][a-zA-Z0-9]*$"));}proc string makeNodeObserver(string $event, string $proc, string $type) {string $nodeObserver;if (isValidObserverEvent($event) && isValidObserverProc($proc) && isValidNodeObserverType($type)) {$nodeObserver = $event + ";" + $proc + ";" + $type;}return $nodeObserver;}proc string extractNodeObserverEvent(string $nodeObserver) {string $event;string $buffer[];if (`tokenize $nodeObserver ";" $buffer` == 3) {$event = $buffer[0];}return $event;}proc string extractNodeObserverProc(string $nodeObserver) {string $proc;string $buffer[];if (`tokenize $nodeObserver ";" $buffer` == 3) {$proc = $buffer[1];}return $proc;}proc string extractNodeObserverType(string $nodeObserver) {string $type;string $buffer[];if (`tokenize $nodeObserver ";" $buffer` == 3) {$type = $buffer[2];}return $type;}proc int findNodeObserver(string $nodeObserver) {global string $nkOpenMayaNodeObservers[];int $index = -1;for ($i = 0; $i < `size $nkOpenMayaNodeObservers`; $i++) {if ($nodeObserver == $nkOpenMayaNodeObservers[$i]) {$index = $i;break;}}return $index;}proc int existsNodeObserver(string $nodeObserver) {return (findNodeObserver($nodeObserver) >= 0);}proc int subscribeNode(string $event, string $proc, string $types[], int $deferred) {global string $nkOpenMayaNodeObservers[];global string $nkOpenMayaNodeCallbackIds[];if ( !($event == "Added" || $event == "Removed") || !`size $proc` || !`size $types`) return false;int $shouldSubscribe = false;for ($type in $types) {string $nodeObserver = makeNodeObserver($event, $proc, $type);if (!isValidNodeObserver($nodeObserver)) continue;if (existsNodeObserver($nodeObserver)) continue;string $callbackId = `python("str(" + "maya.api.OpenMaya.MDGMessage.addNode" + $event + "Callback(" + "nkOpenMayaNode" + $event + ", '" + $type + "', " + $deferred + ")" + ")")`;$nkOpenMayaNodeObservers[`size $nkOpenMayaNodeObservers`] = $nodeObserver;$nkOpenMayaNodeCallbackIds[`size $nkOpenMayaNodeCallbackIds`] = $callbackId;if (!$shouldSubscribe) $shouldSubscribe = true;}if ($shouldSubscribe) {subscribe("nkOpenMayaNode" + $event, $proc);}return true;}proc int unsubscribeNode(string $event, string $proc, string $types[]) {global string $nkOpenMayaNodeObservers[];global string $nkOpenMayaNodeCallbackIds[];if ( !($event == "Added" || $event == "Removed") || !`size $proc` || !`size $types`) return false;int $shouldUnsubscribe = false;for ($type in $types) {string $nodeObserver = makeNodeObserver($event, $proc, $type);if (!isValidNodeObserver($nodeObserver)) continue;int $index = findNodeObserver($nodeObserver);if ($index < 0) continue;string $callbackId = $nkOpenMayaNodeCallbackIds[$index];python("maya.api.OpenMaya.MMessage.removeCallback(int(" + $callbackId + "))");stringArrayRemoveAtIndex($index, $nkOpenMayaNodeObservers);stringArrayRemoveAtIndex($index, $nkOpenMayaNodeCallbackIds);if (!$shouldUnsubscribe) $shouldUnsubscribe = true;}if ($shouldUnsubscribe) {unsubscribe("nkOpenMayaNode" + $event, $proc);}return true;}nkOpenMayaInitializeParameters(false);

// /////////////////////////////////////////////////////////////////////////////
// ドメイン
// /////////////////////////////////////////////////////////////////////////////
/*-
@var <string> BDNアトリビュートの既定値。
*/
global string $nkBdnEditorDefaultBdnAttribute = "name=\"\";enable=true;resetTime=0.0;fps=30.0;offsetMatrixWeight=1.0;damping=0.1;elasticity=30.0;elasticForceFunction=0;stiffness=0.0;mass=1.0;gravityX=0.0;gravityY=-980.0;gravityZ=0.0;gravityMultiply=0.0;additionalForceScale=1.0;enableTurbulence=false;turbulenceSeed=0;turbulenceStrength=10.0;turbulenceVectorChangeScale=0.05;turbulenceVectorChangeMax=0.1;enableAngleLimit=false;angleLimit=60.0;radius=0.0;iterations=5;enableGroundCol=false;groundHeight=0.0;meshColCutoff=10.0;";

/*-
@var <string> カプセルコライダーアトリビュートの既定値。
*/
global string $nkBdnEditorDefaultCapsuleColliderAttribute = "name=\"\";colliderType=\"capsule\";colliderRadiusA=0.5;colliderRadiusB=0.5;colliderLength=2.0;colliderOffset=0.0;colliderPivot=0;";

/*-
@var <string> 無限平面コライダーアトリビュートの既定値。
*/
global string $nkBdnEditorDefaultInfinitePlaneColliderAttribute = "name=\"\";colliderType=\"infinitePlane\";colliderWidth=1.0;colliderHeight=1.0;";

/*-
@var <string> 球コライダーアトリビュートの既定値。
*/
global string $nkBdnEditorDefaultSphereColliderAttribute = "name=\"\";colliderType=\"sphere\";colliderRadius=0.5;";

/*-
@var <string> BDNアトリビュートのキャッシュ。
*/
global string $nkBdnEditorBdnAttributeCache;

/*-
@var <string> カプセルコライダーアトリビュートのキャッシュ。
*/
global string $nkBdnEditorCapsuleColliderAttributeCache;

/*-
@var <string> 無限平面コライダーアトリビュートのキャッシュ。
*/
global string $nkBdnEditorInfinitePlaneColliderAttributeCache;

/*-
@var <string> 球コライダーアトリビュートのキャッシュ。
*/
global string $nkBdnEditorSphereColliderAttributeCache;

// -----------------------------------------------------------------------------
// プラグイン
// -----------------------------------------------------------------------------
/*-
@returns <boolean>
*/
proc int isBdnPluginLoaded() {
  // print("isBdnPluginLoaded\n"); // debug
  return (`pluginInfo -q -l "boneDynamicsNode"`);
}

/*-
@returns <boolean> 成功した場合は`true`、失敗した場合は`false`。
*/
proc int loadBdnPlugin() {
  // print("loadBdnPlugin\n"); // debug
  if (isBdnPluginLoaded()) return true;

  if (catchQuiet(`loadPlugin "boneDynamicsNode"`)) return false;
  print("// nkBdnEditor: boneDynamicsNode loaded\n");
  return isBdnPluginLoaded();
}

/*-
@returns <boolean> 成功した場合は`true`、失敗した場合は`false`。
*/
proc int unloadBdnPlugin() {
  // print("unloadBdnPlugin\n"); // debug
  if (!isBdnPluginLoaded()) return false;

  string $bdnNodes[] = `ls -typ "boneDynamicsNode"`;
  if (!`size $bdnNodes`) {
    if (catchQuiet(`unloadPlugin -f "boneDynamicsNode"`)) {
      warning -n "nkBdnEditor: Plugin unload failed";
    }
    print("// nkBdnEditor: boneDynamicsNode unloaded\n");
  }
  else {
    warning -n "nkBdnEditor: Plugin unload failed: boneDynamicsNode exists in the scene.";
  }
  return !isBdnPluginLoaded();
}

/*-
@returns <string>
*/
proc string getBdnPluginVersion() {
  // print("getBdnPluginVersion\n"); // debug
  string $bdnVersion;
  if (catchQuiet($bdnVersion = `pluginInfo -q -v "boneDynamicsNode"`)) {
    $bdnVersion = "";
  }
  return $bdnVersion;
}

// -----------------------------------------------------------------------------
// ノード
// -----------------------------------------------------------------------------
/*-
@returns <string>
*/
proc string getTimeNode() {
  string $timeNodes[] = gatherNodes({"time"}, true, false, "");
  return ((`size $timeNodes`) ? $timeNodes[0] : "");
}

// -----------------------------------------------------------------------------
// アトリビュート
// -----------------------------------------------------------------------------
/*-
translateとrotateのロックを解除する。
@param $node <string>
@param $tFlag <boolean> 位置アトリビュートを処理に含めるかどうか。
@param $rFlag <boolean> 回転アトリビュートを処理に含めるかどうか。
@param $sFlag <boolean> スケールアトリビュートを処理に含めるかどうか。
@returns <boolean> translateとrotateのロックが全て解除されているかどうか。
@remarks リファレンスの場合は解除しない。
*/
proc int unlockTransformAttributes(string $node, int $tFlag, int $rFlag, int $sFlag) {
  // print("unlockTransformAttributes\n"); // debug
  // print("  node :" + $node + "\n"); // debug
  // print("  tFlag:" + $tFlag + "\n"); // debug
  // print("  rFlag:" + $rFlag + "\n"); // debug
  // print("  sFlag:" + $sFlag + "\n"); // debug
  if (!`objExists $node`) return false;

  if (!isNodeReferenced($node)) {
    string $attributes[];
    if ($tFlag) {
      $attributes[`size $attributes`] = "tx";
      $attributes[`size $attributes`] = "ty";
      $attributes[`size $attributes`] = "tz";
    }
    if ($rFlag) {
      $attributes[`size $attributes`] = "rx";
      $attributes[`size $attributes`] = "ry";
      $attributes[`size $attributes`] = "rz";
    }
    if ($sFlag) {
      $attributes[`size $attributes`] = "sx";
      $attributes[`size $attributes`] = "sy";
      $attributes[`size $attributes`] = "sz";
    }
    batchSetAttributeLock({$node}, $attributes, false);
  }

  int $isUnlocked = true;
  if ($tFlag) {
    $isUnlocked = !isAttributeLocked($node, "tx")
        && !isAttributeLocked($node, "ty")
        && !isAttributeLocked($node, "tz");
  }
  if ($isUnlocked && $rFlag) {
    $isUnlocked = !isAttributeLocked($node, "rx")
        && !isAttributeLocked($node, "ry")
        && !isAttributeLocked($node, "rz");
  }
  if ($isUnlocked && $sFlag) {
    $isUnlocked = !isAttributeLocked($node, "sx")
        && !isAttributeLocked($node, "sy")
        && !isAttributeLocked($node, "sz");
  }
  return $isUnlocked;
}

// -----------------------------------------------------------------------------
// BDNノード
// -----------------------------------------------------------------------------
/*-
@param $n <string>
@param $groupType <string>
| 値         | 種類                 |
| ---------- | -------------------- |
| `bdn`      | BDNグループ          |
| `dynamics` | ダイナミクスグループ |
| `target`   | ターゲットグループ   |
| `collider` | コライダーグループ   |
@returns <string>
*/
proc string initGroupNode(string $n, string $groupType) {
  if (`objExists $n`) {
    if (!hasDictAttribute($n, "bdnData")) {
      addDictAttribute($n, "bdnData");
    }
    setStringToDict($n, "bdnData", "type", "group");
    setStringToDict($n, "bdnData", "groupType", $groupType);
  }
  return $n;
}

/*-
@param $n <string>
@param $spaceType <string>
| 値         | 種類         |
| ---------- | ------------ |
| `dynamics` | ダイナミクス |
| `target`   | ターゲット   |
| `collider` | コライダー   |
@returns <string>
*/
proc string initSpaceNode(string $n, string $spaceType) {
  if (`objExists $n`) {
    if (!hasDictAttribute($n, "bdnData")) {
      addDictAttribute($n, "bdnData");
    }
    setStringToDict($n, "bdnData", "type", "space");
    setStringToDict($n, "bdnData", "spaceType", $spaceType);
  }
  return $n;
}

/*-
@param $n <string>
@param $sourceName <string>
@returns <string>
*/
proc string initAltNode(string $n, string $sourceName) {
  if (`objExists $n`) {
    if (!hasDictAttribute($n, "bdnData")) {
      addDictAttribute($n, "bdnData");
    }
    setStringToDict($n, "bdnData", "type", "alt");
    setStringToDict($n, "bdnData", "sourceName", $sourceName);
    setStringToDict($n, "bdnData", "bdnVersion", getBdnPluginVersion());
  }
  return $n;
}

/*-
@param $n <string>
@param $jointKind <string>
| 値         | 種類           |
| ---------- | -------------- |
| `dynamics` | ダイナミクス用 |
| `target`   | 目標姿勢用     |
@param $jointType <string>
| 値       | 種類 |
| -------- | ---- |
| `normal` | 通常 |
| `branch` | 分岐 |
| `end`    | 終端 |
`
@returns <string>
*/
proc string initJointNode(string $n, string $jointKind, string $jointType) {
  if (`objExists $n`) {
    if (!hasDictAttribute($n, "bdnData")) {
      addDictAttribute($n, "bdnData");
    }
    setStringToDict($n, "bdnData", "type", "joint");
    setStringToDict($n, "bdnData", "jointKind", $jointKind);
    setStringToDict($n, "bdnData", "jointType", $jointType);
  }
  return $n;
}

/*-
@param $n <string>
@returns <string>
*/
proc string initRadiusNode(string $n) {
  if (`objExists $n`) {
    if (!hasDictAttribute($n, "bdnData")) {
      addDictAttribute($n, "bdnData");
    }
    setStringToDict($n, "bdnData", "type", "radius");
  }
  return $n;
}

/*-
@param $n <string>
@param $colliderType <string>
| 値              | 種類     |
| --------------- | -------- |
| `capsule`       | カプセル |
| `infinitePlane` | 無限平面 |
| `sphere`        | 球       |
@returns <string>
*/
proc string initColliderNode(string $n, string $colliderType) {
  if (`objExists $n`) {
    if (!hasDictAttribute($n, "bdnData")) {
      addDictAttribute($n, "bdnData");
    }
    setStringToDict($n, "bdnData", "type", "collider");
    setStringToDict($n, "bdnData", "colliderType", $colliderType);
  }
  return $n;
}

/*-
@param $n <string>
@returns <string>
*/
proc string initColliderComponentNode(string $n) {
  if (`objExists $n`) {
    if (!hasDictAttribute($n, "bdnData")) {
      addDictAttribute($n, "bdnData");
    }
    setStringToDict($n, "bdnData", "type", "colliderComponent");
  }
  return $n;
}

/*-
@param $n <string>
@returns <string>
*/
proc string initForceNode(string $n) {
  if (`objExists $n`) {
    if (!hasDictAttribute($n, "bdnData")) {
      addDictAttribute($n, "bdnData");
    }
    setStringToDict($n, "bdnData", "type", "force");
  }
  return $n;
}

/*-
@param $n <string>
@returns <string>
*/
proc string getBdnType(string $n) {
  return getStringFromDict($n, "bdnData", "type", "");
}

/*-
@param $n <string>
@param $type <string>
@returns <boolean>
*/
proc int isBdnType(string $n, string $type) {
  return (getBdnType($n) == $type);
}

/*-
@param $n <string>
@returns <string>
*/
proc string getGroupType(string $n) {
  return getStringFromDict($n, "bdnData", "groupType", "");
}

/*-
@param $n <string>
@param $type <string>
@returns <boolean>
*/
proc int isGroupType(string $n, string $type) {
  return (getGroupType($n) == $type);
}

/*-
@param $n <string>
@returns <string>
*/
proc string getSpaceType(string $n) {
  return getStringFromDict($n, "bdnData", "spaceType", "");
}

/*-
@param $n <string>
@param $type <string>
@returns <boolean>
*/
proc int isSpaceType(string $n, string $type) {
  return (getSpaceType($n) == $type);
}

/*-
@param $n <string>
@returns <string>
*/
proc string getJointKind(string $n) {
  return getStringFromDict($n, "bdnData", "jointKind", "");
}

/*-
@param $n <string>
@param $kind <string>
@returns <boolean>
*/
proc int isJointKind(string $n, string $kind) {
  return (getJointKind($n) == $kind);
}

/*-
@param $n <string>
@returns <string>
*/
proc string getJointType(string $n) {
  return getStringFromDict($n, "bdnData", "jointType", "");
}

/*-
@param $n <string>
@param $type <string>
@returns <boolean>
*/
proc int isJointType(string $n, string $type) {
  return (getJointType($n) == $type);
}

/*-
@param $n <string>
@returns <string>
*/
proc string getColliderType(string $n) {
  return getStringFromDict($n, "bdnData", "colliderType", "");
}

/*-
@param $n <string>
@param $type <string>
@returns <boolean>
*/
proc int isColliderType(string $n, string $type) {
  return (getColliderType($n) == $type);
}

/*-
シーン内の全てのBDNグループノードを取得する。
@returns <string[]>
*/
proc string[] getBdnGroupNodes() {
  // print("getBdnGroupNodes\n"); // debug
  string $bdnGroupNodes[];
  string $transformNodes[] = gatherNodes({"transform"}, true, false, "::BDN_GRP*");
  if (!`size $transformNodes`) return $bdnGroupNodes;

  for ($transformNode in $transformNodes) {
    if (!isGroupType($transformNode, "bdn")) continue;

    $bdnGroupNodes[`size $bdnGroupNodes`] = $transformNode;
  }
  $bdnGroupNodes = stringArrayRemoveDuplicates($bdnGroupNodes);
  return $bdnGroupNodes;
}

/*-
シーン内にあるBDNグループノードの内、最初に見つかった編集可能なBDNグループノードを取得する。
@returns <string>
*/
proc string getEditableBdnGroupNode() {
  // print("getEditableBdnGroupNode\n"); // debug
  string $editableBdnGroupNode;
  string $bdnGroupNodes[] = getBdnGroupNodes();
  for ($bdnGroupNode in $bdnGroupNodes) {
    if (isNodeReferenced($bdnGroupNode)) continue;

    $editableBdnGroupNode = $bdnGroupNode;
    break;
  }
  return $editableBdnGroupNode;
}

/*-
シーン内の全てのコライダーグループノードを取得する。
@returns <string[]>
*/
proc string[] getColliderGroupNodes() {
  // print("getColliderGroupNodes\n"); // debug
  string $colliderGroupNodes[];
  string $bdnGroupNodes[] = getBdnGroupNodes();
  if (!`size $bdnGroupNodes`) return $colliderGroupNodes;

  for ($bdnGroupNode in $bdnGroupNodes) {
    if (!isGroupType($bdnGroupNode, "bdn")) continue;

    string $childNodes[] = collectChildNodes($bdnGroupNode);
    for ($childNode in $childNodes) {
      if (!isGroupType($childNode, "collider")) continue;

      $colliderGroupNodes[`size $colliderGroupNodes`] = $childNode;
    }
  }
  return $colliderGroupNodes;
}

/*-
シーン内にあるコライダーグループノードの内、最初に見つかった編集可能なコライダーグループノードを取得する。
@returns <string>
*/
proc string getEditableColliderGroupNode() {
  // print("getEditableColliderGroupNode\n"); // debug
  string $editableColliderGroupNode;
  string $colliderGroupNodes[] = getColliderGroupNodes();
  for ($colliderGroupNode in $colliderGroupNodes) {
    if (isNodeReferenced($colliderGroupNode)) continue;

    $editableColliderGroupNode = $colliderGroupNode;
    break;
  }
  return $editableColliderGroupNode;
}

/*-
シーン内の全ての編集可能なBDNグループノードを統合する。
@returns <>
*/
proc mergeEditableBdnGroupNodes() {
  // print("mergeEditableBdnGroupNodes\n"); // debug
  string $bdnGroupNodes[] = getBdnGroupNodes();
  // print("  bdnGroupNodes:{\n    " + stringArrayToString($bdnGroupNodes, ",\n    ") + "\n  }\n"); // debug

  string $destBdnGroupNode;
  string $destBdnGroupShortName;
  string $editableBdnGroupNodes[];
  for ($bdnGroupNode in $bdnGroupNodes) {
    if (isNodeReferenced($bdnGroupNode)) continue;

    if (!`size $destBdnGroupNode`) {
      $destBdnGroupNode = $bdnGroupNode;
      $destBdnGroupShortName = toShortName($destBdnGroupNode);
    }
    else {
      $editableBdnGroupNodes[`size $editableBdnGroupNodes`] = $bdnGroupNode;
    }
  }
  // print("  destBdnGroupNode     :" + $destBdnGroupNode + "\n"); // debug
  // print("  destBdnGroupShortName:" + $destBdnGroupShortName + "\n"); // debug
  if (!isGroupType($destBdnGroupNode, "bdn")) return;

  for ($bdnGroupNode in $editableBdnGroupNodes) {
    string $sourceBdnGroupShortName = toShortName($bdnGroupNode);
    // print("  sourceBdnGroupShortName:" + $sourceBdnGroupShortName + "\n"); // debug

    string $sourceDynamicsGroupNode = getSecondLevelNode($sourceBdnGroupShortName, "Dynamics_GRP", false, true);
    // print("  sourceDynamicsGroupNode:" + $sourceDynamicsGroupNode + "\n"); // debug
    if (isGroupType($sourceDynamicsGroupNode, "dynamics")) {
      string $destDynamicsGroupNode = getSecondLevelNode($destBdnGroupShortName, "Dynamics_GRP", true, true);
      if (!isGroupType($destDynamicsGroupNode, "dynamics")) {
        initGroupNode($destDynamicsGroupNode, "dynamics");
      }
      setParentNode(
        collectChildNodes($sourceDynamicsGroupNode),
        $destDynamicsGroupNode
      );
    }

    string $sourceTargetGroupNode = getSecondLevelNode($sourceBdnGroupShortName, "Target_GRP", false, true);
    // print("  sourceTargetGroupNode:" + $sourceTargetGroupNode + "\n"); // debug
    if (isGroupType($sourceTargetGroupNode, "target")) {
      string $destTargetGroupNode = getSecondLevelNode($destBdnGroupShortName, "Target_GRP", true, true);
      if (!isGroupType($destTargetGroupNode, "target")) {
        initGroupNode($destTargetGroupNode, "target");
      }
      setParentNode(
        collectChildNodes($sourceTargetGroupNode),
        $destTargetGroupNode
      );
    }

    string $sourceColliderGroupNode = getSecondLevelNode($sourceBdnGroupShortName, "Collider_GRP", false, true);
    // print("  sourceColliderGroupNode:" + $sourceColliderGroupNode + "\n"); // debug
    if (isGroupType($sourceColliderGroupNode, "collider")) {
      string $destColliderGroupNode = getSecondLevelNode($destBdnGroupShortName, "Collider_GRP", true, true);
      if (!isGroupType($destColliderGroupNode, "collider")) {
        initGroupNode($destColliderGroupNode, "collider");
      }
      setParentNode(
        collectChildNodes($sourceColliderGroupNode),
        $destColliderGroupNode
      );
    }

    delete $bdnGroupNode;
  }

  if (
    isGroupType($destBdnGroupNode, "bdn")
        && toShortName($destBdnGroupNode) != "BDN_GRP"
  ) {
    setNodeName($destBdnGroupNode, "BDN_GRP", true);
  }
}

/*-
@param $selectedOnly <boolean>
@returns <string[]>
*/
proc string[] gatherBdnNodes(int $selectedOnly) {
  string $bdnNodes[];
  if (!isBdnPluginLoaded()) return $bdnNodes;

  $bdnNodes = gatherNodes({"boneDynamicsNode"}, true, $selectedOnly, "");
  string $unknownNodes[] = gatherNodes({"unknown"}, true, $selectedOnly, "");
  for ($unknownNode in $unknownNodes) {
    if (isBdnType($unknownNode, "alt")) {
      $bdnNodes[`size $bdnNodes`] = $unknownNode;
    }
  }
  return $bdnNodes;
}

/*-
@param $selectedOnly <boolean>
@returns <string[]>
*/
proc string[] gatherColliderNodes(int $selectedOnly) {
  string $colliderNodes[];
  if ($selectedOnly) {
    string $transformNodes[] = gatherNodes({"transform"}, true, $selectedOnly, "");
    for ($node in $transformNodes) {
      string $bdnType = getBdnType($node);
      if ($bdnType == "collider") {
        $colliderNodes[`size $colliderNodes`] = $node;
      }
      else if ($bdnType == "colliderComponent") {
        string $parentNode = getParentNode($node);
        if (isBdnType($parentNode, "collider")) {
          $colliderNodes[`size $colliderNodes`] = $parentNode;
        }
      }
      else if ($bdnType == "space" && isSpaceType($node, "collider")) {
        string $childNodes[] = collectChildNodes($node);
        for ($childNode in $childNodes) {
          if (isBdnType($childNode, "collider")) {
            $colliderNodes[`size $colliderNodes`] = $childNode;
          }
        }
      }
    }
  }
  else {
    string $colliderGroupNodes[] = getColliderGroupNodes();
    for ($colliderGroupNode in $colliderGroupNodes) {
      if (!isGroupType($colliderGroupNode, "collider")) continue;

      string $spcNodes[] = collectChildNodes($colliderGroupNode);
      for ($spcNode in $spcNodes) {
        if (!isSpaceType($spcNode, "collider")) continue;

        string $childNodes[] = collectChildNodes($spcNode);
        for ($childNode in $childNodes) {
          if (!isBdnType($childNode, "collider")) continue;

          $colliderNodes[`size $colliderNodes`] = $childNode;
        }
      }
    }
  }
  $colliderNodes = stringArrayRemoveDuplicates($colliderNodes);
  return $colliderNodes;
}

/*-
@param $selectedOnly <boolean>
@returns <string[]>
*/
proc string[] gatherMeshNodes(int $selectedOnly) {
  string $meshNodes[];
  string $nodes[] = gatherNodes({"transform", "mesh"}, true, $selectedOnly, "");
  for ($node in $nodes) {
    if (isMeshNode($node)) {
      $meshNodes[`size $meshNodes`] = $node;
    }
    else if (isTransformNode($node) && hasMeshNode($node)) {
      $meshNodes = stringArrayCatenate($meshNodes, getShapeNodes($node, "mesh"));
    }
  }
  $meshNodes = stringArrayRemoveDuplicates($meshNodes);
  return $meshNodes;
}

// -----------------------------------------------------------------------------
// BDNアトリビュート
// -----------------------------------------------------------------------------
/*-
@param $bdnNode <string>
@returns <string>
*/
proc string bdnAttributesToDict(string $bdnNode) {
  // print("bdnAttributesToDict\n"); // debug
  // print("  bdnNode:" + $bdnNode + "\n"); // debug
  string $dict;
  if (!isBdnPluginLoaded()) return $dict;
  if (!isType($bdnNode, {"boneDynamicsNode"}, true)) return $dict;

  $dict = dictAddString($dict, "name", toShortName($bdnNode));
  $dict = dictAddBoolean($dict, "enable", getIntAttribute($bdnNode, "enable", true));
  $dict = dictAddFloat($dict, "resetTime", getFloatAttribute($bdnNode, "resetTime", 0.0));
  $dict = dictAddFloat($dict, "fps", getFloatAttribute($bdnNode, "fps", 30.0));
  $dict = dictAddFloat($dict, "offsetMatrixWeight", getFloatAttribute($bdnNode, "offsetMatrixWeight", 1.0));
  $dict = dictAddFloat($dict, "damping", getFloatAttribute($bdnNode, "damping", 0.1));
  $dict = dictAddFloat($dict, "elasticity", getFloatAttribute($bdnNode, "elasticity", 30.0));
  $dict = dictAddInt($dict, "elasticForceFunction", getIntAttribute($bdnNode, "elasticForceFunction", 0));
  $dict = dictAddFloat($dict, "stiffness", getFloatAttribute($bdnNode, "stiffness", 0.0));
  $dict = dictAddFloat($dict, "mass", getFloatAttribute($bdnNode, "mass", 1.0));
  $dict = dictAddFloat($dict, "gravityX", getFloatAttribute($bdnNode, "gravityX", 0.0));
  $dict = dictAddFloat($dict, "gravityY", getFloatAttribute($bdnNode, "gravityY", -980.0));
  $dict = dictAddFloat($dict, "gravityZ", getFloatAttribute($bdnNode, "gravityZ", 0.0));
  $dict = dictAddFloat($dict, "gravityMultiply", getFloatAttribute($bdnNode, "gravityMultiply", 0.0));
  $dict = dictAddFloat($dict, "additionalForceScale", getFloatAttribute($bdnNode, "additionalForceScale", 1.0));
  $dict = dictAddBoolean($dict, "enableTurbulence", getIntAttribute($bdnNode, "enableTurbulence", false));
  $dict = dictAddInt($dict, "turbulenceSeed", getIntAttribute($bdnNode, "turbulenceSeed", 0));
  $dict = dictAddFloat($dict, "turbulenceStrength", getFloatAttribute($bdnNode, "turbulenceStrength", 10.0));
  $dict = dictAddFloat($dict, "turbulenceVectorChangeScale", getFloatAttribute($bdnNode, "turbulenceVectorChangeScale", 0.05));
  $dict = dictAddFloat($dict, "turbulenceVectorChangeMax", getFloatAttribute($bdnNode, "turbulenceVectorChangeMax", 0.1));
  $dict = dictAddBoolean($dict, "enableAngleLimit", getIntAttribute($bdnNode, "enableAngleLimit", false));
  $dict = dictAddFloat($dict, "angleLimit", getFloatAttribute($bdnNode, "angleLimit", 60.0));
  $dict = dictAddFloat($dict, "radius", getFloatAttribute($bdnNode, "radius", 0.0));
  $dict = dictAddInt($dict, "iterations", getIntAttribute($bdnNode, "iterations", 5));
  $dict = dictAddBoolean($dict, "enableGroundCol", getIntAttribute($bdnNode, "enableGroundCol", false));
  $dict = dictAddFloat($dict, "groundHeight", getFloatAttribute($bdnNode, "groundHeight", 0.0));
  $dict = dictAddFloat($dict, "meshColCutoff", getFloatAttribute($bdnNode, "meshColCutoff", 10.0));
  return $dict;
}

/*-
@param $dict <string>
@param $bdnNodes <string[]>
@returns <>
*/
proc applyDictToBdnAttributes(string $dict, string $bdnNodes[]) {
  // print("applyDictToBdnAttributes\n"); // debug
  // print("  dict    :" + $dict + "\n"); // debug
  // print("  bdnNodes:{\n    " + stringArrayToString($bdnNodes, ",\n    ") + "\n  }\n"); // debug
  if (!isBdnPluginLoaded() || !`size $dict` || !`size $bdnNodes`) return;

  int $enable = dictGetBoolean($dict, "enable", true);
  float $resetTime = dictGetFloat($dict, "resetTime", 0.0);
  float $fps = dictGetFloat($dict, "fps", 30.0);
  float $offsetMatrixWeight = dictGetFloat($dict, "offsetMatrixWeight", 1.0);
  float $damping = dictGetFloat($dict, "damping", 0.1);
  float $elasticity = dictGetFloat($dict, "elasticity", 30.0);
  int $elasticForceFunction = dictGetInt($dict, "elasticForceFunction", 0);
  float $stiffness = dictGetFloat($dict, "stiffness", 0.0);
  float $mass = dictGetFloat($dict, "mass", 1.0);
  float $gravityX = dictGetFloat($dict, "gravityX", 0.0);
  float $gravityY = dictGetFloat($dict, "gravityY", -980.0);
  float $gravityZ = dictGetFloat($dict, "gravityZ", 0.0);
  float $gravityMultiply = dictGetFloat($dict, "gravityMultiply", 0.0);
  float $additionalForceScale = dictGetFloat($dict, "additionalForceScale", 1.0);
  int $enableTurbulence = dictGetBoolean($dict, "enableTurbulence", false);
  int $turbulenceSeed = dictGetInt($dict, "turbulenceSeed", 0);
  float $turbulenceStrength = dictGetFloat($dict, "turbulenceStrength", 10.0);
  float $turbulenceVectorChangeScale = dictGetFloat($dict, "turbulenceVectorChangeScale", 0.05);
  float $turbulenceVectorChangeMax = dictGetFloat($dict, "turbulenceVectorChangeMax", 0.1);
  int $enableAngleLimit = dictGetBoolean($dict, "enableAngleLimit", false);
  float $angleLimit = dictGetFloat($dict, "angleLimit", 60.0);
  float $radius = dictGetFloat($dict, "radius", 0.0);
  int $iterations = dictGetInt($dict, "iterations", 5);
  int $enableGroundCol = dictGetBoolean($dict, "enableGroundCol", false);
  float $groundHeight = dictGetFloat($dict, "groundHeight", 0.0);
  float $meshColCutoff = dictGetFloat($dict, "meshColCutoff", 10.0);

  int $shouldNotify = false;
  for ($bdnNode in $bdnNodes) {
    if (!isType($bdnNode, {"boneDynamicsNode"}, true)) continue;

    setIntAttribute($bdnNode, "enable", $enable);
    setFloatAttribute($bdnNode, "resetTime", $resetTime);
    setFloatAttribute($bdnNode, "fps", $fps);
    setFloatAttribute($bdnNode, "offsetMatrixWeight", $offsetMatrixWeight);
    setFloatAttribute($bdnNode, "damping", $damping);
    setFloatAttribute($bdnNode, "elasticity", $elasticity);
    setIntAttribute($bdnNode, "elasticForceFunction", $elasticForceFunction);
    setFloatAttribute($bdnNode, "stiffness", $stiffness);
    setFloatAttribute($bdnNode, "mass", $mass);
    setFloatAttribute($bdnNode, "gravityX", $gravityX);
    setFloatAttribute($bdnNode, "gravityY", $gravityY);
    setFloatAttribute($bdnNode, "gravityZ", $gravityZ);
    setFloatAttribute($bdnNode, "gravityMultiply", $gravityMultiply);
    setFloatAttribute($bdnNode, "additionalForceScale", $additionalForceScale);
    setIntAttribute($bdnNode, "enableTurbulence", $enableTurbulence);
    setIntAttribute($bdnNode, "turbulenceSeed", $turbulenceSeed);
    setFloatAttribute($bdnNode, "turbulenceStrength", $turbulenceStrength);
    setFloatAttribute($bdnNode, "turbulenceVectorChangeScale", $turbulenceVectorChangeScale);
    setFloatAttribute($bdnNode, "turbulenceVectorChangeMax", $turbulenceVectorChangeMax);
    setIntAttribute($bdnNode, "enableAngleLimit", $enableAngleLimit);
    setFloatAttribute($bdnNode, "angleLimit", $angleLimit);
    setFloatAttribute($bdnNode, "radius", $radius);
    setIntAttribute($bdnNode, "iterations", $iterations);
    setIntAttribute($bdnNode, "enableGroundCol", $enableGroundCol);
    setFloatAttribute($bdnNode, "groundHeight", $groundHeight);
    setFloatAttribute($bdnNode, "meshColCutoff", $meshColCutoff);

    if (!$shouldNotify) $shouldNotify = true;
  }

  if ($shouldNotify) {
    notify("nkBdnEditorBdnAttributeChanged");
  }
}

/*-
@param $bdnNodes <string[]>
@param $attribute <string>
@param $value <float>
@returns <>
*/
proc setFloatBdnAttribute(string $bdnNodes[], string $attribute, float $value) {
  // print("setFloatBdnAttribute\n"); // debug
  // print("  bdnNodes :{\n    " + stringArrayToString($bdnNodes, ",\n    ") + "\n  }\n"); // debug
  // print("  attribute:" + $attribute + "\n"); // debug
  // print("  value    :" + $value + "\n"); // debug
  if (!isBdnPluginLoaded()) return;

  batchSetFloatAttribute($bdnNodes, $attribute, $value);
  notify("nkBdnEditorBdnAttributeChanged");
}

/*-
@param $bdnNodes <string[]>
@param $attribute <string>
@param $value <int>
@returns <>
*/
proc setIntBdnAttribute(string $bdnNodes[], string $attribute, int $value) {
  // print("setIntBdnAttribute\n"); // debug
  // print("  bdnNodes :{\n    " + stringArrayToString($bdnNodes, ",\n    ") + "\n  }\n"); // debug
  // print("  attribute:" + $attribute + "\n"); // debug
  // print("  value    :" + $value + "\n"); // debug
  if (!isBdnPluginLoaded()) return;

  batchSetIntAttribute($bdnNodes, $attribute, $value);
  notify("nkBdnEditorBdnAttributeChanged");
}

// -----------------------------------------------------------------------------
/*-
@param $bdnNodes <string[]>
@param $filename <string> ファイル選択ダイアログを使用するには空文字列を渡す。
@returns <>
*/
proc exportBdnAttributes(string $bdnNodes[], string $filename) {
  // print("exportBdnAttributes\n"); // debug
  // print("  bdnNodes:{\n    " + stringArrayToString($bdnNodes, ",\n    ") + "\n  }\n"); // debug
  // print("  filename:" + $filename + "\n"); // debug
  if (!isBdnPluginLoaded()) return;

  int $numBdnNodes = `size $bdnNodes`;
  if ($numBdnNodes == 0) return;

  if (!`size $filename`) {
    $filename = getSaveFilename("Export boneDynamicsNode Attributes - nkBdnEditor", "*.bdn");
  }
  // print("  filename:" + $filename + "\n"); // debug
  if (!`size $filename`) return;

  string $lastNode = $bdnNodes[$numBdnNodes - 1];
  string $dict = bdnAttributesToDict($lastNode);
  if (!`size $dict`) return;

  if (writeAllText($filename, "", $dict)) {
    print("// nkBdnEditor: write file:" + $filename + "\n");
  }
}

/*-
@param $bdnNodes <string[]>
@param $filename <string> ファイル選択ダイアログを使用するには空文字列を渡す。
@returns <>
*/
proc importBdnAttributes(string $bdnNodes[], string $filename) {
  // print("importBdnAttributes\n"); // debug
  // print("  bdnNodes:{\n    " + stringArrayToString($bdnNodes, ",\n    ") + "\n  }\n"); // debug
  // print("  filename:" + $filename + "\n"); // debug
  if (!isBdnPluginLoaded()) return;

  if (!`size $filename`) {
    $filename = getOpenFilename("Import boneDynamicsNode Attributes - nkBdnEditor", "*.bdn");
  }
  // print("  filename:" + $filename + "\n"); // debug
  if (!existsFilename($filename)) return;

  applyDictToBdnAttributes(readAllText($filename, ""), $bdnNodes);
}

/*-
@param $bdnNodes <string[]>
@returns <>
*/
proc copyBdnAttributes(string $bdnNodes[]) {
  // print("copyBdnAttributes\n"); // debug
  // print("  bdnNodes:{\n    " + stringArrayToString($bdnNodes, ",\n    ") + "\n  }\n"); // debug
  global string $nkBdnEditorBdnAttributeCache;
  if (!isBdnPluginLoaded()) return;

  int $numBdnNodes = `size $bdnNodes`;
  if ($numBdnNodes == 0) return;

  string $lastNode = $bdnNodes[$numBdnNodes - 1];
  $nkBdnEditorBdnAttributeCache = bdnAttributesToDict($lastNode);
  print("// nkBdnEditor: nkBdnEditorBdnAttributeCache:" + $nkBdnEditorBdnAttributeCache + "\n");
}

/*-
@param $bdnNodes <string[]>
@returns <>
*/
proc pasteBdnAttributes(string $bdnNodes[]) {
  // print("pasteBdnAttributes\n"); // debug
  // print("  bdnNodes:{\n    " + stringArrayToString($bdnNodes, ",\n    ") + "\n  }\n"); // debug
  global string $nkBdnEditorBdnAttributeCache;
  if (!isBdnPluginLoaded()) return;

  applyDictToBdnAttributes($nkBdnEditorBdnAttributeCache, $bdnNodes);
}

// -----------------------------------------------------------------------------
// 代替ノード
// -----------------------------------------------------------------------------
/*-
@param $bdnNodes <string[]>
@returns <string[]>
*/
proc string[] substituteBdnNodes(string $bdnNodes[]) {
  // print("substituteBdnNodes\n"); // debug
  // print("  bdnNodes:{\n    " + stringArrayToString($bdnNodes, ",\n    ") + "\n  }\n"); // debug
  string $altNodes[];
  if (!`size $bdnNodes`) return $altNodes;

  for ($bdnNode in $bdnNodes) {
    // print("  bdnNode:" + $bdnNode + "\n"); // debug
    if (isNodeReferenced($bdnNode)) continue;
    if (!isType($bdnNode, {"boneDynamicsNode"}, true)) continue;

    string $altNode = initAltNode(uuidToLongName(toUUID(`createNode -n ($bdnNode + "_ALT") -ss "unknown"`)), $bdnNode);
    $altNodes[`size $altNodes`] = $altNode;

    addAttr -at "bool" -dv 1 -k true -ln "enable" -sn "en" $altNode;

    // time attributes
    addAttr -at "time" -dv 0.0 -k true -ln "time" -sn "t" $altNode;
    addAttr -at "time" -dv 0.0 -k true -ln "resetTime" -sn "rt" $altNode;
    addAttr -at "double" -dv 30.0 -k true -hnv true -min 1.0 -ln "fps" -sn "fps" $altNode;

    // input attributes
    addAttr -at "matrix" -k true -ln "offsetMatrix" -sn "ofmtx" $altNode;
    addAttr -at "double" -dv 1.0 -hxv true -hnv true -k true -max 1.0 -min 0.0 -ln "offsetMatrixWeight" -sn "ofmtxw" $altNode;

    addAttr -at "double3" -ln "boneTranslate" -sn "bt" $altNode;
    addAttr -at "double" -dv 0.0 -k true -ln "boneTranslateX" -p "boneTranslate" -sn "btx" $altNode;
    addAttr -at "double" -dv 0.0 -k true -ln "boneTranslateY" -p "boneTranslate" -sn "bty" $altNode;
    addAttr -at "double" -dv 0.0 -k true -ln "boneTranslateZ" -p "boneTranslate" -sn "btz" $altNode;

    addAttr -at "double3" -ln "boneJointOrient" -sn "bjo" $altNode;
    addAttr -at "doubleAngle" -dv 0.0 -k true -ln "boneJointOrientX" -p "boneJointOrient" -sn "bjox" $altNode;
    addAttr -at "doubleAngle" -dv 0.0 -k true -ln "boneJointOrientY" -p "boneJointOrient" -sn "bjoy" $altNode;
    addAttr -at "doubleAngle" -dv 0.0 -k true -ln "boneJointOrientZ" -p "boneJointOrient" -sn "bjoz" $altNode;

    addAttr -at "matrix" -k true -ln "boneParentMatrix" -sn "bpmtx" $altNode;
    addAttr -at "matrix" -k true -ln "boneParentInverseMatrix" -sn "bpimtx" $altNode;

    addAttr -at "double3" -ln "boneScale" -sn "bs" $altNode;
    addAttr -at "double" -dv 1.0 -k true -ln "boneScaleX" -p "boneScale" -sn "bsx" $altNode;
    addAttr -at "double" -dv 1.0 -k true -ln "boneScaleY" -p "boneScale" -sn "bsy" $altNode;
    addAttr -at "double" -dv 1.0 -k true -ln "boneScaleZ" -p "boneScale" -sn "bsz" $altNode;

    addAttr -at "double3" -ln "boneInverseScale" -sn "bis" $altNode;
    addAttr -at "double" -dv 1.0 -k true -ln "boneInverseScaleX" -p "boneInverseScale" -sn "bisx" $altNode;
    addAttr -at "double" -dv 1.0 -k true -ln "boneInverseScaleY" -p "boneInverseScale" -sn "bisy" $altNode;
    addAttr -at "double" -dv 1.0 -k true -ln "boneInverseScaleZ" -p "boneInverseScale" -sn "bisz" $altNode;

    addAttr -at "double3" -ln "endTranslate" -sn "et" $altNode;
    addAttr -at "double" -dv 0.0 -k true -ln "endTranslateX" -p "endTranslate" -sn "etx" $altNode;
    addAttr -at "double" -dv 0.0 -k true -ln "endTranslateY" -p "endTranslate" -sn "ety" $altNode;
    addAttr -at "double" -dv 0.0 -k true -ln "endTranslateZ" -p "endTranslate" -sn "etz" $altNode;

    addAttr -at "double3" -ln "endScale" -sn "es" $altNode;
    addAttr -at "double" -dv 1.0 -k true -ln "endScaleX" -p "endScale" -sn "esx" $altNode;
    addAttr -at "double" -dv 1.0 -k true -ln "endScaleY" -p "endScale" -sn "esy" $altNode;
    addAttr -at "double" -dv 1.0 -k true -ln "endScaleZ" -p "endScale" -sn "esz" $altNode;

    addAttr -at "double3" -ln "rotationOffset" -sn "ro" $altNode;
    addAttr -at "doubleAngle" -dv 0.0 -k true -ln "rotationOffsetX" -p "rotationOffset" -sn "rox" $altNode;
    addAttr -at "doubleAngle" -dv 0.0 -k true -ln "rotationOffsetY" -p "rotationOffset" -sn "roy" $altNode;
    addAttr -at "doubleAngle" -dv 0.0 -k true -ln "rotationOffsetZ" -p "rotationOffset" -sn "roz" $altNode;

    // dynamics attributes
    addAttr -at "double" -dv 0.1 -hxv true -hnv true -k true -max 1.0 -min 0.0 -ln "damping" -sn "damp" $altNode;
    addAttr -at "double" -dv 30.0 -hnv true -k true -min 0.0 -ln "elasticity" -sn "elas" $altNode;
    addAttr -at "enum" -dv 0 -k true -en "Linear:Quadratic:Cubic" -ln "elasticForceFunction" -sn "eff" $altNode;
    addAttr -at "double" -dv 0.0 -hxv true -hnv true -k true -max 1.0 -min 0.0 -ln "stiffness" -sn "stif" $altNode;
    addAttr -at "double" -dv 1.0 -hnv true -k true -min 0.001 -ln "mass" -sn "m" $altNode;

    addAttr -at "double3" -ln "gravity" -sn "g" $altNode;
    addAttr -at "double" -dv 0.0 -k true -ln "gravityX" -p "gravity" -sn "gx" $altNode;
    addAttr -at "double" -dv -980.0 -k true -ln "gravityY" -p "gravity" -sn "gy" $altNode;
    addAttr -at "double" -dv 0.0 -k true -ln "gravityZ" -p "gravity" -sn "gz" $altNode;

    addAttr -at "double" -dv 0.0 -hxv true -hnv true -k true -max 1.0 -min 0.0 -ln "gravityMultiply" -sn "gm" $altNode;

    addAttr -at "double3" -ln "additionalForce" -sn "af" $altNode;
    addAttr -at "double" -dv 0.0 -k true -ln "additionalForceX" -p "additionalForce" -sn "afx" $altNode;
    addAttr -at "double" -dv 0.0 -k true -ln "additionalForceY" -p "additionalForce" -sn "afy" $altNode;
    addAttr -at "double" -dv 0.0 -k true -ln "additionalForceZ" -p "additionalForce" -sn "afz" $altNode;

    addAttr -at "double" -dv 1.0 -hnv true -k true -min 0.0 -ln "additionalForceScale" -sn "afs" $altNode;

    // turbulence
    addAttr -at "bool" -dv 0 -k true -ln "enableTurbulence" -sn "enw" $altNode;
    addAttr -at "long" -dv 0 -hnv true -k true -min 0.0 -ln "turbulenceSeed" -sn "wsd" $altNode;
    addAttr -at "double" -dv 10.0 -hnv true -k true -min 0.0 -ln "turbulenceStrength" -sn "wst" $altNode;
    addAttr -at "double" -dv 0.05 -hnv true -k true -min 0.0 -ln "turbulenceVectorChangeScale" -sn "wvcs" $altNode;
    addAttr -at "double" -dv 0.1 -hnv true -k true -min 0.0 -ln "turbulenceVectorChangeMax" -sn "wvcm" $altNode;

    // angle limit
    addAttr -at "bool" -dv 0 -k true -ln "enableAngleLimit" -sn "eal" $altNode;
    addAttr -at "double" -dv 60.0 -hxv true -hnv true -k true -max 360.0 -min 0.0 -ln "angleLimit" -sn "al" $altNode;

    // radius
    addAttr -at "double" -dv 0.0 -hnv true -k true -min 0.0 -ln "radius" -sn "r" $altNode;

    // constraint attributes
    addAttr -at "long" -dv 5 -hxv true -hnv true -k true -max 10.0 -min 0.0 -ln "iterations" -sn "iter" $altNode;

    // groundCollider
    addAttr -at "bool" -dv 0 -k true -ln "enableGroundCol" -sn "gc" $altNode;
    addAttr -at "double" -dv 0.0 -k true -ln "groundHeight" -sn "gh" $altNode;

    // sphereCollider
    addAttr -at "compound" -ln "sphereCollider" -m -nc 2 -r true -sn "sc" $altNode;
    addAttr -at "matrix" -k true -ln "sphereColMatrix" -p "sphereCollider" -sn "scmtx" $altNode;
    addAttr -at "double" -dv 0.0 -hnv true -k true -min 0.0 -ln "sphereColRadius" -p "sphereCollider" -sn "scrad" $altNode;

    // capsuleCollider
    addAttr -at "compound" -ln "capsuleCollider" -m -nc 4 -r true -sn "cc" $altNode;
    addAttr -at "matrix" -k true -ln "capsuleColMatrixA" -p "capsuleCollider" -sn "ccmtxa" $altNode;
    addAttr -at "matrix" -k true -ln "capsuleColMatrixB" -p "capsuleCollider" -sn "ccmtxb" $altNode;
    addAttr -at "double" -dv 0.0 -hnv true -k true -min 0.0 -ln "capsuleColRadiusA" -p "capsuleCollider" -sn "ccrada" $altNode;
    addAttr -at "double" -dv 0.0 -hnv true -k true -min 0.0 -ln "capsuleColRadiusB" -p "capsuleCollider" -sn "ccradb" $altNode;

    // infinitePlaneCollider
    addAttr -at "compound" -ln "infinitePlaneCollider" -m -nc 1 -r true -sn "pc" $altNode;
    addAttr -at "matrix" -k true -ln "infinitePlaneColMatrix" -p "infinitePlaneCollider" -sn "pcmtx" $altNode;

    // meshCollider
    addAttr -dt "mesh" -ln "meshCollider" -m -r true -sn "mc" $altNode;
    addAttr -at "double" -dv 10.0 -hnv true -k true -min 0.0 -ln "meshColCutoff" -sn "mcc" $altNode;

    // output attributes
    addAttr -at "double3" -ln "outputRotate" -sn "outr" -s true -w false $altNode;
    addAttr -at "doubleAngle" -dv 0.0 -ln "outputRotateX" -p "outputRotate" -sn "outrx" $altNode;
    addAttr -at "doubleAngle" -dv 0.0 -ln "outputRotateY" -p "outputRotate" -sn "outry" $altNode;
    addAttr -at "doubleAngle" -dv 0.0 -ln "outputRotateZ" -p "outputRotate" -sn "outrz" $altNode;

    string $inPlugSourceAttributes[];
    string $inPlugBdnAttributes[];
    getSourceConnections($bdnNode, {}, "", $inPlugSourceAttributes, $inPlugBdnAttributes);
    // print("    inPlugSourceAttributes:{\n      " + stringArrayToString($inPlugSourceAttributes, ",\n      ") + "\n    }\n"); // debug
    // print("    inPlugBdnAttributes   :{\n      " + stringArrayToString($inPlugBdnAttributes, ",\n      ") + "\n    }\n"); // debug
    string $inPlugAltAttributes[];
    for ($i = 0; $i < `size $inPlugBdnAttributes`; $i++) {
      $inPlugAltAttributes[$i] = `substitute $bdnNode $inPlugBdnAttributes[$i] $altNode`;
    }
    // print("    inPlugAltAttributes   :{\n      " + stringArrayToString($inPlugAltAttributes, ",\n      ") + "\n    }\n"); // debug

    string $outPlugBdnAttributes[];
    string $outPlugTargetAttributes[];
    getDestConnections($bdnNode, {}, "", $outPlugBdnAttributes, $outPlugTargetAttributes);
    // print("    outPlugBdnAttributes   :{\n      " + stringArrayToString($outPlugBdnAttributes, ",\n      ") + "\n    }\n"); // debug
    // print("    outPlugTargetAttributes:{\n      " + stringArrayToString($outPlugTargetAttributes, ",\n      ") + "\n    }\n"); // debug
    string $outPlugAltAttributes[];
    for ($i = 0; $i < `size $outPlugBdnAttributes`; $i++) {
      $outPlugAltAttributes[$i] = `substitute $bdnNode $outPlugBdnAttributes[$i] $altNode`;
    }
    // print("    outPlugAltAttributes   :{\n      " + stringArrayToString($outPlugAltAttributes, ",\n      ") + "\n    }\n"); // debug

    connectAttributes($inPlugSourceAttributes, $inPlugAltAttributes, true);
    connectAttributes($outPlugAltAttributes, $outPlugTargetAttributes, true);

    disconnectAttributes($inPlugSourceAttributes, $inPlugBdnAttributes);
    disconnectAttributes($outPlugBdnAttributes, $outPlugTargetAttributes);
    delete $bdnNode;
  }
  return $altNodes;
}

/*-
@param $altNodes <string[]>
@returns <string[]>
*/
proc string[] restoreBdnNodes(string $altNodes[]) {
  // print("restoreBdnNodes\n"); // debug
  // print("  altNodes:{\n    " + stringArrayToString($altNodes, ",\n    ") + "\n  }\n"); // debug
  string $bdnNodes[];
  if (!`size $altNodes`) return $bdnNodes;

  for ($altNode in $altNodes) {
    if (isNodeReferenced($altNode)) continue;
    if (!isBdnType($altNode, "alt")) continue;

    string $sourceName = getStringFromDict($altNode, "bdnData", "sourceName", "");
    if (!`size $sourceName`) continue;

    string $bdnNode = uuidToLongName(toUUID(`createNode -n $sourceName -ss "boneDynamicsNode"`));
    $bdnNodes[`size $bdnNodes`] = $bdnNode;

    string $inPlugSourceAttributes[];
    string $inPlugAltAttributes[];
    getSourceConnections($altNode, {}, "", $inPlugSourceAttributes, $inPlugAltAttributes);
    // print("    inPlugSourceAttributes:{\n      " + stringArrayToString($inPlugSourceAttributes, ",\n      ") + "\n    }\n"); // debug
    // print("    inPlugAltAttributes   :{\n      " + stringArrayToString($inPlugAltAttributes, ",\n      ") + "\n    }\n"); // debug
    string $inPlugBdnAttributes[];
    for ($i = 0; $i < `size $inPlugAltAttributes`; $i++) {
      $inPlugBdnAttributes[$i] = `substitute $altNode $inPlugAltAttributes[$i] $bdnNode`;
    }
    // print("    inPlugBdnAttributes   :{\n      " + stringArrayToString($inPlugBdnAttributes, ",\n      ") + "\n    }\n"); // debug

    string $outPlugAltAttributes[];
    string $outPlugTargetAttributes[];
    getDestConnections($altNode, {}, "", $outPlugAltAttributes, $outPlugTargetAttributes);
    // print("    outPlugAltAttributes   :{\n      " + stringArrayToString($outPlugAltAttributes, ",\n      ") + "\n    }\n"); // debug
    // print("    outPlugTargetAttributes:{\n      " + stringArrayToString($outPlugTargetAttributes, ",\n      ") + "\n    }\n"); // debug
    string $outPlugBdnAttributes[];
    for ($i = 0; $i < `size $outPlugAltAttributes`; $i++) {
      $outPlugBdnAttributes[$i] = `substitute $altNode $outPlugAltAttributes[$i] $bdnNode`;
    }
    // print("    outPlugBdnAttributes   :{\n      " + stringArrayToString($outPlugBdnAttributes, ",\n      ") + "\n    }\n"); // debug

    connectAttributes($inPlugSourceAttributes, $inPlugBdnAttributes, true);
    connectAttributes($outPlugBdnAttributes, $outPlugTargetAttributes, true);

    disconnectAttributes($inPlugSourceAttributes, $inPlugAltAttributes);
    disconnectAttributes($outPlugAltAttributes, $outPlugTargetAttributes);
    delete $altNode;
  }
  return $bdnNodes;
}

// -----------------------------------------------------------------------------
// ダイナミクスユニット階層探索用スクリプト
// -----------------------------------------------------------------------------
/*-
@param $sourceId <string>
@param $parentId <string>
@returns <string[]>
*/
global proc string[] nkBdnEditorGenerateDynamicsScript(
  string $sourceId,
  string $parentId
) {
  string $sourceNode = uuidToLongName($sourceId);
  string $parentNode = uuidToLongName($parentId);
  if (!`objExists $sourceNode`) return {$sourceId, $parentId};

  string $nodeId = $parentId;
  if (isSelected($sourceNode)) {
    // print("sourceNode:" + $sourceNode + "\n"); // debug
    // print("parentNode:" + $parentNode + "\n"); // debug
    string $name = toShortName($sourceNode);
    if (!`objExists $parentNode`) {
      $parentNode = initSpaceNode(createTransform($name + "_Dynamics_SPC", $parentNode, true, $sourceNode, {}), "dynamics");

      // ノード接続
      addAttr -at "message" -ln "bdnBindSource" $parentNode;
      string $parentSourceNode = getParentNode($sourceNode);
      if (`objExists $parentSourceNode`) {
        connectMessage($parentSourceNode, $parentNode, "bdnBindSource");
      }
    }
    string $node = initJointNode(createJoint($name + "_Dynamics", $parentNode, true, $sourceNode, {}), "dynamics", "normal");
    $nodeId = toUUID($node);

    // ノード接続
    addAttr -at "message" -ln "bdnBindTarget" $node;
    connectMessage($sourceNode, $node, "bdnBindTarget");

    // sscをここで設定してもなぜか反映されない
    // setIntAttribute($node, "ssc", false);
  }
  return {$nodeId, $sourceId};
}

/*-
@param $sourceId <string>
@param $parentId <string>
@returns <string[]>
*/
global proc string[] nkBdnEditorGenerateTargetScript(
  string $sourceId,
  string $parentId
) {
  string $sourceNode = uuidToLongName($sourceId);
  string $parentNode = uuidToLongName($parentId);
  if (!`objExists $sourceNode`) return {$sourceId, $parentId};

  string $nodeId = $parentId;
  if (isSelected($sourceNode)) {
    // print("sourceNode:" + $sourceNode + "\n"); // debug
    // print("parentNode:" + $parentNode + "\n"); // debug
    string $name = toShortName($sourceNode);
    if (!`objExists $parentNode`) {
      $parentNode = initSpaceNode(createTransform($name + "_Target_SPC", $parentNode, true, $sourceNode, {}), "target");

      // ノード接続
      addAttr -at "message" -ln "bdnBindSource" $parentNode;
      string $parentSourceNode = getParentNode($sourceNode);
      if (`objExists $parentSourceNode`) {
        connectMessage($parentSourceNode, $parentNode, "bdnBindSource");
      }
    }
    string $node = initJointNode(createJoint($name + "_Target", $parentNode, true, $sourceNode, {}), "target", "normal");
    $nodeId = toUUID($node);

    // ノード接続
    addAttr -at "message" -ln "bdnSource" $node;
    connectMessage($sourceNode, $node, "bdnSource");

    // sscをここで設定してもなぜか反映されない
    // setIntAttribute($node, "ssc", false);
  }
  return {$nodeId, $sourceId};
}

// -----------------------------------------------------------------------------
// ダイナミクスユニット
// -----------------------------------------------------------------------------
/*-
スケルトンの分岐を処理する。
@param $nodes <string[]>
@param $branchAimVector <float[3]>
@param $branchUpVector <float[3]>
@returns <string[]>
*/
proc string[] splitSkeletonBranch(
  string $nodes[],
  float $branchAimVector[],
  float $branchUpVector[]
) {
  // print("splitSkeletonBranch\n"); // debug
  // print("  nodes          :{\n    " + stringArrayToString($nodes, ",\n    ") + "\n  }\n"); // debug
  // print("  branchAimVector:{" + floatArrayToString($branchAimVector, ", ") + "}\n"); // debug
  // print("  branchUpVector :{" + floatArrayToString($branchUpVector, ", ") + "}\n"); // debug

  string $nodeIds[];
  for ($node in $nodes) {
    $nodeIds[`size $nodeIds`] = toUUID($node);
  }

  string $newNodes[];
  for ($nodeId in $nodeIds) {
    string $node = uuidToLongName($nodeId);
    $newNodes[`size $newNodes`] = $node;
    string $childNodes[] = collectChildNodes($node);
    if (`size $childNodes` > 1) {
      for ($childNode in $childNodes) {
        string $jointKind = getJointKind($childNode);
        initJointNode($childNode, $jointKind, "branch");
        string $name = toShortName($childNode);

        string $dummyAimNode = createTransform($name + "_Dummy", "", true, $node, {true, false, false});
        string $constraintNodes[] = `aimConstraint
            -aim $branchAimVector[0] $branchAimVector[1] $branchAimVector[2]
            -u $branchUpVector[0] $branchUpVector[1] $branchUpVector[2]
            -wuo $childNode
            -wut 2
            -wu 0.0 1.0 0.0
            $childNode
            $dummyAimNode`;

        string $branchSpcNode = initSpaceNode(createTransform($name + "_Branch_SPC", "", true, $dummyAimNode, {}), $jointKind);
        string $branchJointNode = initJointNode(createJoint($name + "_Branch", $branchSpcNode, true, $branchSpcNode, {}), $jointKind, "normal");
        setParentNode({$childNode}, $branchJointNode);
        $newNodes[`size $newNodes`] = $branchSpcNode;
        $newNodes[`size $newNodes`] = $branchJointNode;

        delete $dummyAimNode;

        // ノード接続
        addAttr -at "message" -ln "bdnBindSource" $branchSpcNode;
        addAttr -at "message" -ln "bdnBindTarget" $branchJointNode;
        connectMessage($node, $branchSpcNode, "bdnBindSource");
        // `$branchJointNode`はソース無し
      }
    }
  }
  return $newNodes;
}

/*-
プロキシスケルトンの末端にジョイントを追加する。
@param $nodes <string[]>
@param $endJointOffset <float[3]>
@returns <string[]>
*/
proc string[] generateEndJoint(string $nodes[], float $endJointOffset[]) {
  // print("generateEndJoint\n"); // debug
  // print("  nodes         :{\n    " + stringArrayToString($nodes, ",\n    ") + "\n  }\n"); // debug
  // print("  endJointOffset:{" + floatArrayToString($endJointOffset, ", ") + "}\n"); // debug

  string $newNodes[];
  for ($node in $nodes) {
    $newNodes[`size $newNodes`] = $node;
    string $childNodes[] = collectChildNodes($node);
    if (!`size $childNodes`) {
      string $name = toShortName($node);
      string $jointKind = getJointKind($node);
      string $jointNode = initJointNode(createJoint($name + "_End", $node, true, $node, {}), $jointKind, "end");
      $newNodes[`size $newNodes`] = $jointNode;

      // ノード接続
      addAttr -at "message" -ln "bdnBindTarget" $jointNode;

      // アトリビュート値設定
      setFloat3Attribute($jointNode, "t", $endJointOffset);
    }
  }
  return $newNodes;
}

/*-
@param $nodes <string[]>
@returns <string[]>
*/
proc string[] constraintSkeleton(string $nodes[]) {
  // print("constraintSkeleton\n"); // debug
  // print("  nodes:{\n    " + stringArrayToString($nodes, ",\n    ") + "\n  }\n"); // debug
  string $constraintNodes[];
  for ($n in $nodes) {
    if (!(
      hasDictAttribute($n, "bdnData")
          && (existsAttribute($n, "bdnBindSource") || existsAttribute($n, "bdnBindTarget"))
    )) continue;

    string $bdnType = getBdnType($n);
    string $nodeName = toShortName($n);

    if ($bdnType == "space") {
      string $sourceNodes[] = getSourceConnections($n, {"bdnBindSource"}, "", {}, {});
      if (`size $sourceNodes` != 1) continue;

      string $sourceNode = longNameOf($sourceNodes[0]);
      // print("  sourceNode:" + $sourceNode + "\n"); // debug
      string $prcstNodes[] = `parentConstraint -mo $sourceNode $n`;
      if (`size $prcstNodes`) {
        $constraintNodes[`size $constraintNodes`] = setNodeName(
          $prcstNodes[0],
          $nodeName + "_PRCST",
          false
        );
      }
    }
    else if ($bdnType == "joint") {
      string $jointType = getJointType($n);
      string $targetNodes[] = getSourceConnections($n, {"bdnBindTarget"}, "", {}, {});
      if (`size $targetNodes` != 1) continue;

      string $targetNode = longNameOf($targetNodes[0]);
      // print("  targetNode:" + $targetNode + "\n"); // debug

      if ($jointType == "branch") {
        if (!unlockTransformAttributes($targetNode, true, true, false)) continue;

        string $prcstNodes[] = `parentConstraint $n $targetNode`;
        if (`size $prcstNodes`) {
          $constraintNodes[`size $constraintNodes`] = setNodeName(
            $prcstNodes[0],
            $nodeName + "_PRCST",
            false
          );
        }
      }
      else {
        if (!unlockTransformAttributes($targetNode, false, true, false)) continue;

        string $orcstNodes[] = `orientConstraint $n $targetNode`;
        if (`size $orcstNodes`) {
          $constraintNodes[`size $constraintNodes`] = setNodeName(
            $orcstNodes[0],
            $nodeName + "_ORCST",
            false
          );
        }
      }
    }
  }
  return $constraintNodes;
}

/*-
@param $nodes <string[]>
@returns <string[]>
*/
proc string[] generateBdnNodes(string $nodes[]) {
  // print("generateBdnNodes\n"); // debug
  // print("  nodes:{\n    " + stringArrayToString($nodes, ",\n    ") + "\n  }\n"); // debug
  string $bdnNodes[];
  if (!isBdnPluginLoaded()) return $bdnNodes;

  string $timeNode = getTimeNode();
  if (!`objExists $timeNode`) return $bdnNodes;

  string $jointNodes[];
  for ($n in $nodes) {
    if (!isBdnType($n, "joint")) continue;

    $jointNodes[`size $jointNodes`] = $n;
  }
  int $numJointNodes = `size $jointNodes`;
  for ($i = 0; $i < $numJointNodes - 1; $i++) {
    string $joint1Node = $jointNodes[$i];
    string $joint2Node = $jointNodes[$i + 1];
    if (isJointType($joint1Node, "end")) continue;

    string $bdnNode = uuidToLongName(toUUID(`createNode -n (toShortName($joint1Node) + "_BDN") -ss "boneDynamicsNode"`));
    connectAttr -f ($joint1Node + ".translate"          ) ($bdnNode    + ".boneTranslate"          );
    connectAttr -f ($joint1Node + ".jointOrient"        ) ($bdnNode    + ".boneJointOrient"        );
    connectAttr -f ($joint1Node + ".parentMatrix"       ) ($bdnNode    + ".boneParentMatrix"       );
    connectAttr -f ($joint1Node + ".parentInverseMatrix") ($bdnNode    + ".boneParentInverseMatrix");
    connectAttr -f ($joint2Node + ".translate"          ) ($bdnNode    + ".endTranslate"           );
    connectAttr -f ($timeNode   + ".outTime"            ) ($bdnNode    + ".time"                   );
    connectAttr -f ($bdnNode    + ".outputRotate"       ) ($joint1Node + ".rotate"                 );

    $bdnNodes[`size $bdnNodes`] = $bdnNode;
  }
  return $bdnNodes;
}

/*-
@param $nodes <string[]>
@returns <string[]>
*/
proc string[] generateRadiusSphere(string $nodes[]) {
  // print("generateRadiusSphere\n"); // debug
  // print("  nodes:{\n    " + stringArrayToString($nodes, ",\n    ") + "\n  }\n"); // debug
  string $sphereNodes[];
  if (!isBdnPluginLoaded()) return $sphereNodes;

  for ($n in $nodes) {
    if (!isType($n, {"boneDynamicsNode"}, true)) continue;

    string $endNodes[] = getSourceConnections($n, {"endTranslate"}, "", {}, {});
    if (!`size $endNodes`) continue;

    string $endNode = $endNodes[0];
    string $jointName = toShortName($endNode);
    string $shapeNode = longNameOf(`createNode -ss "implicitSphere"`);
    string $shapeId = toUUID($shapeNode);
    string $transformNode = initRadiusNode(buildDagNode(getParentNode($shapeNode), $jointName + "_Radius", $endNode, true, $endNode, {}));
    $shapeNode = uuidToLongName($shapeId);
    $sphereNodes[`size $sphereNodes`] = $transformNode;
    $sphereNodes[`size $sphereNodes`] = $shapeNode;
    setIntAttribute($transformNode, "overrideEnabled", true);
    setIntAttribute($transformNode, "overrideDisplayType", 2);
    connectAttr -f ($n + ".radius") ($shapeNode + ".radius");
  }

  return $sphereNodes;
}

/*-
@param $sourceNodes <string[]>
@param $branchAimVector <float[3]>
@param $branchUpVector <float[3]>
@returns <string[]>
*/
proc string[] generateTarget(
  string $sourceNodes[],
  float $branchAimVector[],
  float $branchUpVector[]
) {
  // print("generateTarget\n"); // debug
  // print("  sourceNodes    :{\n    " + stringArrayToString($sourceNodes, ",\n    ") + "\n  }\n"); // debug
  // print("  branchAimVector:{" + floatArrayToString($branchAimVector, ", ") + "}\n"); // debug
  // print("  branchUpVector :{" + floatArrayToString($branchUpVector, ", ") + "}\n"); // debug

  string $targetNodes[];
  if (!`size $sourceNodes`) return $targetNodes;

  string $targetGrpNode = initGroupNode(getSecondLevelNode("BDN_GRP", "Target_GRP", true, true), "target");
  initGroupNode(getTopLevelNode("BDN_GRP", false, true), "bdn");
  // print("  targetGrpNode:" + $targetGrpNode + "\n"); // debug
  if (!`objExists $targetGrpNode`) return $targetNodes;

  string $targetSkeletonNodes[] = collectHierarchyNodes(
    $sourceNodes,
    "",
    {"transform"},
    false,
    "nkBdnEditorGenerateTargetScript"
  );
  $targetSkeletonNodes = splitSkeletonBranch($targetSkeletonNodes, $branchAimVector, $branchUpVector);

  string $targetSpcNodes[] = collectRootNodes($targetSkeletonNodes);
  $targetSpcNodes = setParentNode($targetSpcNodes, $targetGrpNode);
  // print("  targetSpcNodes:{\n    " + stringArrayToString($targetSpcNodes, ",\n    ") + "\n  }\n"); // debug
  setOutlinerColor($targetSpcNodes, {0.0, 0.0, 1.0});
  for ($targetSpcNode in $targetSpcNodes) {
    $targetNodes = stringArrayCatenate(
      $targetNodes,
      collectDescendantNodes($targetSpcNode, "", {}, false, "")
    );
    string $jointNodes[] = collectDescendantNodes($targetSpcNode, "", {"joint"}, true, "");
    batchSetFloatAttribute($jointNodes, "radius", 1.0);
    setOverrideColor($jointNodes, 6);
    freezeTransform($jointNodes, {});
  }

  $targetNodes = stringArrayCatenate($targetNodes, constraintSkeleton($targetNodes));

  for ($targetNode in $targetNodes) {
    if (!isJointKind($targetNode, "target")) continue;

    string $dynamicsNode;
    string $sourceNodes[] = getSourceConnections($targetNode, {"bdnSource"}, "", {}, {});
    if (`size $sourceNodes` != 1) continue;

    string $sourceNode = $sourceNodes[0];
    string $jointNodes[] = getDestConnections($sourceNode, {"message"}, "", {}, {});
    for ($jointNode in $jointNodes) {
      if (isJointKind($jointNode, "dynamics")) {
        $dynamicsNode = $jointNode;
        break;
      }
    }
    if (!isJointKind($dynamicsNode, "dynamics")) continue;

    string $bdnNodes[] = getSourceConnections($dynamicsNode, {"rotate"}, "", {}, {});
    if (`size $bdnNodes` != 1) continue;

    string $bdnNode = $bdnNodes[0];
    if (!isType($bdnNode, {"boneDynamicsNode"}, true)) continue;

    connectAttr -f ($targetNode + ".rotate") ($bdnNode + ".rotationOffset");
  }

  return $targetNodes;
}

/*-
@param $sourceNodes <string[]>
@param $branchAimVector <float[3]>
@param $branchUpVector <float[3]>
@param $endJointOffset <float[3]>
@returns <string[]>
*/
proc string[] generateDynamicsUnit(
  string $sourceNodes[],
  float $branchAimVector[],
  float $branchUpVector[],
  float $endJointOffset[]
) {
  // print("generateDynamicsUnit\n"); // debug
  // print("  sourceNodes    :{\n    " + stringArrayToString($sourceNodes, ",\n    ") + "\n  }\n"); // debug
  // print("  branchAimVector:{" + floatArrayToString($branchAimVector, ", ") + "}\n"); // debug
  // print("  branchUpVector :{" + floatArrayToString($branchUpVector, ", ") + "}\n"); // debug
  // print("  endJointOffset :{" + floatArrayToString($endJointOffset, ", ") + "}\n"); // debug

  string $dynamicsNodes[];
  if (!`size $sourceNodes`) return $dynamicsNodes;

  if (!isBdnPluginLoaded()) loadBdnPlugin();
  if (!isBdnPluginLoaded()) return $dynamicsNodes;

  string $dynamicsGrpNode = initGroupNode(getSecondLevelNode("BDN_GRP", "Dynamics_GRP", true, true), "dynamics");
  initGroupNode(getTopLevelNode("BDN_GRP", false, true), "bdn");
  // print("  dynamicsGrpNode:" + $dynamicsGrpNode + "\n"); // debug
  if (!`objExists $dynamicsGrpNode`) return $dynamicsNodes;

  string $dynamicsSkeletonNodes[] = collectHierarchyNodes(
    $sourceNodes,
    "",
    {"transform"},
    false,
    "nkBdnEditorGenerateDynamicsScript"
  );
  $dynamicsSkeletonNodes = splitSkeletonBranch($dynamicsSkeletonNodes, $branchAimVector, $branchUpVector);
  $dynamicsSkeletonNodes = generateEndJoint($dynamicsSkeletonNodes, $endJointOffset);

  string $dynamicsSpcNodes[] = collectRootNodes($dynamicsSkeletonNodes);
  $dynamicsSpcNodes = setParentNode($dynamicsSpcNodes, $dynamicsGrpNode);
  // print("  dynamicsSpcNodes:{\n    " + stringArrayToString($dynamicsSpcNodes, ",\n    ") + "\n  }\n"); // debug
  setOutlinerColor($dynamicsSpcNodes, {1.0, 0.0, 0.0});
  for ($dynamicsSpcNode in $dynamicsSpcNodes) {
    $dynamicsNodes = stringArrayCatenate(
      $dynamicsNodes,
      collectDescendantNodes($dynamicsSpcNode, "", {}, false, "")
    );
    string $jointNodes[] = collectDescendantNodes($dynamicsSpcNode, "", {"joint"}, true, "");
    batchSetFloatAttribute($jointNodes, "radius", 0.5);
    setOverrideColor($jointNodes, 13);
    freezeTransform($jointNodes, {});
  }

  $dynamicsNodes = stringArrayCatenate($dynamicsNodes, constraintSkeleton($dynamicsNodes));
  $dynamicsNodes = stringArrayCatenate($dynamicsNodes, generateBdnNodes($dynamicsNodes));
  $dynamicsNodes = stringArrayCatenate($dynamicsNodes, generateRadiusSphere($dynamicsNodes));
  $dynamicsNodes = stringArrayCatenate($dynamicsNodes, generateTarget($sourceNodes, $branchAimVector, $branchUpVector));

  if (`size $dynamicsNodes`) {
    notify("nkBdnEditorDynamicsNodeCreated");
  }

  return $dynamicsNodes;
}

// -----------------------------------------------------------------------------
// コライダー
// -----------------------------------------------------------------------------
/*-
@param $sourceNodes <string[]>
@param $shouldCreateEnd <boolean>
@returns <string[]>
*/
proc string[] createCapsuleCollider(string $sourceNodes[], int $shouldCreateEnd) {
  // print("createCapsuleCollider\n"); // debug
  // print("  sourceNodes    :{\n    " + stringArrayToString($sourceNodes, ",\n    ") + "\n  }\n"); // debug
  // print("  shouldCreateEnd:" + $shouldCreateEnd + "\n"); // debug
  string $colliderNodes[];
  string $colliderType = "capsule";
  string $colliderName = "CapsuleCollider";

  string $colliderGrpNode = initGroupNode(getSecondLevelNode("BDN_GRP", "Collider_GRP", true, true), "collider");
  initGroupNode(getTopLevelNode("BDN_GRP", false, true), "bdn");
  // print("  colliderGrpNode:" + $colliderGrpNode + "\n"); // debug
  if (!`objExists $colliderGrpNode`) return $colliderNodes;

  if (!`size $sourceNodes`) $sourceNodes = {""};
  int $numSourceNodes = `size $sourceNodes`;
  int $lastIndex = $numSourceNodes - 1;
  for ($i = 0; $i < $numSourceNodes; $i++) {
    if (!$shouldCreateEnd && $i == $lastIndex) continue;

    string $affectedNodes[];
    string $sourceNode = $sourceNodes[$i];
    string $sourceShortName = toShortName($sourceNode);
    string $spcNodeName = join({$sourceShortName, $colliderName, "SPC"}, "_", true);
    string $colliderNodeName = join({$sourceShortName, $colliderName}, "_", true);

    string $nextSourceNode;
    if ($i < $lastIndex) {
      $nextSourceNode = $sourceNodes[$i + 1];
    }
    // print("      sourceNode:" + $sourceNode + "\n"); // debug
    // print("  nextSourceNode:" + $nextSourceNode + "\n"); // debug

    // ノード作成
    string $spcNode = initSpaceNode(createTransform($spcNodeName, $colliderGrpNode, true, $sourceNode, {}), "collider");
    string $transformNode = createTransform($colliderNodeName, $spcNode, true, $spcNode, {});
    $colliderNodes[`size $colliderNodes`] = $spcNode;
    $colliderNodes[`size $colliderNodes`] = $transformNode;

    string $sphereANodes[] = `sphere -ax 0.0 1.0 0.0 -d 3 -esw 270.0 -hr 2.0 -r 0.5 -s 4 -nsp 4 -ssw 90.0`;
    string $sphereATransformNode = initColliderComponentNode(
      buildDagNode(longNameOf($sphereANodes[0]), $colliderNodeName + "_SphereA", $transformNode, true, $transformNode, {})
    );
    string $makeSphereANode = longNameOf($sphereANodes[1]);
    string $sphereAShapeNodes[] = getShapeNodes($sphereATransformNode, "");
    $colliderNodes[`size $colliderNodes`] = $sphereATransformNode;
    $colliderNodes[`size $colliderNodes`] = $makeSphereANode;
    $colliderNodes = stringArrayCatenate($colliderNodes, $sphereAShapeNodes);

    $affectedNodes[`size $affectedNodes`] = $sphereATransformNode;
    $affectedNodes[`size $affectedNodes`] = $makeSphereANode;
    $affectedNodes = stringArrayCatenate($affectedNodes, $sphereAShapeNodes);

    string $sphereBNodes[] = `sphere -ax 0.0 1.0 0.0 -d 3 -esw 90.0 -hr 2.0 -r 0.5 -s 4 -nsp 4 -ssw -90.0`;
    string $sphereBTransformNode = initColliderComponentNode(
      buildDagNode(longNameOf($sphereBNodes[0]), $colliderNodeName + "_SphereB", $transformNode, true, $transformNode, {})
    );
    string $makeSphereBNode = longNameOf($sphereBNodes[1]);
    string $sphereBShapeNodes[] = getShapeNodes($sphereBTransformNode, "");
    $colliderNodes[`size $colliderNodes`] = $sphereBTransformNode;
    $colliderNodes[`size $colliderNodes`] = $makeSphereBNode;
    $colliderNodes = stringArrayCatenate($colliderNodes, $sphereBShapeNodes);

    $affectedNodes[`size $affectedNodes`] = $sphereBTransformNode;
    $affectedNodes[`size $affectedNodes`] = $makeSphereBNode;
    $affectedNodes = stringArrayCatenate($affectedNodes, $sphereBShapeNodes);

    string $circleANodes[] = `circle -d 3 -fp 1.0 0.0 0.0 -fc true -nr 1.0 0.0 0.0 -r 0.5 -s 8`;
    string $circleATransformNode = initColliderComponentNode(
      buildDagNode(longNameOf($circleANodes[0]), $colliderNodeName + "_CircleA", $transformNode, true, $transformNode, {})
    );
    string $makeCircleANode = longNameOf($circleANodes[1]);
    string $circleAShapeNodes[] = getShapeNodes($circleATransformNode, "");
    $colliderNodes[`size $colliderNodes`] = $circleATransformNode;
    $colliderNodes[`size $colliderNodes`] = $makeCircleANode;
    $colliderNodes = stringArrayCatenate($colliderNodes, $circleAShapeNodes);

    $affectedNodes[`size $affectedNodes`] = $circleATransformNode;
    $affectedNodes[`size $affectedNodes`] = $makeCircleANode;
    $affectedNodes = stringArrayCatenate($affectedNodes, $circleAShapeNodes);

    string $circleBNodes[] = `circle -d 3 -fp 1.0 0.0 0.0 -fc true -nr 1.0 0.0 0.0 -r 0.5 -s 8`;
    string $circleBTransformNode = initColliderComponentNode(
      buildDagNode(longNameOf($circleBNodes[0]), $colliderNodeName + "_CircleB", $transformNode, true, $transformNode, {})
    );
    string $makeCircleBNode = longNameOf($circleBNodes[1]);
    string $circleBShapeNodes[] = getShapeNodes($circleBTransformNode, "");
    $colliderNodes[`size $colliderNodes`] = $circleBTransformNode;
    $colliderNodes[`size $colliderNodes`] = $makeCircleBNode;
    $colliderNodes = stringArrayCatenate($colliderNodes, $circleBShapeNodes);

    $affectedNodes[`size $affectedNodes`] = $circleBTransformNode;
    $affectedNodes[`size $affectedNodes`] = $makeCircleBNode;
    $affectedNodes = stringArrayCatenate($affectedNodes, $circleBShapeNodes);

    string $loftNodes[] = `loft -d 3 -ss 1 $circleBTransformNode $circleATransformNode`;
    string $loftTransformNode = initColliderComponentNode(
      buildDagNode(longNameOf($loftNodes[0]), $colliderNodeName + "_Loft", $transformNode, false, "", {})
    );
    string $loftNode = longNameOf($loftNodes[1]);
    string $loftShapeNodes[] = getShapeNodes($loftTransformNode, "");
    $colliderNodes[`size $colliderNodes`] = $loftTransformNode;
    $colliderNodes[`size $colliderNodes`] = $loftNode;
    $colliderNodes = stringArrayCatenate($colliderNodes, $loftShapeNodes);

    $affectedNodes[`size $affectedNodes`] = $loftTransformNode;
    $affectedNodes[`size $affectedNodes`] = $loftNode;
    $affectedNodes = stringArrayCatenate($affectedNodes, $loftShapeNodes);

    // ノード初期化
    initColliderNode($transformNode, $colliderType);
    setOutlinerColor({$spcNode}, {1.0, 1.0, 0.0});
    setOverrideColor($sphereAShapeNodes, 17);
    setOverrideColor($sphereBShapeNodes, 17);
    setOverrideColor($circleAShapeNodes, 17);
    setOverrideColor($circleBShapeNodes, 17);
    setOverrideColor($loftShapeNodes, 17);

    // アトリビュート設定
    addAttr -at "message" -ln "colliderAffectedBy" -m $transformNode;
    addAttr -dt "string" -ln "colliderSource" $spcNode;
    addAttr -dt "string" -ln "colliderAimTarget" $spcNode;
    addAttr -at "double" -dv 0.5 -k true -hxv false -hnv true -min 0.001 -ln "colliderRadiusA" $transformNode;
    addAttr -at "double" -dv 0.5 -k true -hxv false -hnv true -min 0.001 -ln "colliderRadiusB" $transformNode;
    addAttr -at "double" -dv 2.0 -k true -hxv false -hnv false -ln "colliderLength" $transformNode;
    addAttr -at "double" -dv 0.0 -k true -hxv false -hnv false -ln "colliderOffset" $transformNode;
    addAttr -at "enum" -dv 0 -k true -en "A:Center:B" -ln "colliderPivot" $transformNode;
    addAttr -at "matrix" -h true -k true -ln "colliderMatrixA" $transformNode;
    addAttr -at "matrix" -h true -k true -ln "colliderMatrixB" $transformNode;

    // アトリビュートエイリアス設定
    string $colliderAttributes[] = {
      "colliderRadiusA",
      "colliderRadiusB",
      "colliderLength",
      "colliderOffset",
      "colliderPivot"
    };
    addProxyAttributes($transformNode, $colliderAttributes, $spcNode);
    addProxyAttributes($transformNode, $colliderAttributes, $sphereATransformNode);
    addProxyAttributes($transformNode, $colliderAttributes, $sphereBTransformNode);
    addProxyAttributes($transformNode, $colliderAttributes, $circleATransformNode);
    addProxyAttributes($transformNode, $colliderAttributes, $circleBTransformNode);
    addProxyAttributes($transformNode, $colliderAttributes, $loftTransformNode);

    // 計算ノード作成
    string $halfLengthNode = uuidToLongName(toUUID(`createNode -n ($colliderNodeName + "_halfLength") -ss "floatMath"`));
    string $pivotNode = uuidToLongName(toUUID(`createNode -n ($colliderNodeName + "_pivot") -ss "floatMath"`));
    string $offsetANode = uuidToLongName(toUUID(`createNode -n ($colliderNodeName + "_offsetA") -ss "floatMath"`));
    string $offsetBNode = uuidToLongName(toUUID(`createNode -n ($colliderNodeName + "_offsetB") -ss "floatMath"`));
    string $lengthDirNode = uuidToLongName(toUUID(`createNode -n ($colliderNodeName + "_lengthDir") -ss "condition"`));
    string $sweepRangeANode = uuidToLongName(toUUID(`createNode -n ($colliderNodeName + "_sweepRangeA") -ss "setRange"`));
    string $sweepRangeBNode = uuidToLongName(toUUID(`createNode -n ($colliderNodeName + "_sweepRangeB") -ss "setRange"`));
    string $sweepAStartUcNode = uuidToLongName(toUUID(`createNode -n ($colliderNodeName + "_sweepAStartUc") -ss "unitConversion"`));
    string $sweepAEndUcNode = uuidToLongName(toUUID(`createNode -n ($colliderNodeName + "_sweepAEndUc") -ss "unitConversion"`));
    string $sweepBStartUcNode = uuidToLongName(toUUID(`createNode -n ($colliderNodeName + "_sweepBStartUc") -ss "unitConversion"`));
    string $sweepBEndUcNode = uuidToLongName(toUUID(`createNode -n ($colliderNodeName + "_sweepBEndUc") -ss "unitConversion"`));
    $colliderNodes[`size $colliderNodes`] = $halfLengthNode;
    $colliderNodes[`size $colliderNodes`] = $pivotNode;
    $colliderNodes[`size $colliderNodes`] = $offsetANode;
    $colliderNodes[`size $colliderNodes`] = $offsetBNode;
    $colliderNodes[`size $colliderNodes`] = $lengthDirNode;
    $colliderNodes[`size $colliderNodes`] = $sweepRangeANode;
    $colliderNodes[`size $colliderNodes`] = $sweepRangeBNode;
    $colliderNodes[`size $colliderNodes`] = $sweepAStartUcNode;
    $colliderNodes[`size $colliderNodes`] = $sweepAEndUcNode;
    $colliderNodes[`size $colliderNodes`] = $sweepBStartUcNode;
    $colliderNodes[`size $colliderNodes`] = $sweepBEndUcNode;

    $affectedNodes[`size $affectedNodes`] = $halfLengthNode;
    $affectedNodes[`size $affectedNodes`] = $pivotNode;
    $affectedNodes[`size $affectedNodes`] = $offsetANode;
    $affectedNodes[`size $affectedNodes`] = $offsetBNode;
    $affectedNodes[`size $affectedNodes`] = $lengthDirNode;
    $affectedNodes[`size $affectedNodes`] = $sweepRangeANode;
    $affectedNodes[`size $affectedNodes`] = $sweepRangeBNode;
    $affectedNodes[`size $affectedNodes`] = $sweepAStartUcNode;
    $affectedNodes[`size $affectedNodes`] = $sweepAEndUcNode;
    $affectedNodes[`size $affectedNodes`] = $sweepBStartUcNode;
    $affectedNodes[`size $affectedNodes`] = $sweepBEndUcNode;

    // 計算ノード設定
    float $sweepConversionFactor = `deg_to_rad 1.0`;
    setAttr ($halfLengthNode + ".operation") 2;
    setAttr ($halfLengthNode + ".floatB") -0.5;
    setAttributeLock($halfLengthNode, "floatB", true);
    setAttr ($pivotNode + ".operation") 2;
    setAttr ($offsetANode + ".operation") 0;
    setAttr ($offsetBNode + ".operation") 0;
    setAttr ($lengthDirNode + ".secondTerm") 0.0;
    setAttr ($lengthDirNode + ".operation") 4;
    setAttr ($lengthDirNode + ".colorIfTrueR") -1.0;
    setAttr ($lengthDirNode + ".colorIfFalseR") 1.0;
    setAttr ($sweepRangeANode + ".min") -90.0 90.0 0.0;
    setAttr ($sweepRangeANode + ".max") 90.0 270.0 0.0;
    setAttr ($sweepRangeANode + ".oldMin") -1.0 -1.0 0.0;
    setAttr ($sweepRangeANode + ".oldMax") 1.0 1.0 0.0;
    setAttr ($sweepRangeBNode + ".min") 90.0 270.0 0.0;
    setAttr ($sweepRangeBNode + ".max") -90.0 90.0 0.0;
    setAttr ($sweepRangeBNode + ".oldMin") -1.0 -1.0 0.0;
    setAttr ($sweepRangeBNode + ".oldMax") 1.0 1.0 0.0;
    setAttr ($sweepAStartUcNode + ".conversionFactor") $sweepConversionFactor;
    setAttr ($sweepAEndUcNode + ".conversionFactor") $sweepConversionFactor;
    setAttr ($sweepBStartUcNode + ".conversionFactor") $sweepConversionFactor;
    setAttr ($sweepBEndUcNode + ".conversionFactor") $sweepConversionFactor;

    // アトリビュート接続
    connectAttr -f ($transformNode        + ".worldInverseMatrix") ($loftTransformNode    + ".offsetParentMatrix");
    connectAttr -f ($sphereATransformNode + ".worldMatrix"       ) ($transformNode        + ".colliderMatrixA"   );
    connectAttr -f ($sphereBTransformNode + ".worldMatrix"       ) ($transformNode        + ".colliderMatrixB"   );
    connectAttr -f ($transformNode        + ".colliderRadiusA"   ) ($makeSphereANode      + ".radius"            );
    connectAttr -f ($transformNode        + ".colliderRadiusB"   ) ($makeSphereBNode      + ".radius"            );
    connectAttr -f ($transformNode        + ".colliderRadiusA"   ) ($makeCircleANode      + ".radius"            );
    connectAttr -f ($transformNode        + ".colliderRadiusB"   ) ($makeCircleBNode      + ".radius"            );
    connectAttr -f ($transformNode        + ".colliderLength"    ) ($halfLengthNode       + ".floatA"            );
    connectAttr -f ($halfLengthNode       + ".outFloat"          ) ($pivotNode            + ".floatA"            );
    connectAttr -f ($transformNode        + ".colliderPivot"     ) ($pivotNode            + ".floatB"            );
    connectAttr -f ($pivotNode            + ".outFloat"          ) ($offsetANode          + ".floatA"            );
    connectAttr -f ($transformNode        + ".colliderOffset"    ) ($offsetANode          + ".floatB"            );
    connectAttr -f ($offsetANode          + ".outFloat"          ) ($offsetBNode          + ".floatA"            );
    connectAttr -f ($transformNode        + ".colliderLength"    ) ($offsetBNode          + ".floatB"            );
    connectAttr -f ($offsetANode          + ".outFloat"          ) ($sphereATransformNode + ".tx"                );
    connectAttr -f ($offsetANode          + ".outFloat"          ) ($circleATransformNode + ".tx"                );
    connectAttr -f ($offsetBNode          + ".outFloat"          ) ($sphereBTransformNode + ".tx"                );
    connectAttr -f ($offsetBNode          + ".outFloat"          ) ($circleBTransformNode + ".tx"                );
    connectAttr -f ($transformNode        + ".colliderLength"    ) ($lengthDirNode        + ".firstTerm"         );
    connectAttr -f ($lengthDirNode        + ".outColorR"         ) ($makeCircleANode      + ".normalX"           );
    connectAttr -f ($lengthDirNode        + ".outColorR"         ) ($makeCircleBNode      + ".normalX"           );
    connectAttr -f ($lengthDirNode        + ".outColorR"         ) ($sweepRangeANode      + ".valueX"            );
    connectAttr -f ($lengthDirNode        + ".outColorR"         ) ($sweepRangeANode      + ".valueY"            );
    connectAttr -f ($lengthDirNode        + ".outColorR"         ) ($sweepRangeBNode      + ".valueX"            );
    connectAttr -f ($lengthDirNode        + ".outColorR"         ) ($sweepRangeBNode      + ".valueY"            );
    connectAttr -f ($sweepRangeANode      + ".outValueX"         ) ($sweepAStartUcNode    + ".input"             );
    connectAttr -f ($sweepAStartUcNode    + ".output"            ) ($makeSphereANode      + ".startSweep"        );
    connectAttr -f ($sweepRangeANode      + ".outValueY"         ) ($sweepAEndUcNode      + ".input"             );
    connectAttr -f ($sweepAEndUcNode      + ".output"            ) ($makeSphereANode      + ".endSweep"          );
    connectAttr -f ($sweepRangeBNode      + ".outValueX"         ) ($sweepBStartUcNode    + ".input"             );
    connectAttr -f ($sweepBStartUcNode    + ".output"            ) ($makeSphereBNode      + ".startSweep"        );
    connectAttr -f ($sweepRangeBNode      + ".outValueY"         ) ($sweepBEndUcNode      + ".input"             );
    connectAttr -f ($sweepBEndUcNode      + ".output"            ) ($makeSphereBNode      + ".endSweep"          );

    // アトリビュート状態設定
    string $txNodes[] = {
      $sphereATransformNode,
      $sphereBTransformNode,
      $circleATransformNode,
      $circleBTransformNode
    };
    batchSetAttributeLock($txNodes, {"ty", "tz", "rx", "ry", "rz", "sx", "sy", "sz", "v"}, true);
    batchSetAttributeChannelBox($txNodes, {"ty", "tz", "rx", "ry", "rz", "sx", "sy", "sz", "v"}, false);
    batchSetAttributeLock({$loftTransformNode}, {"tx", "ty", "tz", "rx", "ry", "rz", "sx", "sy", "sz", "v"}, true);
    batchSetAttributeChannelBox({$loftTransformNode}, {"tx", "ty", "tz", "rx", "ry", "rz", "sx", "sy", "sz", "v"}, false);
    disableRenderStats(getShapeNodes($sphereATransformNode, ""));
    disableRenderStats(getShapeNodes($sphereBTransformNode, ""));
    disableRenderStats(getShapeNodes($loftTransformNode, ""));

    // ノード接続
    appendMultiMessage($affectedNodes, $transformNode, "colliderAffectedBy");

    // コンストレイント設定
    if (`objExists $sourceNode`) {
      if (`objExists $nextSourceNode`) {
        string $ptcstNodes[] = `pointConstraint $sourceNode $spcNode`;
        if (`size $ptcstNodes`) {
          $ptcstNodes[0] = setNodeName($ptcstNodes[0], $spcNodeName + "_PTCST", false);
          $colliderNodes[`size $colliderNodes`] = $ptcstNodes[0];
          setStringAttribute($spcNode, "colliderSource", $sourceNode);
        }
        string $amcstNodes[] = `aimConstraint
            -aim 1.0 0.0 0.0
            -u 0.0 1.0 0.0
            -wuo $sourceNode
            -wut "objectrotation"
            -wu 0.0 1.0 0.0
            $nextSourceNode $spcNode`;
        if (`size $amcstNodes`) {
          $amcstNodes[0] = setNodeName($amcstNodes[0], $spcNodeName + "_AMCST", false);
          $colliderNodes[`size $colliderNodes`] = $amcstNodes[0];
          setStringAttribute($spcNode, "colliderAimTarget", $nextSourceNode);
        }
      }
      else {
        string $prcstNodes[] = `parentConstraint $sourceNode $spcNode`;
        if (`size $prcstNodes`) {
          $prcstNodes[0] = setNodeName($prcstNodes[0], $spcNodeName + "_PRCST", false);
          $colliderNodes[`size $colliderNodes`] = $prcstNodes[0];
          setStringAttribute($spcNode, "colliderSource", $sourceNode);
        }
      }
    }
    batchSetAttributeLock({$spcNode}, {"colliderSource", "colliderAimTarget"}, true);

    // アトリビュート値設定
    // print("nextSourceNode:" + $nextSourceNode + "\n"); // debug
    if (`objExists $nextSourceNode`) {
      float $t1[] = `xform -q -t -ws $sourceNode`;
      float $t2[] = `xform -q -t -ws $nextSourceNode`;
      vector $delta = <<$t2[0] - $t1[0], $t2[1] - $t1[1], $t2[2] - $t1[2]>>;
      float $colliderLength = `mag $delta`;
      setFloatAttribute($transformNode, "colliderLength", $colliderLength);
    }
  }

  if (`size $colliderNodes`) {
    notify("nkBdnEditorColliderCreated");
  }

  return $colliderNodes;
}

/*-
@param $sourceNodes <string[]>
@returns <string[]>
*/
proc string[] createInfinitePlaneCollider(string $sourceNodes[]) {
  // print("createInfinitePlaneCollider\n"); // debug
  // print("  sourceNodes:{\n    " + stringArrayToString($sourceNodes, ",\n    ") + "\n  }\n"); // debug

  string $colliderNodes[];
  string $colliderType = "infinitePlane";
  string $colliderName = "InfinitePlaneCollider";

  string $colliderGrpNode = initGroupNode(getSecondLevelNode("BDN_GRP", "Collider_GRP", true, true), "collider");
  initGroupNode(getTopLevelNode("BDN_GRP", false, true), "bdn");
  // print("  colliderGrpNode:" + $colliderGrpNode + "\n"); // debug
  if (!`objExists $colliderGrpNode`) return $colliderNodes;

  if (!`size $sourceNodes`) $sourceNodes = {""};
  int $numSourceNodes = `size $sourceNodes`;
  for ($i = 0; $i < $numSourceNodes; $i++) {
    string $affectedNodes[];
    string $sourceNode = $sourceNodes[$i];
    string $sourceShortName = toShortName($sourceNode);
    string $spcNodeName = join({$sourceShortName, $colliderName, "SPC"}, "_", true);
    string $colliderNodeName = join({$sourceShortName, $colliderName}, "_", true);

    // ノード作成
    string $spcNode = initSpaceNode(createTransform($spcNodeName, $colliderGrpNode, true, $sourceNode, {}), "collider");
    string $planeNodes[] = `nurbsPlane -ax 0.0 1.0 0.0 -d 3 -lr 1.0 -u 1.0 -v 1.0 -w 1.0`;
    string $transformNode = buildDagNode(longNameOf($planeNodes[0]), $colliderNodeName, $spcNode, true, $spcNode, {});
    string $makeNode = longNameOf($planeNodes[1]);
    string $shapeNodes[] = getShapeNodes($transformNode, "");
    $colliderNodes[`size $colliderNodes`] = $spcNode;
    $colliderNodes[`size $colliderNodes`] = $transformNode;
    $colliderNodes[`size $colliderNodes`] = $makeNode;
    $colliderNodes = stringArrayCatenate($colliderNodes, $shapeNodes);

    $affectedNodes[`size $affectedNodes`] = $makeNode;
    $affectedNodes = stringArrayCatenate($affectedNodes, $shapeNodes);

    // ノード初期化
    initColliderNode($transformNode, $colliderType);
    setOutlinerColor({$spcNode}, {1.0, 1.0, 0.0});
    setOverrideColor($shapeNodes, 17);

    // アトリビュート設定
    addAttr -at "message" -ln "colliderAffectedBy" -m $transformNode;
    addAttr -dt "string" -ln "colliderSource" $spcNode;
    addAttr -at "double" -dv 1.0 -k true -hxv false -hnv true -min 0.001 -ln "colliderWidth" $transformNode;
    addAttr -at "double" -dv 1.0 -k true -hxv false -hnv true -min 0.001 -ln "colliderHeight" $transformNode;

    // アトリビュートエイリアス設定
    string $colliderAttributes[] = {
      "colliderWidth",
      "colliderHeight"
    };
    addProxyAttributes($transformNode, $colliderAttributes, $spcNode);

    // 計算ノード作成
    string $ratioNode = uuidToLongName(toUUID(`createNode -n ($colliderNodeName + "_ratio") -ss "floatMath"`));
    $colliderNodes[`size $colliderNodes`] = $ratioNode;

    $affectedNodes[`size $affectedNodes`] = $ratioNode;

    // 計算ノード設定
    setAttr ($ratioNode + ".operation") 3;

    // アトリビュート接続
    connectAttr -f ($transformNode + ".colliderWidth" ) ($makeNode  + ".width"      );
    connectAttr -f ($transformNode + ".colliderHeight") ($ratioNode + ".floatA"     );
    connectAttr -f ($transformNode + ".colliderWidth" ) ($ratioNode + ".floatB"     );
    connectAttr -f ($ratioNode     + ".outFloat"      ) ($makeNode  + ".lengthRatio");

    // ノード接続
    appendMultiMessage($affectedNodes, $transformNode, "colliderAffectedBy");

    // コンストレイント設定
    if (`objExists $sourceNode`) {
      string $prcstNodes[] = `parentConstraint $sourceNode $spcNode`;
      if (`size $prcstNodes`) {
        $prcstNodes[0] = setNodeName($prcstNodes[0], $spcNodeName + "_PRCST", false);
        $colliderNodes[`size $colliderNodes`] = $prcstNodes[0];
        setStringAttribute($spcNode, "colliderSource", $sourceNode);
      }
    }
    setAttributeLock($spcNode, "colliderSource", true);
  }

  if (`size $colliderNodes`) {
    notify("nkBdnEditorColliderCreated");
  }

  return $colliderNodes;
}

/*-
@param $sourceNodes <string[]>
@returns <string[]>
*/
proc string[] createSphereCollider(string $sourceNodes[]) {
  // print("createSphereCollider\n"); // debug
  // print("  sourceNodes:{\n    " + stringArrayToString($sourceNodes, ",\n    ") + "\n  }\n"); // debug

  string $colliderNodes[];
  string $colliderType = "sphere";
  string $colliderName = "SphereCollider";

  string $colliderGrpNode = initGroupNode(getSecondLevelNode("BDN_GRP", "Collider_GRP", true, true), "collider");
  initGroupNode(getTopLevelNode("BDN_GRP", false, true), "bdn");
  // print("  colliderGrpNode:" + $colliderGrpNode + "\n"); // debug
  if (!`objExists $colliderGrpNode`) return $colliderNodes;

  if (!`size $sourceNodes`) $sourceNodes = {""};
  int $numSourceNodes = `size $sourceNodes`;
  for ($i = 0; $i < $numSourceNodes; $i++) {
    string $affectedNodes[];
    string $sourceNode = $sourceNodes[$i];
    string $sourceShortName = toShortName($sourceNode);
    string $spcNodeName = join({$sourceShortName, $colliderName, "SPC"}, "_", true);
    string $colliderNodeName = join({$sourceShortName, $colliderName}, "_", true);

    // ノード作成
    string $spcNode = initSpaceNode(createTransform($spcNodeName, $colliderGrpNode, true, $sourceNode, {}), "collider");
    string $sphereNodes[] = `sphere -ax 0.0 1.0 0.0 -d 3 -hr 2.0 -r 0.5 -s 8 -nsp 4`;
    string $transformNode = buildDagNode(longNameOf($sphereNodes[0]), $colliderNodeName, $spcNode, true, $spcNode, {});
    string $makeNode = longNameOf($sphereNodes[1]);
    string $shapeNodes[] = getShapeNodes($transformNode, "");
    $colliderNodes[`size $colliderNodes`] = $spcNode;
    $colliderNodes[`size $colliderNodes`] = $transformNode;
    $colliderNodes[`size $colliderNodes`] = $makeNode;
    $colliderNodes = stringArrayCatenate($colliderNodes, $shapeNodes);

    $affectedNodes[`size $affectedNodes`] = $makeNode;
    $affectedNodes = stringArrayCatenate($affectedNodes, $shapeNodes);

    // ノード初期化
    initColliderNode($transformNode, $colliderType);
    setOutlinerColor({$spcNode}, {1.0, 1.0, 0.0});
    setOverrideColor($shapeNodes, 17);

    // アトリビュート設定
    addAttr -at "message" -ln "colliderAffectedBy" -m $transformNode;
    addAttr -dt "string" -ln "colliderSource" $spcNode;
    addAttr -at "double" -dv 0.5 -k true -hxv false -hnv true -min 0.001 -ln "colliderRadius" $transformNode;

    // アトリビュートエイリアス設定
    string $colliderAttributes[] = {
      "colliderRadius"
    };
    addProxyAttributes($transformNode, $colliderAttributes, $spcNode);

    // アトリビュート接続
    connectAttr -f ($transformNode + ".colliderRadius") ($makeNode  + ".radius");

    // ノード接続
    appendMultiMessage($affectedNodes, $transformNode, "colliderAffectedBy");

    // コンストレイント設定
    if (`objExists $sourceNode`) {
      string $prcstNodes[] = `parentConstraint $sourceNode $spcNode`;
      if (`size $prcstNodes`) {
        $prcstNodes[0] = setNodeName($prcstNodes[0], $spcNodeName + "_PRCST", false);
        $colliderNodes[`size $colliderNodes`] = $prcstNodes[0];
        setStringAttribute($spcNode, "colliderSource", $sourceNode);
      }
    }
    setAttributeLock($spcNode, "colliderSource", true);
  }

  if (`size $colliderNodes`) {
    notify("nkBdnEditorColliderCreated");
  }

  return $colliderNodes;
}

/*-
@param $bdnNode <string>
@param $index <int>
@param $colliderNode <string>
@returns <>
*/
proc connectCollider(string $bdnNode, int $index, string $colliderNode) {
  // print("connectCollider\n"); // debug
  // print("  bdnNode     :" + $bdnNode + "\n"); // debug
  // print("  index       :" + $index + "\n"); // debug
  // print("  colliderNode:" + $colliderNode + "\n"); // debug
  if (!isBdnPluginLoaded()) return;
  if (
    !isType($bdnNode, {"boneDynamicsNode"}, true)
        || $index < 0
        || !isBdnType($colliderNode, "collider")
  ) return;

  string $colliderType = getColliderType($colliderNode);
  if ($colliderType == "capsule") {
    connectAttr -f
        ($colliderNode + ".colliderMatrixA")
        ($bdnNode + ".capsuleCollider[" + $index + "].capsuleColMatrixA");
    connectAttr -f
        ($colliderNode + ".colliderMatrixB")
        ($bdnNode + ".capsuleCollider[" + $index + "].capsuleColMatrixB");
    connectAttr -f
        ($colliderNode + ".colliderRadiusA")
        ($bdnNode + ".capsuleCollider[" + $index + "].capsuleColRadiusA");
    connectAttr -f
        ($colliderNode + ".colliderRadiusB")
        ($bdnNode + ".capsuleCollider[" + $index + "].capsuleColRadiusB");
  }
  else if ($colliderType == "infinitePlane") {
    connectAttr -f
        ($colliderNode + ".worldMatrix")
        ($bdnNode + ".infinitePlaneCollider[" + $index + "].infinitePlaneColMatrix");
  }
  else if ($colliderType == "sphere") {
    connectAttr -f
        ($colliderNode + ".worldMatrix")
        ($bdnNode + ".sphereCollider[" + $index + "].sphereColMatrix");
    connectAttr -f
        ($colliderNode + ".colliderRadius")
        ($bdnNode + ".sphereCollider[" + $index + "].sphereColRadius");
  }
}

/*-
@param $colliderNodes <string[]>
@param $bdnNodes <string[]>
@returns <string[]>
*/
proc appendCollider(string $colliderNodes[], string $bdnNodes[]) {
  // print("appendCollider\n"); // debug
  // print("  colliderNodes:{\n    " + stringArrayToString($colliderNodes, ",\n    ") + "\n  }\n"); // debug
  // print("  bdnNodes     :{\n    " + stringArrayToString($bdnNodes, ",\n    ") + "\n  }\n"); // debug
  if (!isBdnPluginLoaded()) return;

  // 種類ごとにコライダーを分ける
  string $ccNodes[];
  string $pcNodes[];
  string $scNodes[];
  for ($colliderNode in $colliderNodes) {
    if (!isBdnType($colliderNode, "collider")) continue;

    string $colliderType = getColliderType($colliderNode);
    if ($colliderType == "capsule") {
      $ccNodes[`size $ccNodes`] = $colliderNode;
    }
    else if ($colliderType == "infinitePlane") {
      $pcNodes[`size $pcNodes`] = $colliderNode;
    }
    else if ($colliderType == "sphere") {
      $scNodes[`size $scNodes`] = $colliderNode;
    }
  }

  int $numCcNodes = `size $ccNodes`;
  int $numPcNodes = `size $pcNodes`;
  int $numScNodes = `size $scNodes`;
  if ($numCcNodes == 0 && $numPcNodes == 0 && $numScNodes == 0) return;

  for ($bdnNode in $bdnNodes) {
    if (!isType($bdnNode, {"boneDynamicsNode"}, true)) continue;

    /*
    コライダー配列の最適化
    接続を切っても値が残ると衝突判定されてしまうため、一旦すべての配列アトリビュートの要素を削除する。
    その後既存のコライダーと追加するコライダーとを接続し直す。
    */

    // capsuleCollider
    if ($numCcNodes) {
      int $size = `getAttr -s ($bdnNode + ".capsuleCollider")`;
      string $newCcNodes[];
      for ($i = 0; $i < $size; $i++) {
        $newCcNodes = stringArrayCatenate(
          $newCcNodes,
          getSourceConnections(
            $bdnNode,
            {
              "capsuleCollider[" + $i + "].capsuleColMatrixA",
              "capsuleCollider[" + $i + "].capsuleColMatrixB",
              "capsuleCollider[" + $i + "].capsuleColRadiusA",
              "capsuleCollider[" + $i + "].capsuleColRadiusB"
            },
            "", {}, {}
          )
        );
        removeMultiInstance -b true ($bdnNode + ".capsuleCollider[" + $i + "]");
      }
      $newCcNodes = stringArrayCatenate($newCcNodes, $ccNodes);
      $newCcNodes = stringArrayRemoveDuplicates($newCcNodes);

      for ($i = 0; $i < `size $newCcNodes`; $i++) {
        connectCollider($bdnNode, $i, $newCcNodes[$i]);
      }
    }

    // infinitePlaneCollider
    if ($numPcNodes) {
      int $size = `getAttr -s ($bdnNode + ".infinitePlaneCollider")`;
      string $newPcNodes[];
      for ($i = 0; $i < $size; $i++) {
        $newPcNodes = stringArrayCatenate(
          $newPcNodes,
          getSourceConnections(
            $bdnNode,
            {"infinitePlaneCollider[" + $i + "].infinitePlaneColMatrix"},
            "", {}, {}
          )
        );
        removeMultiInstance -b true ($bdnNode + ".infinitePlaneCollider[" + $i + "]");
      }
      $newPcNodes = stringArrayCatenate($newPcNodes, $pcNodes);
      $newPcNodes = stringArrayRemoveDuplicates($newPcNodes);

      for ($i = 0; $i < `size $newPcNodes`; $i++) {
        connectCollider($bdnNode, $i, $newPcNodes[$i]);
      }
    }

    // sphereCollider
    if ($numScNodes) {
      int $size = `getAttr -s ($bdnNode + ".sphereCollider")`;
      string $newScNodes[];
      for ($i = 0; $i < $size; $i++) {
        $newScNodes = stringArrayCatenate(
          $newScNodes,
          getSourceConnections(
            $bdnNode,
            {
              "sphereCollider[" + $i + "].sphereColMatrix",
              "sphereCollider[" + $i + "].sphereColRadius"
            },
            "", {}, {}
          )
        );
        removeMultiInstance -b true ($bdnNode + ".sphereCollider[" + $i + "]");
      }
      $newScNodes = stringArrayCatenate($newScNodes, $scNodes);
      $newScNodes = stringArrayRemoveDuplicates($newScNodes);

      for ($i = 0; $i < `size $newScNodes`; $i++) {
        connectCollider($bdnNode, $i, $newScNodes[$i]);
      }
    }
  }
  notify("nkBdnEditorBdnColliderConnectionChanged");
}

/*-
@param $colliderNodes <string[]>
@param $bdnNodes <string[]>
@returns <string[]>
*/
proc removeCollider(string $colliderNodes[], string $bdnNodes[]) {
  // print("removeCollider\n"); // debug
  // print("  colliderNodes:{\n    " + stringArrayToString($colliderNodes, ",\n    ") + "\n  }\n"); // debug
  // print("  bdnNodes     :{\n    " + stringArrayToString($bdnNodes, ",\n    ") + "\n  }\n"); // debug
  if (!isBdnPluginLoaded()) return;

  // 種類ごとにコライダーを分ける
  string $ccNodes[];
  string $pcNodes[];
  string $scNodes[];
  for ($colliderNode in $colliderNodes) {
    if (!isBdnType($colliderNode, "collider")) continue;

    string $colliderType = getColliderType($colliderNode);
    if ($colliderType == "capsule") {
      $ccNodes[`size $ccNodes`] = $colliderNode;
    }
    else if ($colliderType == "infinitePlane") {
      $pcNodes[`size $pcNodes`] = $colliderNode;
    }
    else if ($colliderType == "sphere") {
      $scNodes[`size $scNodes`] = $colliderNode;
    }
  }

  int $numCcNodes = `size $ccNodes`;
  int $numPcNodes = `size $pcNodes`;
  int $numScNodes = `size $scNodes`;
  if ($numCcNodes == 0 && $numPcNodes == 0 && $numScNodes == 0) return;

  for ($bdnNode in $bdnNodes) {
    if (!isType($bdnNode, {"boneDynamicsNode"}, true)) continue;

    // capsuleCollider
    if ($numCcNodes) {
      int $size = `getAttr -s ($bdnNode + ".capsuleCollider")`;
      string $newCcNodes[];
      for ($i = 0; $i < $size; $i++) {
        $newCcNodes = stringArrayCatenate(
          $newCcNodes,
          getSourceConnections(
            $bdnNode,
            {
              "capsuleCollider[" + $i + "].capsuleColMatrixA",
              "capsuleCollider[" + $i + "].capsuleColMatrixB",
              "capsuleCollider[" + $i + "].capsuleColRadiusA",
              "capsuleCollider[" + $i + "].capsuleColRadiusB"
            },
            "", {}, {}
          )
        );
        removeMultiInstance -b true ($bdnNode + ".capsuleCollider[" + $i + "]");
      }
      $newCcNodes = `stringArrayRemove $ccNodes $newCcNodes`;
      $newCcNodes = stringArrayRemoveDuplicates($newCcNodes);

      for ($i = 0; $i < `size $newCcNodes`; $i++) {
        connectCollider($bdnNode, $i, $newCcNodes[$i]);
      }
    }

    // infinitePlaneCollider
    if ($numPcNodes) {
      int $size = `getAttr -s ($bdnNode + ".infinitePlaneCollider")`;
      string $newPcNodes[];
      for ($i = 0; $i < $size; $i++) {
        $newPcNodes = stringArrayCatenate(
          $newPcNodes,
          getSourceConnections(
            $bdnNode,
            {"infinitePlaneCollider[" + $i + "].infinitePlaneColMatrix"},
            "", {}, {}
          )
        );
        removeMultiInstance -b true ($bdnNode + ".infinitePlaneCollider[" + $i + "]");
      }
      $newPcNodes = `stringArrayRemove $pcNodes $newPcNodes`;
      $newPcNodes = stringArrayRemoveDuplicates($newPcNodes);

      for ($i = 0; $i < `size $newPcNodes`; $i++) {
        connectCollider($bdnNode, $i, $newPcNodes[$i]);
      }
    }

    // sphereCollider
    if ($numScNodes) {
      int $size = `getAttr -s ($bdnNode + ".sphereCollider")`;
      string $newScNodes[];
      for ($i = 0; $i < $size; $i++) {
        $newScNodes = stringArrayCatenate(
          $newScNodes,
          getSourceConnections(
            $bdnNode,
            {
              "sphereCollider[" + $i + "].sphereColMatrix",
              "sphereCollider[" + $i + "].sphereColRadius"
            },
            "", {}, {}
          )
        );
        removeMultiInstance -b true ($bdnNode + ".sphereCollider[" + $i + "]");
      }
      $newScNodes = `stringArrayRemove $scNodes $newScNodes`;
      $newScNodes = stringArrayRemoveDuplicates($newScNodes);

      for ($i = 0; $i < `size $newScNodes`; $i++) {
        connectCollider($bdnNode, $i, $newScNodes[$i]);
      }
    }
  }
  notify("nkBdnEditorBdnColliderConnectionChanged");
}

// -----------------------------------------------------------------------------
// コライダーアトリビュート
// -----------------------------------------------------------------------------
/*-
@param $colliderNode <string>
@returns <string>
*/
proc string capsuleColliderAttributesToDict(string $colliderNode) {
  // print("capsuleColliderAttributesToDict\n"); // debug
  // print("  colliderNode:" + $colliderNode + "\n"); // debug
  string $dict;
  if (!isBdnType($colliderNode, "collider")) return $dict;

  string $colliderType = getColliderType($colliderNode);
  if ($colliderType != "capsule") return $dict;

  $dict = dictAddString($dict, "name", toShortName($colliderNode));
  $dict = dictAddString($dict, "colliderType", $colliderType);
  $dict = dictAddFloat($dict, "colliderRadiusA", getFloatAttribute($colliderNode, "colliderRadiusA", 0.5));
  $dict = dictAddFloat($dict, "colliderRadiusB", getFloatAttribute($colliderNode, "colliderRadiusB", 0.5));
  $dict = dictAddFloat($dict, "colliderLength", getFloatAttribute($colliderNode, "colliderLength", 2.0));
  $dict = dictAddFloat($dict, "colliderOffset", getFloatAttribute($colliderNode, "colliderOffset", 0.0));
  $dict = dictAddInt($dict, "colliderPivot", getIntAttribute($colliderNode, "colliderPivot", 0));
  return $dict;
}

/*-
@param $colliderNode <string>
@returns <string>
*/
proc string infinitePlaneColliderAttributesToDict(string $colliderNode) {
  // print("infinitePlaneColliderAttributesToDict\n"); // debug
  // print("  colliderNode:" + $colliderNode + "\n"); // debug
  string $dict;
  if (!isBdnType($colliderNode, "collider")) return $dict;

  string $colliderType = getColliderType($colliderNode);
  if ($colliderType != "infinitePlane") return $dict;

  $dict = dictAddString($dict, "name", toShortName($colliderNode));
  $dict = dictAddString($dict, "colliderType", $colliderType);
  $dict = dictAddFloat($dict, "colliderWidth", getFloatAttribute($colliderNode, "colliderWidth", 1.0));
  $dict = dictAddFloat($dict, "colliderHeight", getFloatAttribute($colliderNode, "colliderHeight", 1.0));
  return $dict;
}

/*-
@param $colliderNode <string>
@returns <string>
*/
proc string sphereColliderAttributesToDict(string $colliderNode) {
  // print("sphereColliderAttributesToDict\n"); // debug
  // print("  colliderNode:" + $colliderNode + "\n"); // debug
  string $dict;
  if (!isBdnType($colliderNode, "collider")) return $dict;

  string $colliderType = getColliderType($colliderNode);
  if ($colliderType != "sphere") return $dict;

  $dict = dictAddString($dict, "name", toShortName($colliderNode));
  $dict = dictAddString($dict, "colliderType", $colliderType);
  $dict = dictAddFloat($dict, "colliderRadius", getFloatAttribute($colliderNode, "colliderRadius", 0.5));
  return $dict;
}

/*-
@param $dict <string>
@param $colliderNodes <string[]>
@param $shouldSetPlacementAttributes <boolean>
@returns <>
*/
proc applyDictToCapsuleColliderAttributes(
  string $dict,
  string $colliderNodes[],
  int $shouldSetPlacementAttributes
) {
  // print("applyDictToCapsuleColliderAttributes\n"); // debug
  // print("  dict                        :" + $dict + "\n"); // debug
  // print("  colliderNodes               :{\n    " + stringArrayToString($colliderNodes, ",\n    ") + "\n  }\n"); // debug
  // print("  shouldSetPlacementAttributes:" + $shouldSetPlacementAttributes + "\n"); // debug
  if (!`size $dict` || !`size $colliderNodes`) return;

  string $dictType = dictGetString($dict, "colliderType", "");
  // print("  dictType:" + $dictType + "\n"); // debug
  if ($dictType != "capsule") return;

  float $colliderRadiusA = dictGetFloat($dict, "colliderRadiusA", 0.5);
  float $colliderRadiusB = dictGetFloat($dict, "colliderRadiusB", 0.5);
  float $colliderLength = dictGetFloat($dict, "colliderLength", 2.0);
  float $colliderOffset = dictGetFloat($dict, "colliderOffset", 0.0);
  int $colliderPivot = dictGetInt($dict, "colliderPivot", 0);

  int $shouldNotify = false;
  for ($colliderNode in $colliderNodes) {
    if (!isColliderType($colliderNode, $dictType)) continue;

    setFloatAttribute($colliderNode, "colliderRadiusA", $colliderRadiusA);
    setFloatAttribute($colliderNode, "colliderRadiusB", $colliderRadiusB);
    if ($shouldSetPlacementAttributes) {
      setFloatAttribute($colliderNode, "colliderLength", $colliderLength);
      setFloatAttribute($colliderNode, "colliderOffset", $colliderOffset);
      setIntAttribute($colliderNode, "colliderPivot", $colliderPivot);
    }
    if (!$shouldNotify) $shouldNotify = true;
  }

  if ($shouldNotify) {
    notify("nkBdnEditorColliderAttributeChanged");
  }
}

/*-
@param $dict <string>
@param $colliderNodes <string[]>
@returns <>
*/
proc applyDictToInfinitePlaneColliderAttributes(string $dict, string $colliderNodes[]) {
  // print("applyDictToInfinitePlaneColliderAttributes\n"); // debug
  // print("  dict         :" + $dict + "\n"); // debug
  // print("  colliderNodes:{\n    " + stringArrayToString($colliderNodes, ",\n    ") + "\n  }\n"); // debug
  if (!`size $dict` || !`size $colliderNodes`) return;

  string $dictType = dictGetString($dict, "colliderType", "");
  // print("  dictType:" + $dictType + "\n"); // debug
  if ($dictType != "infinitePlane") return;

  float $colliderWidth = dictGetFloat($dict, "colliderWidth", 1.0);
  float $colliderHeight = dictGetFloat($dict, "colliderHeight", 1.0);

  int $shouldNotify = false;
  for ($colliderNode in $colliderNodes) {
    if (!isColliderType($colliderNode, $dictType)) continue;

    setFloatAttribute($colliderNode, "colliderWidth", $colliderWidth);
    setFloatAttribute($colliderNode, "colliderHeight", $colliderHeight);
    if (!$shouldNotify) $shouldNotify = true;
  }

  if ($shouldNotify) {
    notify("nkBdnEditorColliderAttributeChanged");
  }
}

/*-
@param $dict <string>
@param $colliderNodes <string[]>
@param $shouldSetPlacementAttributes <boolean>
@returns <>
*/
proc applyDictToSphereColliderAttributes(string $dict, string $colliderNodes[]) {
  // print("applyDictToSphereColliderAttributes\n"); // debug
  // print("  dict         :" + $dict + "\n"); // debug
  // print("  colliderNodes:{\n    " + stringArrayToString($colliderNodes, ",\n    ") + "\n  }\n"); // debug
  if (!`size $dict` || !`size $colliderNodes`) return;

  string $dictType = dictGetString($dict, "colliderType", "");
  // print("  dictType:" + $dictType + "\n"); // debug
  if ($dictType != "sphere") return;

  float $colliderRadius = dictGetFloat($dict, "colliderRadius", 0.5);

  int $shouldNotify = false;
  for ($colliderNode in $colliderNodes) {
    if (!isColliderType($colliderNode, $dictType)) continue;

    setFloatAttribute($colliderNode, "colliderRadius", $colliderRadius);
    if (!$shouldNotify) $shouldNotify = true;
  }

  if ($shouldNotify) {
    notify("nkBdnEditorColliderAttributeChanged");
  }
}

/*-
@param $colliderNodes <string[]>
@param $attribute <string>
@param $value <float>
@returns <>
*/
proc setFloatColliderAttribute(string $colliderNodes[], string $attribute, float $value) {
  // print("setFloatColliderAttribute\n"); // debug
  // print("  colliderNodes:{\n    " + stringArrayToString($colliderNodes, ",\n    ") + "\n  }\n"); // debug
  // print("  attribute    :" + $attribute + "\n"); // debug
  // print("  value        :" + $value + "\n"); // debug
  if (!`size $colliderNodes`) return;

  batchSetFloatAttribute($colliderNodes, $attribute, $value);
  notify("nkBdnEditorColliderAttributeChanged");
}

/*-
@param $colliderNodes <string[]>
@param $attribute <string>
@param $value <int>
@returns <>
*/
proc setIntColliderAttribute(string $colliderNodes[], string $attribute, int $value) {
  // print("setIntColliderAttribute\n"); // debug
  // print("  colliderNodes:{\n    " + stringArrayToString($colliderNodes, ",\n    ") + "\n  }\n"); // debug
  // print("  attribute    :" + $attribute + "\n"); // debug
  // print("  value        :" + $value + "\n"); // debug
  if (!`size $colliderNodes`) return;

  batchSetIntAttribute($colliderNodes, $attribute, $value);
  notify("nkBdnEditorColliderAttributeChanged");
}

// -----------------------------------------------------------------------------
/*-
@param $colliderNodes <string[]>
@param $filename <string> ファイル選択ダイアログを使用するには空文字列を渡す。
@returns <>
*/
proc exportColliders(string $colliderNodes[], string $filename) {
  // print("exportColliders\n"); // debug
  // print("  colliderNodes:{\n    " + stringArrayToString($colliderNodes, ",\n    ") + "\n  }\n"); // debug
  // print("  filename     :" + $filename + "\n"); // debug
  if (!`size $colliderNodes`) return;

  if (!`size $filename`) {
    $filename = getSaveFilename("Export Colliders - nkBdnEditor", "*.collider");
  }
  // print("  filename:" + $filename + "\n"); // debug
  if (!`size $filename`) return;

  string $dicts[];
  for ($colliderNode in $colliderNodes) {
    if (!isBdnType($colliderNode, "collider")) continue;

    string $spcNode = getParentNode($colliderNode);
    if (!isSpaceType($spcNode, "collider")) continue;

    string $dict;
    string $colliderType = getColliderType($colliderNode);
    if ($colliderType == "capsule") {
      $dict = capsuleColliderAttributesToDict($colliderNode);
      $dict = dictAddString($dict, "colliderSource", getStringAttribute($spcNode, "colliderSource", ""));
      $dict = dictAddString($dict, "colliderAimTarget", getStringAttribute($spcNode, "colliderAimTarget", ""));
    }
    else if ($colliderType == "infinitePlane") {
      $dict = infinitePlaneColliderAttributesToDict($colliderNode);
      $dict = dictAddString($dict, "colliderSource", getStringAttribute($spcNode, "colliderSource", ""));
    }
    else if ($colliderType == "sphere") {
      $dict = sphereColliderAttributesToDict($colliderNode);
      $dict = dictAddString($dict, "colliderSource", getStringAttribute($spcNode, "colliderSource", ""));
    }

    $dict = dictAddFloatArray($dict, "spaceTranslate", getFloat3Attribute($spcNode, "translate", {0.0, 0.0, 0.0}));
    $dict = dictAddFloatArray($dict, "spaceRotate", getFloat3Attribute($spcNode, "rotate", {0.0, 0.0, 0.0}));
    $dict = dictAddFloatArray($dict, "spaceScale", getFloat3Attribute($spcNode, "scale", {1.0, 1.0, 1.0}));
    $dict = dictAddFloatArray($dict, "colliderTranslate", getFloat3Attribute($colliderNode, "translate", {0.0, 0.0, 0.0}));
    $dict = dictAddFloatArray($dict, "colliderRotate", getFloat3Attribute($colliderNode, "rotate", {0.0, 0.0, 0.0}));
    $dict = dictAddFloatArray($dict, "colliderScale", getFloat3Attribute($colliderNode, "scale", {1.0, 1.0, 1.0}));
    $dicts[`size $dicts`] = $dict;
  }
  if (!`size $dicts`) return;

  // print("  dicts:{\n    " + stringArrayToString($dicts, ",\n    ") + "\n  }\n"); // debug
  if (writeAllLines($filename, "", $dicts)) {
    print("// nkBdnEditor: write file:" + $filename + "\n");
  }
}

/*-
@param $filename <string> ファイル選択ダイアログを使用するには空文字列を渡す。
@returns <>
*/
proc importColliders(string $filename) {
  // print("importColliders\n"); // debug
  // print("  filename:" + $filename + "\n"); // debug
  if (!`size $filename`) {
    $filename = getOpenFilename("Import Colliders - nkBdnEditor", "*.collider");
  }
  // print("  filename:" + $filename + "\n"); // debug
  if (!existsFilename($filename)) return;

  string $dicts[] = readAllLines($filename, "");
  // print("  dicts:{\n    " + stringArrayToString($dicts, ",\n    ") + "\n  }\n"); // debug
  if (!`size $dicts`) return;

  for ($dict in $dicts) {
    string $dictType = dictGetString($dict, "colliderType", "");
    // print("  dictType:" + $dictType + "\n"); // debug

    string $sourceNodes[];
    string $colliderSource = dictGetString($dict, "colliderSource", "");
    int $existsColliderSource = `objExists $colliderSource`;
    if ($existsColliderSource) $sourceNodes[`size $sourceNodes`] = $colliderSource;

    string $colliderNodes[];
    if ($dictType == "capsule") {
      int $existsColliderAimTarget = false;
      if ($existsColliderSource) {
        string $colliderAimTarget = dictGetString($dict, "colliderAimTarget", "");
        $existsColliderAimTarget = `objExists $colliderAimTarget`;
        if ($existsColliderAimTarget) $sourceNodes[`size $sourceNodes`] = $colliderAimTarget;
      }
      $colliderNodes = createCapsuleCollider($sourceNodes, !$existsColliderAimTarget);
    }
    else if ($dictType == "infinitePlane") {
      $colliderNodes = createInfinitePlaneCollider($sourceNodes);
    }
    else if ($dictType == "sphere") {
      $colliderNodes = createSphereCollider($sourceNodes);
    }
    // print("  colliderNodes:{\n    " + stringArrayToString($colliderNodes, ",\n    ") + "\n  }\n"); // debug

    float $spaceTranslate[] = dictGetFloatArray($dict, "spaceTranslate", {0.0, 0.0, 0.0});
    float $spaceRotate[] = dictGetFloatArray($dict, "spaceRotate", {0.0, 0.0, 0.0});
    float $spaceScale[] = dictGetFloatArray($dict, "spaceScale", {1.0, 1.0, 1.0});
    float $colliderTranslate[] = dictGetFloatArray($dict, "colliderTranslate", {0.0, 0.0, 0.0});
    float $colliderRotate[] = dictGetFloatArray($dict, "colliderRotate", {0.0, 0.0, 0.0});
    float $colliderScale[] = dictGetFloatArray($dict, "colliderScale", {1.0, 1.0, 1.0});

    for ($colliderNode in $colliderNodes) {
      if (isBdnType($colliderNode, "space")) {
        setFloat3Attribute($colliderNode, "translate", $spaceTranslate);
        setFloat3Attribute($colliderNode, "rotate", $spaceRotate);
        setFloat3Attribute($colliderNode, "scale", $spaceScale);
      }
      else if (isBdnType($colliderNode, "collider")) {
        setFloat3Attribute($colliderNode, "translate", $colliderTranslate);
        setFloat3Attribute($colliderNode, "rotate", $colliderRotate);
        setFloat3Attribute($colliderNode, "scale", $colliderScale);

        string $colliderType = getColliderType($colliderNode);
        if ($colliderType == "capsule") {
          applyDictToCapsuleColliderAttributes($dict, {$colliderNode}, true);
        }
        else if ($colliderType == "infinitePlane") {
          applyDictToInfinitePlaneColliderAttributes($dict, {$colliderNode});
        }
        else if ($colliderType == "sphere") {
          applyDictToSphereColliderAttributes($dict, {$colliderNode});
        }
      }
    }
  }
}

/*-
@param $colliderNodes <string[]>
@returns <>
*/
proc copyCapsuleColliderAttributes(string $colliderNodes[]) {
  // print("copyCapsuleColliderAttributes\n"); // debug
  // print("  colliderNodes:{\n    " + stringArrayToString($colliderNodes, ",\n    ") + "\n  }\n"); // debug
  global string $nkBdnEditorCapsuleColliderAttributeCache;
  int $numColliderNodes = `size $colliderNodes`;
  if ($numColliderNodes == 0) return;

  string $lastNode = $colliderNodes[$numColliderNodes - 1];
  $nkBdnEditorCapsuleColliderAttributeCache = capsuleColliderAttributesToDict($lastNode);
  print("// nkBdnEditor: nkBdnEditorCapsuleColliderAttributeCache:" + $nkBdnEditorCapsuleColliderAttributeCache + "\n");
}

/*-
@param $colliderNodes <string[]>
@param $shouldSetPlacementAttributes <boolean>
@returns <>
*/
proc pasteCapsuleColliderAttributes(string $colliderNodes[], int $shouldSetPlacementAttributes) {
  // print("pasteCapsuleColliderAttributes\n"); // debug
  // print("  colliderNodes               :{\n    " + stringArrayToString($colliderNodes, ",\n    ") + "\n  }\n"); // debug
  // print("  shouldSetPlacementAttributes:" + $shouldSetPlacementAttributes + "\n"); // debug
  global string $nkBdnEditorCapsuleColliderAttributeCache;
  if (!`size $colliderNodes`) return;

  applyDictToCapsuleColliderAttributes(
    $nkBdnEditorCapsuleColliderAttributeCache,
    $colliderNodes,
    $shouldSetPlacementAttributes
  );
}

/*-
@param $colliderNodes <string[]>
@returns <>
*/
proc copyInfinitePlaneColliderAttributes(string $colliderNodes[]) {
  // print("copyInfinitePlaneColliderAttributes\n"); // debug
  // print("  colliderNodes:{\n    " + stringArrayToString($colliderNodes, ",\n    ") + "\n  }\n"); // debug
  global string $nkBdnEditorInfinitePlaneColliderAttributeCache;
  int $numColliderNodes = `size $colliderNodes`;
  if ($numColliderNodes == 0) return;

  string $lastNode = $colliderNodes[$numColliderNodes - 1];
  $nkBdnEditorInfinitePlaneColliderAttributeCache = infinitePlaneColliderAttributesToDict($lastNode);
  print("// nkBdnEditor: nkBdnEditorInfinitePlaneColliderAttributeCache:" + $nkBdnEditorInfinitePlaneColliderAttributeCache + "\n");
}

/*-
@param $colliderNodes <string[]>
@returns <>
*/
proc pasteInfinitePlaneColliderAttributes(string $colliderNodes[]) {
  // print("pasteInfinitePlaneColliderAttributes\n"); // debug
  // print("  colliderNodes:{\n    " + stringArrayToString($colliderNodes, ",\n    ") + "\n  }\n"); // debug
  global string $nkBdnEditorInfinitePlaneColliderAttributeCache;
  if (!`size $colliderNodes`) return;

  applyDictToInfinitePlaneColliderAttributes($nkBdnEditorInfinitePlaneColliderAttributeCache, $colliderNodes);
}

/*-
@param $colliderNodes <string[]>
@returns <>
*/
proc copySphereColliderAttributes(string $colliderNodes[]) {
  // print("copySphereColliderAttributes\n"); // debug
  // print("  colliderNodes:{\n    " + stringArrayToString($colliderNodes, ",\n    ") + "\n  }\n"); // debug
  global string $nkBdnEditorSphereColliderAttributeCache;
  int $numColliderNodes = `size $colliderNodes`;
  if ($numColliderNodes == 0) return;

  string $lastNode = $colliderNodes[$numColliderNodes - 1];
  $nkBdnEditorSphereColliderAttributeCache = sphereColliderAttributesToDict($lastNode);
  print("// nkBdnEditor: nkBdnEditorSphereColliderAttributeCache:" + $nkBdnEditorSphereColliderAttributeCache + "\n");
}

/*-
@param $colliderNodes <string[]>
@returns <>
*/
proc pasteSphereColliderAttributes(string $colliderNodes[]) {
  // print("pasteSphereColliderAttributes\n"); // debug
  // print("  colliderNodes:{\n    " + stringArrayToString($colliderNodes, ",\n    ") + "\n  }\n"); // debug
  global string $nkBdnEditorSphereColliderAttributeCache;
  if (!`size $colliderNodes`) return;

  applyDictToSphereColliderAttributes($nkBdnEditorSphereColliderAttributeCache, $colliderNodes);
}

// -----------------------------------------------------------------------------
// メッシュ
// -----------------------------------------------------------------------------
/*-
@param $bdnNode <string>
@param $index <int>
@param $meshNode <string>
@returns <>
*/
proc connectMesh(string $bdnNode, int $index, string $meshNode) {
  // print("connectMesh\n"); // debug
  // print("  bdnNode :" + $bdnNode + "\n"); // debug
  // print("  index   :" + $index + "\n"); // debug
  // print("  meshNode:" + $meshNode + "\n"); // debug
  if (!isBdnPluginLoaded()) return;
  if (
    !isType($bdnNode, {"boneDynamicsNode"}, true)
        || $index < 0
        || !isMeshNode($meshNode)
  ) return;

  connectAttr -f
      ($meshNode + ".outMesh")
      ($bdnNode + ".meshCollider[" + $index + "]");
}

/*-
@param $sourceNodes <string[]>
@param $bdnNodes <string[]>
@returns <string[]>
*/
proc appendMesh(string $sourceNodes[], string $bdnNodes[]) {
  // print("appendMesh\n"); // debug
  // print("  sourceNodes:{\n    " + stringArrayToString($sourceNodes, ",\n    ") + "\n  }\n"); // debug
  // print("  bdnNodes   :{\n    " + stringArrayToString($bdnNodes, ",\n    ") + "\n  }\n"); // debug
  if (!isBdnPluginLoaded()) return;
  if (!`size $sourceNodes` || !`size $bdnNodes`) return;

  string $meshNodes[];
  for ($sourceNode in $sourceNodes) {
    if (!isMeshNode($sourceNode)) continue;

    $meshNodes[`size $meshNodes`] = $sourceNode;
  }
  // print("  meshNodes:{\n    " + stringArrayToString($meshNodes, ",\n    ") + "\n  }\n"); // debug
  if (`size $meshNodes` == 0) return;

  for ($bdnNode in $bdnNodes) {
    if (!isType($bdnNode, {"boneDynamicsNode"}, true)) continue;

    int $size = `getAttr -s ($bdnNode + ".meshCollider")`;
    string $newMeshNodes[];
    for ($i = 0; $i < $size; $i++) {
      $newMeshNodes = stringArrayCatenate(
        $newMeshNodes,
        getSourceConnections(
          $bdnNode,
          {"meshCollider[" + $i + "]"},
          "", {}, {}
        )
      );
      removeMultiInstance -b true ($bdnNode + ".meshCollider[" + $i + "]");
    }
    $newMeshNodes = stringArrayCatenate($newMeshNodes, $meshNodes);
    $newMeshNodes = stringArrayRemoveDuplicates($newMeshNodes);

    for ($i = 0; $i < `size $newMeshNodes`; $i++) {
      connectMesh($bdnNode, $i, $newMeshNodes[$i]);
    }
  }

  notify("nkBdnEditorBdnMeshConnectionChanged");
}

/*-
@param $sourceNodes <string[]>
@param $bdnNodes <string[]>
@returns <string[]>
*/
proc removeMesh(string $sourceNodes[], string $bdnNodes[]) {
  // print("removeMesh\n"); // debug
  // print("  sourceNodes:{\n    " + stringArrayToString($sourceNodes, ",\n    ") + "\n  }\n"); // debug
  // print("  bdnNodes   :{\n    " + stringArrayToString($bdnNodes, ",\n    ") + "\n  }\n"); // debug
  if (!isBdnPluginLoaded()) return;
  if (!`size $sourceNodes` || !`size $bdnNodes`) return;

  string $meshNodes[];
  for ($sourceNode in $sourceNodes) {
    if (!isMeshNode($sourceNode)) continue;

    $meshNodes[`size $meshNodes`] = $sourceNode;
  }
  // print("  meshNodes:{\n    " + stringArrayToString($meshNodes, ",\n    ") + "\n  }\n"); // debug
  if (`size $meshNodes` == 0) return;

  for ($bdnNode in $bdnNodes) {
    if (!isType($bdnNode, {"boneDynamicsNode"}, true)) continue;

    int $size = `getAttr -s ($bdnNode + ".meshCollider")`;
    string $newMeshNodes[];
    for ($i = 0; $i < $size; $i++) {
      $newMeshNodes = stringArrayCatenate(
        $newMeshNodes,
        getSourceConnections(
          $bdnNode,
          {"meshCollider[" + $i + "]"},
          "", {}, {}
        )
      );
      removeMultiInstance -b true ($bdnNode + ".meshCollider[" + $i + "]");
    }
    $newMeshNodes = `stringArrayRemove $meshNodes $newMeshNodes`;
    $newMeshNodes = stringArrayRemoveDuplicates($newMeshNodes);

    for ($i = 0; $i < `size $newMeshNodes`; $i++) {
      connectMesh($bdnNode, $i, $newMeshNodes[$i]);
    }
  }

  notify("nkBdnEditorBdnMeshConnectionChanged");
}

// -----------------------------------------------------------------------------
// フォース
// -----------------------------------------------------------------------------
/*-
@param $transformNode <string>
@returns <string>
*/
proc string getForceVectorNodeFromTransform(string $transformNode) {
  // print("getForceVectorNodeFromTransform\n"); // debug
  // print("  transformNode:" + $transformNode + "\n"); // debug
  string $forceVectorNode;
  if (!isType($transformNode, {"transform"}, false)) return $forceVectorNode;

  string $destNodes[] = getDestConnections($transformNode, {"worldMatrix"}, "vectorProduct", {}, {});
  for ($destNode in $destNodes) {
    if (isBdnType($destNode, "force")) {
      $forceVectorNode = $destNode;
    }
  }
  return $forceVectorNode;
}

/*-
@param $bdnNode <string>
@returns <string>
*/
proc string getForceVectorNodeFromBdn(string $bdnNode) {
  // print("getForceVectorNodeFromBdn\n"); // debug
  // print("  bdnNode:" + $bdnNode + "\n"); // debug
  string $forceVectorNode;
  if (!isType($bdnNode, {"boneDynamicsNode"}, true)) return $forceVectorNode;

  string $afSourceNodes[] = getSourceConnections($bdnNode, {"additionalForce"}, "vectorProduct", {}, {});
  for ($afSourceNode in $afSourceNodes) {
    if (isBdnType($afSourceNode, "force")) {
      $forceVectorNode = $afSourceNode;
    }
  }
  return $forceVectorNode;
}

/*-
@param $bdnNode <string>
@returns <string>
*/
proc string getForceNodeFromBdn(string $bdnNode) {
  // print("getForceNodeFromBdn\n"); // debug
  // print("  bdnNode:" + $bdnNode + "\n"); // debug
  string $forceNode;
  if (!isType($bdnNode, {"boneDynamicsNode"}, true)) return $forceNode;

  string $forceVectorNode = getForceVectorNodeFromBdn($bdnNode);
  if (!isBdnType($forceVectorNode, "force")) return $forceNode;

  string $mSourceNodes[] = getSourceConnections($forceVectorNode, {"matrix"}, "", {}, {});
  for ($mSourceNode in $mSourceNodes) {
    if (isType($mSourceNode, {"transform"}, false)) {
      $forceNode = $mSourceNode;
    }
  }
  return $forceNode;
}

/*-
@param $sourceNodes <string[]>
@param $bdnNodes <string[]>
@param $forceVector <float[3]>
@returns <string[]>
*/
proc connectForce(string $sourceNodes[], string $bdnNodes[], float $forceVector[]) {
  // print("connectForce\n"); // debug
  // print("  sourceNodes:{\n    " + stringArrayToString($sourceNodes, ",\n    ") + "\n  }\n"); // debug
  // print("  bdnNodes   :{\n    " + stringArrayToString($bdnNodes, ",\n    ") + "\n  }\n"); // debug
  // print("  forceVector:{\n    " + floatArrayToString($forceVector, ",\n    ") + "\n  }\n"); // debug
  if (!isBdnPluginLoaded()) return;

  string $transformNodes[];
  for ($sourceNode in $sourceNodes) {
    if (!isType($sourceNode, {"transform"}, false)) continue;

    $transformNodes[`size $transformNodes`] = $sourceNode;
  }
  // print("  transformNodes:{\n    " + stringArrayToString($transformNodes, ",\n    ") + "\n  }\n"); // debug
  if (`size $transformNodes` == 0) return;

  int $hasCconnected = false;
  for ($transformNode in $transformNodes) {
    string $forceNode = getForceVectorNodeFromTransform($transformNode);
    if (!isBdnType($forceNode, "force")) {
      // 計算ノード作成
      $forceNode = initForceNode(uuidToLongName(toUUID(`createNode -n (toShortName($transformNode) + "_forceVector") -ss "vectorProduct"`)));
      // 計算ノード設定
      setAttr ($forceNode + ".operation") 3;
      setAttr ($forceNode + ".input1") $forceVector[0] $forceVector[1] $forceVector[2];
      setAttr ($forceNode + ".input2") 0.0 0.0 0.0;
      setAttr ($forceNode + ".normalizeOutput") true;
      // アトリビュート接続
      connectAttr -f ($transformNode + ".worldMatrix") ($forceNode + ".matrix");
    }
    if (!isBdnType($forceNode, "force")) continue;

    for ($bdnNode in $bdnNodes) {
      if (!isType($bdnNode, {"boneDynamicsNode"}, true)) continue;

      connectAttr -f ($forceNode + ".output") ($bdnNode + ".additionalForce");
      if (!$hasCconnected) $hasCconnected = true;
    }
  }

  if ($hasCconnected) {
    notify("nkBdnEditorBdnForceConnectionChanged");
  }
}

/*-
@param $sourceNodes <string[]>
@param $bdnNodes <string[]>
@returns <string[]>
*/
proc disconnectForce(string $sourceNodes[], string $bdnNodes[]) {
  // print("disconnectForce\n"); // debug
  // print("  sourceNodes:{\n    " + stringArrayToString($sourceNodes, ",\n    ") + "\n  }\n"); // debug
  // print("  bdnNodes   :{\n    " + stringArrayToString($bdnNodes, ",\n    ") + "\n  }\n"); // debug
  if (!isBdnPluginLoaded()) return;

  string $transformNodes[];
  for ($sourceNode in $sourceNodes) {
    if (!isType($sourceNode, {"transform"}, false)) continue;

    $transformNodes[`size $transformNodes`] = $sourceNode;
  }
  // print("  transformNodes:{\n    " + stringArrayToString($transformNodes, ",\n    ") + "\n  }\n"); // debug
  if (`size $transformNodes` == 0) return;

  int $hasDisconnected = false;
  for ($transformNode in $transformNodes) {
    string $forceNode = getForceVectorNodeFromTransform($transformNode);
    if (!isBdnType($forceNode, "force")) continue;

    for ($bdnNode in $bdnNodes) {
      if (!isType($bdnNode, {"boneDynamicsNode"}, true)) continue;

      string $currentForceNode = getForceVectorNodeFromBdn($bdnNode);
      if ($forceNode == $currentForceNode) {
        disconnectAttr ($forceNode + ".output") ($bdnNode + ".additionalForce");
        if (!$hasDisconnected) $hasDisconnected = true;
      }
    }

    string $fvDestNodes[] = getDestConnections($forceNode, {"output"}, "boneDynamicsNode", {}, {});
    if (!`size $fvDestNodes`) {
      disconnectAttr ($transformNode + ".worldMatrix") ($forceNode + ".matrix");
      delete $forceNode;
    }
  }

  if ($hasDisconnected) {
    notify("nkBdnEditorBdnForceConnectionChanged");
  }
}

// -----------------------------------------------------------------------------
// フォースアトリビュート
// -----------------------------------------------------------------------------
/*-
@param $forceVectorNodes <string[]>
@param $forceVector <float[3]>
@returns <>
*/
proc setForceVectorAttribute(string $forceVectorNodes[], float $forceVector[]) {
  // print("setForceVectorAttribute\n"); // debug
  // print("  forceVectorNodes:{\n    " + stringArrayToString($forceVectorNodes, ",\n    ") + "\n  }\n"); // debug
  // print("  forceVector     :{\n    " + floatArrayToString($forceVector, ",\n    ") + "\n  }\n"); // debug
  if (!`size $forceVectorNodes` || `size $forceVector` != 3) return;

  for ($forceVectorNode in $forceVectorNodes) {
    if (!isBdnType($forceVectorNode, "force")) continue;

    setFloat3Attribute($forceVectorNode, "input1", $forceVector);
  }
  notify("nkBdnEditorForceAttributeChanged");
}

// -----------------------------------------------------------------------------
// オフセット
// -----------------------------------------------------------------------------
/*-
@param $sourceNodes <string[]>
@param $bdnNodes <string[]>
@returns <string[]>
*/
proc connectOffset(string $sourceNodes[], string $bdnNodes[]) {
  // print("connectOffset\n"); // debug
  // print("  sourceNodes:{\n    " + stringArrayToString($sourceNodes, ",\n    ") + "\n  }\n"); // debug
  // print("  bdnNodes   :{\n    " + stringArrayToString($bdnNodes, ",\n    ") + "\n  }\n"); // debug
  if (!isBdnPluginLoaded()) return;

  string $offsetNodes[];
  for ($sourceNode in $sourceNodes) {
    if (!isType($sourceNode, {"transform"}, false)) continue;

    $offsetNodes[`size $offsetNodes`] = $sourceNode;
  }
  // print("  offsetNodes:{\n    " + stringArrayToString($offsetNodes, ",\n    ") + "\n  }\n"); // debug
  int $numOffsetNodes = `size $offsetNodes`;
  if ($numOffsetNodes == 0) return;

  string $offsetNode = $offsetNodes[$numOffsetNodes - 1];
  for ($bdnNode in $bdnNodes) {
    if (!isType($bdnNode, {"boneDynamicsNode"}, true)) continue;

    connectAttr -f ($offsetNode + ".worldMatrix") ($bdnNode + ".offsetMatrix");
  }

  notify("nkBdnEditorBdnOffsetConnectionChanged");
}

/*-
@param $sourceNodes <string[]>
@param $bdnNodes <string[]>
@returns <string[]>
*/
proc disconnectOffset(string $sourceNodes[], string $bdnNodes[]) {
  // print("disconnectOffset\n"); // debug
  // print("  sourceNodes:{\n    " + stringArrayToString($sourceNodes, ",\n    ") + "\n  }\n"); // debug
  // print("  bdnNodes   :{\n    " + stringArrayToString($bdnNodes, ",\n    ") + "\n  }\n"); // debug
  if (!isBdnPluginLoaded()) return;

  string $offsetNodes[];
  for ($sourceNode in $sourceNodes) {
    if (!isType($sourceNode, {"transform"}, false)) continue;

    $offsetNodes[`size $offsetNodes`] = $sourceNode;
  }
  // print("  offsetNodes:{\n    " + stringArrayToString($offsetNodes, ",\n    ") + "\n  }\n"); // debug
  int $numOffsetNodes = `size $offsetNodes`;
  if ($numOffsetNodes == 0) return;

  int $hasDisconnected = false;
  for ($offsetNode in $offsetNodes) {
    for ($bdnNode in $bdnNodes) {
      if (!isType($bdnNode, {"boneDynamicsNode"}, true)) continue;

      string $currentOffsetNodes[] = getSourceConnections($bdnNode, {"offsetMatrix"}, "", {}, {});
      if (!stringArrayContains($offsetNode, $currentOffsetNodes)) continue;

      disconnectAttr ($offsetNode + ".worldMatrix") ($bdnNode + ".offsetMatrix");
      if (!$hasDisconnected) $hasDisconnected = true;
    }
  }

  if ($hasDisconnected) {
    notify("nkBdnEditorBdnOffsetConnectionChanged");
  }
}

// -----------------------------------------------------------------------------
// ベイク
// -----------------------------------------------------------------------------
/*-
@param $sourceNodes <string[]>
@param $timeRange <string> `int`または`float`で`"start:end"`の形式で指定する。
@returns <>
*/
proc bakeBind(string $sourceNodes[], string $timeRange) {
  // print("bakeBind\n"); // debug
  // print("  sourceNodes:{\n    " + stringArrayToString($sourceNodes, ",\n    ") + "\n  }\n"); // debug
  // print("  timeRange  :" + $timeRange + "\n"); // debug
  if (`match "^-*[\.0-9]+:-*[\.0-9]+$" $timeRange` != $timeRange) return;

  string $bindNodes[];
  for ($sourceNode in $sourceNodes) {
    if (!isType($sourceNode, {"transform"}, false)) continue;

    string $dynamicsNode;
    string $destNodes[] = getDestConnections($sourceNode, {"message"}, "", {}, {});
    for ($destNode in $destNodes) {
      if (isJointKind($destNode, "dynamics")) {
        $dynamicsNode = $destNode;
        break;
      }
    }
    if (isJointKind($dynamicsNode, "dynamics")) {
      $bindNodes[`size $bindNodes`] = $sourceNode;
    }
  }
  // print("  bindNodes:{\n    " + stringArrayToString($bindNodes, ",\n    ") + "\n  }\n"); // debug
  int $numBindNodes = `size $bindNodes`;
  if ($numBindNodes == 0) return;

  bakeResults
      -at "rx" -at "ry" -at "rz"
      -bol false
      -dic true
      -mr true
      -osr 1
      -pok true
      -rba false
      -ral false
      -sb 1.0
      -sm true
      -sac false
      -t $timeRange
      $bindNodes;
}

/*-
@param $sourceNodes <string[]>
@returns <>
*/
proc rebind(string $sourceNodes[]) {
  // print("rebind\n"); // debug
  // print("  sourceNodes:{\n    " + stringArrayToString($sourceNodes, ",\n    ") + "\n  }\n"); // debug
  if (!`size $sourceNodes`) return;

  // ベースアニメーションレイヤを選択
  string $baseAnimLayer = `animLayer -q -r`;
  string $animLayers[] = gatherNodes({"animLayer"}, true, false, "");
  for ($animLayer in $animLayers) {
    animLayer -e -sel ($animLayer == $baseAnimLayer) $animLayer;
  }

  for ($sourceNode in $sourceNodes) {
    // print("  sourceNode:" + $sourceNode + "\n"); // debug
    string $dynamicsNode;
    string $orcstNode;
    string $msgDestNodes[] = getDestConnections($sourceNode, {"message"}, "", {}, {});
    for ($destNode in $msgDestNodes) {
      if (isJointKind($destNode, "dynamics")) {
        $dynamicsNode = $destNode;
        break;
      }
    }
    if (!isJointKind($dynamicsNode, "dynamics")) continue;

    string $pimDestNodes[] = getDestConnections($sourceNode, {"parentInverseMatrix"}, "orientConstraint", {}, {});
    for ($destNode in $pimDestNodes) {
      if (getMultiAttributeSize($destNode, "target") == 0) continue;

      string $tpmSourceNodes[] = getSourceConnections($destNode, {"target[0].targetParentMatrix"}, "", {}, {});
      if (stringArrayFind($dynamicsNode, 0, $tpmSourceNodes) >= 0) {
        $orcstNode = $destNode;
        break;
      }
    }
    if (!isType($orcstNode, {"orientConstraint"}, true)) continue;

    // print("    dynamicsNode:" + $dynamicsNode + "\n"); // debug
    // print("    orcstNode   :" + $orcstNode + "\n"); // debug

    string $rotateSourceNodes[] = getSourceConnections($sourceNode, {"rx", "ry", "rz"}, "", {}, {});
    // print("    rotateSourceNodes:{\n      " + stringArrayToString($rotateSourceNodes, ",\n      ") + "\n    }\n"); // debug
    if (stringArrayFind($orcstNode, 0, $rotateSourceNodes) >= 0) continue;

    // キーを削除
    cutKey -at "rx" -at "ry" -at "rz" -cl -hi "none" -t ":" $sourceNode;

    // 接続が残っている場合はベース以外のアニメーションレイヤのメンバーである可能性があるため処理しない。
    $rotateSourceNodes = getSourceConnections($sourceNode, {"rx", "ry", "rz"}, "", {}, {});
    // print("    rotateSourceNodes:{\n      " + stringArrayToString($rotateSourceNodes, ",\n      ") + "\n    }\n"); // debug
    if (`size $rotateSourceNodes`) continue;

    // 再接続
    connectAttributes(
      {
        $orcstNode + ".constraintRotateX",
        $orcstNode + ".constraintRotateY",
        $orcstNode + ".constraintRotateZ"
      },
      {
        $sourceNode + ".rotateX",
        $sourceNode + ".rotateY",
        $sourceNode + ".rotateZ"
      },
      false
    );
    // print("    connectAttributes\n"); // debug
  }
}

// /////////////////////////////////////////////////////////////////////////////
// API
// /////////////////////////////////////////////////////////////////////////////

// /////////////////////////////////////////////////////////////////////////////
// スクリプトジョブ
// /////////////////////////////////////////////////////////////////////////////
// -----------------------------------------------------------------------------
// イベントジョブ
// -----------------------------------------------------------------------------
/*-
@returns <>
*/
proc registerEventJob() {
  // print("registerEventJob\n"); // debug
  int $newSceneOpenedId = `scriptJob
      -e "NewSceneOpened" "nkBdnEditorNewSceneOpened"
      -p "nkBdnEditorWindow"`;
  int $postSceneReadId = `scriptJob
      -e "PostSceneRead" "nkBdnEditorPostSceneRead"
      -p "nkBdnEditorWindow"`;
  int $timeChangedId = `scriptJob
      -e "timeChanged" "nkBdnEditorTimeChanged"
      -p "nkBdnEditorWindow"`;

  // subscribeNode("Added", "nkBdnEditorNodeAdded", {"boneDynamicsNode"}, true);
  subscribeNode("Removed", "nkBdnEditorNodeRemoved", {"boneDynamicsNode", "transform", "unknown"}, true);
}

/*-
@returns <>
*/
proc unregisterEventJob() {
  // print("unregisterEventJob\n"); // debug
  // unsubscribeNode("Added", "nkBdnEditorNodeAdded", {"boneDynamicsNode"});
  unsubscribeNode("Removed", "nkBdnEditorNodeRemoved", {"boneDynamicsNode", "transform"});
}

// -----------------------------------------------------------------------------
// ノードジョブ
// -----------------------------------------------------------------------------
// /*-
// @param $n <string>
// @returns <>
// */
// proc registerNodeJob(string $n) {
//   print("registerNodeJob\n"); // debug
//   print("  n:" + $n + "\n"); // debug
// }

// /*-
// @param $nodeId <string>
// @returns <>
// */
// proc unregisterNodeJob(string $nodeId) {
//   print("unregisterNodeJob\n"); // debug
//   print("  nodeId:" + $nodeId + "\n"); // debug
// }

// /////////////////////////////////////////////////////////////////////////////
// プレゼンテーション
// /////////////////////////////////////////////////////////////////////////////
/*-
@returns <>
*/
proc subscribeMainWindowObservers() {
  // print("subscribeMainWindowObservers\n"); // debug
  subscribe("nkBdnEditorDynamicsNodeCreated", "nkBdnEditorDynamicsNodeCreated");
  subscribe("nkBdnEditorBdnAttributeChanged", "nkBdnEditorBdnAttributeChanged");
  subscribe("nkBdnEditorBdnColliderConnectionChanged", "nkBdnEditorBdnColliderConnectionChanged");
  subscribe("nkBdnEditorBdnMeshConnectionChanged", "nkBdnEditorBdnMeshConnectionChanged");
  subscribe("nkBdnEditorBdnForceConnectionChanged", "nkBdnEditorBdnForceConnectionChanged");
  subscribe("nkBdnEditorBdnOffsetConnectionChanged", "nkBdnEditorBdnOffsetConnectionChanged");
  subscribe("nkBdnEditorColliderCreated", "nkBdnEditorColliderCreated");
  subscribe("nkBdnEditorColliderAttributeChanged", "nkBdnEditorColliderAttributeChanged");
  subscribe("nkBdnEditorForceAttributeChanged", "nkBdnEditorForceAttributeChanged");
}

/*-
@returns <>
*/
proc unsubscribeMainWindowObservers() {
  // print("unsubscribeMainWindowObservers\n"); // debug
  unsubscribe("nkBdnEditorDynamicsNodeCreated", "nkBdnEditorDynamicsNodeCreated");
  unsubscribe("nkBdnEditorBdnAttributeChanged", "nkBdnEditorBdnAttributeChanged");
  unsubscribe("nkBdnEditorBdnColliderConnectionChanged", "nkBdnEditorBdnColliderConnectionChanged");
  unsubscribe("nkBdnEditorBdnMeshConnectionChanged", "nkBdnEditorBdnMeshConnectionChanged");
  unsubscribe("nkBdnEditorBdnForceConnectionChanged", "nkBdnEditorBdnForceConnectionChanged");
  unsubscribe("nkBdnEditorBdnOffsetConnectionChanged", "nkBdnEditorBdnOffsetConnectionChanged");
  unsubscribe("nkBdnEditorColliderCreated", "nkBdnEditorColliderCreated");
  unsubscribe("nkBdnEditorColliderAttributeChanged", "nkBdnEditorColliderAttributeChanged");
  unsubscribe("nkBdnEditorForceAttributeChanged", "nkBdnEditorForceAttributeChanged");
}

// -----------------------------------------------------------------------------
/*-
@returns <string[]>
*/
proc string[] getSelectedBdnNodes() {
  // print("getSelectedBdnNodes\n"); // debug
  string $bdnNodeList = getUIControl("nkBdnEditorWindow", "bdnNodeList");
  string $bdnNodes[] = qStringArray("textScrollList", "-sut", $bdnNodeList);
  // print("  bdnNodes:{\n    " + stringArrayToString($bdnNodes, ",\n    ") + "\n  }\n"); // debug
  return $bdnNodes;
}

/*-
@returns <string[]>
*/
proc string[] getSelectedDynamicsNodes() {
  // print("getSelectedDynamicsNodes\n"); // debug
  string $dynamicsNodeList = getUIControl("nkBdnEditorWindow", "dynamicsNodeList");
  string $dynamicsNodes[] = qStringArray("textScrollList", "-sut", $dynamicsNodeList);
  // print("  dynamicsNodes:{\n    " + stringArrayToString($dynamicsNodes, ",\n    ") + "\n  }\n"); // debug
  return $dynamicsNodes;
}

/*-
@returns <string[]>
*/
proc string[] getSelectedTargetNodes() {
  // print("getSelectedTargetNodes\n"); // debug
  string $targetNodeList = getUIControl("nkBdnEditorWindow", "targetNodeList");
  string $targetNodes[] = qStringArray("textScrollList", "-sut", $targetNodeList);
  // print("  targetNodes:{\n    " + stringArrayToString($targetNodes, ",\n    ") + "\n  }\n"); // debug
  return $targetNodes;
}

/*-
@returns <string[]>
*/
proc string[] getSelectedInfluencedColliderNodes() {
  // print("getSelectedInfluencedColliderNodes\n"); // debug
  string $influencedColliderNodeList = getUIControl("nkBdnEditorWindow", "influencedColliderNodeList");
  string $colliderNodes[] = qStringArray("textScrollList", "-sut", $influencedColliderNodeList);
  // print("  colliderNodes:{\n    " + stringArrayToString($colliderNodes, ",\n    ") + "\n  }\n"); // debug
  return $colliderNodes;
}

/*-
@param $colliderType <string> 空文字列の場合は全て取得する。
@returns <string[]>
*/
proc string[] getSelectedAllColliderNodes(string $colliderType) {
  // print("getSelectedAllColliderNodes\n"); // debug
  // print("  colliderType:" + $colliderType + "\n"); // debug
  string $allColliderNodeList = getUIControl("nkBdnEditorWindow", "allColliderNodeList");

  string $selectedColliderNodes[] = qStringArray("textScrollList", "-sut", $allColliderNodeList);
  if (!`size $colliderType`) return $selectedColliderNodes;

  string $colliderNodes[];
  for ($colliderNode in $selectedColliderNodes) {
    if (isColliderType($colliderNode, $colliderType)) {
      $colliderNodes[`size $colliderNodes`] = $colliderNode;
    }
  }
  // print("  colliderNodes:{\n    " + stringArrayToString($colliderNodes, ",\n    ") + "\n  }\n"); // debug
  return $colliderNodes;
}

/*-
@returns <string[]>
*/
proc string[] getSelectedMeshNodes() {
  // print("getSelectedMeshNodes\n"); // debug
  string $meshNodeList = getUIControl("nkBdnEditorWindow", "meshNodeList");
  string $meshNodes[] = qStringArray("textScrollList", "-sut", $meshNodeList);
  // print("  meshNodes:{\n    " + stringArrayToString($meshNodes, ",\n    ") + "\n  }\n"); // debug
  return $meshNodes;
}

/*-
@returns <string[]>
*/
proc string[] getSelectedForceNodes() {
  // print("getSelectedForceNodes\n"); // debug
  string $forceNodeList = getUIControl("nkBdnEditorWindow", "forceNodeList");
  string $forceNodes[] = qStringArray("textScrollList", "-sut", $forceNodeList);
  // print("  forceNodes:{\n    " + stringArrayToString($forceNodes, ",\n    ") + "\n  }\n"); // debug
  return $forceNodes;
}

/*-
@returns <string[]>
*/
proc string[] getSelectedForceVectorNodes() {
  // print("getSelectedForceVectorNodes\n"); // debug
  string $forceVectorNodes[];
  string $forceNodes[] = getSelectedForceNodes();
  for ($forceNode in $forceNodes) {
    string $forceVectorNode = getForceVectorNodeFromTransform($forceNode);
    if (isBdnType($forceVectorNode, "force")) {
      $forceVectorNodes[`size $forceVectorNodes`] = $forceVectorNode;
    }
  }
  return $forceVectorNodes;
}

/*-
@returns <string[]>
*/
proc string[] getSelectedOffsetNodes() {
  // print("getSelectedOffsetNodes\n"); // debug
  string $offsetNodeList = getUIControl("nkBdnEditorWindow", "offsetNodeList");
  string $offsetNodes[] = qStringArray("textScrollList", "-sut", $offsetNodeList);
  // print("  offsetNodes:{\n    " + stringArrayToString($offsetNodes, ",\n    ") + "\n  }\n"); // debug
  return $offsetNodes;
}

/*-
@returns <string[]>
*/
proc string[] getSelectedBindNodes() {
  // print("getSelectedBindNodes\n"); // debug
  string $bindNodeList = getUIControl("nkBdnEditorWindow", "bindNodeList");
  string $bindNodes[] = qStringArray("textScrollList", "-sut", $bindNodeList);
  // print("  bindNodes:{\n    " + stringArrayToString($bindNodes, ",\n    ") + "\n  }\n"); // debug
  return $bindNodes;
}

/*-
@returns <string>
*/
proc string getBakeTimeRange() {
  string $bakeTimeRangeRadioButton = getUIControl("nkBdnEditorWindow", "bakeTimeRangeRadioButton");
  string $bakeStartEndField = getUIControl("nkBdnEditorWindow", "bakeStartEndField");

  float $startTime;
  float $endTime;
  int $rangeType = qIndex("radioButtonGrp", "-sl", $bakeTimeRangeRadioButton);
  if ($rangeType == 0) {
    $startTime = `playbackOptions -q -min`;
    $endTime = `playbackOptions -q -max`;
  }
  else if ($rangeType == 1) {
    $startTime = qFloat("floatFieldGrp", "-v1", $bakeStartEndField);
    $endTime = qFloat("floatFieldGrp", "-v2", $bakeStartEndField);
  }
  return ((string) $startTime + ":" + (string) $endTime);
}

// -----------------------------------------------------------------------------
/*-
@returns <>
*/
proc updateBdnAttributeUI() {
  // print("updateBdnAttributeUI\n"); // debug
  string $bdnEnableCheckBox = getUIControl("nkBdnEditorWindow", "bdnEnableCheckBox");
  string $bdnResetTimeField = getUIControl("nkBdnEditorWindow", "bdnResetTimeField");
  string $bdnFpsField = getUIControl("nkBdnEditorWindow", "bdnFpsField");
  string $bdnOffsetMatrixWeightField = getUIControl("nkBdnEditorWindow", "bdnOffsetMatrixWeightField");
  string $bdnDampingField = getUIControl("nkBdnEditorWindow", "bdnDampingField");
  string $bdnElasticityField = getUIControl("nkBdnEditorWindow", "bdnElasticityField");
  string $elasticForceFunctionMenuGrp = getUIControl("nkBdnEditorWindow", "elasticForceFunctionMenuGrp");
  string $bdnStiffnessField = getUIControl("nkBdnEditorWindow", "bdnStiffnessField");
  string $bdnMassField = getUIControl("nkBdnEditorWindow", "bdnMassField");
  string $bdnGravityXField = getUIControl("nkBdnEditorWindow", "bdnGravityXField");
  string $bdnGravityYField = getUIControl("nkBdnEditorWindow", "bdnGravityYField");
  string $bdnGravityZField = getUIControl("nkBdnEditorWindow", "bdnGravityZField");
  string $bdnGravityMultiplyField = getUIControl("nkBdnEditorWindow", "bdnGravityMultiplyField");
  string $bdnAdditionalForceScaleField = getUIControl("nkBdnEditorWindow", "bdnAdditionalForceScaleField");
  string $bdnEnableTurbulenceCheckBox = getUIControl("nkBdnEditorWindow", "bdnEnableTurbulenceCheckBox");
  string $bdnTurbulenceSeedField = getUIControl("nkBdnEditorWindow", "bdnTurbulenceSeedField");
  string $bdnTurbulenceStrengthField = getUIControl("nkBdnEditorWindow", "bdnTurbulenceStrengthField");
  string $bdnTurbulenceVectorChangeScaleField = getUIControl("nkBdnEditorWindow", "bdnTurbulenceVectorChangeScaleField");
  string $bdnTurbulenceVectorChangeMaxField = getUIControl("nkBdnEditorWindow", "bdnTurbulenceVectorChangeMaxField");
  string $bdnEnableAngleLimitCheckBox = getUIControl("nkBdnEditorWindow", "bdnEnableAngleLimitCheckBox");
  string $bdnAngleLimitField = getUIControl("nkBdnEditorWindow", "bdnAngleLimitField");
  string $bdnRadiusField = getUIControl("nkBdnEditorWindow", "bdnRadiusField");
  string $bdnIterationsField = getUIControl("nkBdnEditorWindow", "bdnIterationsField");
  string $bdnEnableGroundColCheckBox = getUIControl("nkBdnEditorWindow", "bdnEnableGroundColCheckBox");
  string $bdnGroundHeightField = getUIControl("nkBdnEditorWindow", "bdnGroundHeightField");
  string $bdnMeshColCutoffField = getUIControl("nkBdnEditorWindow", "bdnMeshColCutoffField");

  int $enable = true;
  float $resetTime = 0.0;
  float $fps = 30.0;
  float $offsetMatrixWeight = 1.0;
  float $damping = 0.1;
  float $elasticity = 30.0;
  int $elasticForceFunction = 0;
  float $stiffness = 0.0;
  float $mass = 1.0;
  float $gravityX = 0.0;
  float $gravityY = -980.0;
  float $gravityZ = 0.0;
  float $gravityMultiply = 0.0;
  float $additionalForceScale = 1.0;
  int $enableTurbulence = false;
  int $turbulenceSeed = 0;
  float $turbulenceStrength = 10.0;
  float $turbulenceVectorChangeScale = 0.05;
  float $turbulenceVectorChangeMax = 0.1;
  int $enableAngleLimit = false;
  float $angleLimit = 60.0;
  float $radius = 0.0;
  int $iterations = 5;
  int $enableGroundCol = false;
  float $groundHeight = 0.0;
  float $meshColCutoff = 10.0;

  string $bdnNodes[] = getSelectedBdnNodes();
  int $numBdnNodes = `size $bdnNodes`;
  if ($numBdnNodes > 0) {
    string $lastNode = $bdnNodes[$numBdnNodes - 1];
    if (isType($lastNode, {"boneDynamicsNode"}, true) || isBdnType($lastNode, "alt")) {
      $enable = getIntAttribute($lastNode, "enable", $enable);
      $resetTime = getFloatAttribute($lastNode, "resetTime", $resetTime);
      $fps = getFloatAttribute($lastNode, "fps", $fps);
      $offsetMatrixWeight = getFloatAttribute($lastNode, "offsetMatrixWeight", $offsetMatrixWeight);
      $damping = getFloatAttribute($lastNode, "damping", $damping);
      $elasticity = getFloatAttribute($lastNode, "elasticity", $elasticity);
      $elasticForceFunction = getIntAttribute($lastNode, "elasticForceFunction", $elasticForceFunction);
      $stiffness = getFloatAttribute($lastNode, "stiffness", $stiffness);
      $mass = getFloatAttribute($lastNode, "mass", $mass);
      $gravityX = getFloatAttribute($lastNode, "gravityX", $gravityX);
      $gravityY = getFloatAttribute($lastNode, "gravityY", $gravityY);
      $gravityZ = getFloatAttribute($lastNode, "gravityZ", $gravityZ);
      $gravityMultiply = getFloatAttribute($lastNode, "gravityMultiply", $gravityMultiply);
      $additionalForceScale = getFloatAttribute($lastNode, "additionalForceScale", $additionalForceScale);
      $enableTurbulence = getIntAttribute($lastNode, "enableTurbulence", $enableTurbulence);
      $turbulenceSeed = getIntAttribute($lastNode, "turbulenceSeed", $turbulenceSeed);
      $turbulenceStrength = getFloatAttribute($lastNode, "turbulenceStrength", $turbulenceStrength);
      $turbulenceVectorChangeScale = getFloatAttribute($lastNode, "turbulenceVectorChangeScale", $turbulenceVectorChangeScale);
      $turbulenceVectorChangeMax = getFloatAttribute($lastNode, "turbulenceVectorChangeMax", $turbulenceVectorChangeMax);
      $enableAngleLimit = getIntAttribute($lastNode, "enableAngleLimit", $enableAngleLimit);
      $angleLimit = getFloatAttribute($lastNode, "angleLimit", $angleLimit);
      $radius = getFloatAttribute($lastNode, "radius", $radius);
      $iterations = getIntAttribute($lastNode, "iterations", $iterations);
      $enableGroundCol = getIntAttribute($lastNode, "enableGroundCol", $enableGroundCol);
      $groundHeight = getFloatAttribute($lastNode, "groundHeight", $groundHeight);
      $meshColCutoff = getFloatAttribute($lastNode, "meshColCutoff", $meshColCutoff);
    }
  }

  eInt("checkBoxGrp", "-v1", $enable, $bdnEnableCheckBox);
  eFloat("floatFieldGrp", "-v1", $resetTime, $bdnResetTimeField);
  eFloat("floatFieldGrp", "-v1", $fps, $bdnFpsField);
  eFloat("floatFieldGrp", "-v1", $offsetMatrixWeight, $bdnOffsetMatrixWeightField);
  eFloat("floatFieldGrp", "-v1", $damping, $bdnDampingField);
  eFloat("floatFieldGrp", "-v1", $elasticity, $bdnElasticityField);
  eIndex("optionMenuGrp", "-sl", $elasticForceFunction, $elasticForceFunctionMenuGrp);
  eFloat("floatFieldGrp", "-v1", $stiffness, $bdnStiffnessField);
  eFloat("floatFieldGrp", "-v1", $mass, $bdnMassField);
  eFloat("floatFieldGrp", "-v1", $gravityX, $bdnGravityXField);
  eFloat("floatFieldGrp", "-v1", $gravityY, $bdnGravityYField);
  eFloat("floatFieldGrp", "-v1", $gravityZ, $bdnGravityZField);
  eFloat("floatFieldGrp", "-v1", $gravityMultiply, $bdnGravityMultiplyField);
  eFloat("floatFieldGrp", "-v1", $additionalForceScale, $bdnAdditionalForceScaleField);
  eInt("checkBoxGrp", "-v1", $enableTurbulence, $bdnEnableTurbulenceCheckBox);
  eInt("intFieldGrp", "-v1", $turbulenceSeed, $bdnTurbulenceSeedField);
  eFloat("floatFieldGrp", "-v1", $turbulenceStrength, $bdnTurbulenceStrengthField);
  eFloat("floatFieldGrp", "-v1", $turbulenceVectorChangeScale, $bdnTurbulenceVectorChangeScaleField);
  eFloat("floatFieldGrp", "-v1", $turbulenceVectorChangeMax, $bdnTurbulenceVectorChangeMaxField);
  eInt("checkBoxGrp", "-v1", $enableAngleLimit, $bdnEnableAngleLimitCheckBox);
  eFloat("floatFieldGrp", "-v1", $angleLimit, $bdnAngleLimitField);
  eFloat("floatFieldGrp", "-v1", $radius, $bdnRadiusField);
  eInt("intFieldGrp", "-v1", $iterations, $bdnIterationsField);
  eInt("checkBoxGrp", "-v1", $enableGroundCol, $bdnEnableGroundColCheckBox);
  eFloat("floatFieldGrp", "-v1", $groundHeight, $bdnGroundHeightField);
  eFloat("floatFieldGrp", "-v1", $meshColCutoff, $bdnMeshColCutoffField);
}

/*-
@returns <>
*/
proc updateColliderAttributeUI() {
  // print("updateColliderAttributeUI\n"); // debug
  string $capsuleColliderFrame = getUIControl("nkBdnEditorWindow", "capsuleColliderFrame");
  string $capsuleColliderRadiusAField = getUIControl("nkBdnEditorWindow", "capsuleColliderRadiusAField");
  string $capsuleColliderRadiusBField = getUIControl("nkBdnEditorWindow", "capsuleColliderRadiusBField");
  string $capsuleColliderLengthField = getUIControl("nkBdnEditorWindow", "capsuleColliderLengthField");
  string $capsuleColliderOffsetField = getUIControl("nkBdnEditorWindow", "capsuleColliderOffsetField");
  string $capsuleColliderPivotMenuGrp = getUIControl("nkBdnEditorWindow", "capsuleColliderPivotMenuGrp");
  string $infinitePlaneColliderFrame = getUIControl("nkBdnEditorWindow", "infinitePlaneColliderFrame");
  string $infinitePlaneColliderWidthField = getUIControl("nkBdnEditorWindow", "infinitePlaneColliderWidthField");
  string $infinitePlaneColliderHeightField = getUIControl("nkBdnEditorWindow", "infinitePlaneColliderHeightField");
  string $sphereColliderFrame = getUIControl("nkBdnEditorWindow", "sphereColliderFrame");
  string $sphereColliderRadiusField = getUIControl("nkBdnEditorWindow", "sphereColliderRadiusField");

  string $capsuleColliderNodes[];
  string $infinitePlaneColliderNodes[];
  string $sphereColliderNodes[];

  string $colliderNodes[] = getSelectedAllColliderNodes("");
  for ($colliderNode in $colliderNodes) {
    string $colliderType = getColliderType($colliderNode);
    if ($colliderType == "capsule") {
      $capsuleColliderNodes[`size $capsuleColliderNodes`] = $colliderNode;
    }
    else if ($colliderType == "infinitePlane") {
      $infinitePlaneColliderNodes[`size $infinitePlaneColliderNodes`] = $colliderNode;
    }
    else if ($colliderType == "sphere") {
      $sphereColliderNodes[`size $sphereColliderNodes`] = $colliderNode;
    }
  }

  int $numCapsuleColliderNodes = `size $capsuleColliderNodes`;
  int $numInfinitePlaneColliderNodes = `size $infinitePlaneColliderNodes`;
  int $numSphereColliderNodes = `size $sphereColliderNodes`;
  // print("  numCapsuleColliderNodes      :" + $numCapsuleColliderNodes + "\n"); // debug
  // print("  numInfinitePlaneColliderNodes:" + $numInfinitePlaneColliderNodes + "\n"); // debug
  // print("  numSphereColliderNodes       :" + $numSphereColliderNodes + "\n"); // debug

  int $containsCapsule = $numCapsuleColliderNodes > 0;
  int $containsInfinitePlane = $numInfinitePlaneColliderNodes > 0;
  int $containsSphere = $numSphereColliderNodes > 0;
  eInt("frameLayout", "-vis", $containsCapsule, $capsuleColliderFrame);
  eInt("frameLayout", "-vis", $containsInfinitePlane, $infinitePlaneColliderFrame);
  eInt("frameLayout", "-vis", $containsSphere, $sphereColliderFrame);

  float $capsuleRadiusA = 0.5;
  float $capsuleRadiusB = 0.5;
  float $capsuleLength = 2.0;
  float $capsuleOffset = 0.0;
  int $capsulePivot = 0;
  if ($containsCapsule) {
    string $lastNode = $capsuleColliderNodes[$numCapsuleColliderNodes - 1];
    $capsuleRadiusA = getFloatAttribute($lastNode, "colliderRadiusA", $capsuleRadiusA);
    $capsuleRadiusB = getFloatAttribute($lastNode, "colliderRadiusB", $capsuleRadiusB);
    $capsuleLength = getFloatAttribute($lastNode, "colliderLength", $capsuleLength);
    $capsuleOffset = getFloatAttribute($lastNode, "colliderOffset", $capsuleOffset);
    $capsulePivot = getIntAttribute($lastNode, "colliderPivot", $capsulePivot);
  }
  // print("  capsuleRadiusA:" + $capsuleRadiusA + "\n"); // debug
  // print("  capsuleRadiusB:" + $capsuleRadiusB + "\n"); // debug
  // print("  capsuleLength :" + $capsuleLength + "\n"); // debug
  // print("  capsuleOffset :" + $capsuleOffset + "\n"); // debug
  // print("  capsulePivot  :" + $capsulePivot + "\n"); // debug
  eFloat("floatFieldGrp", "-v1", $capsuleRadiusA, $capsuleColliderRadiusAField);
  eFloat("floatFieldGrp", "-v1", $capsuleRadiusB, $capsuleColliderRadiusBField);
  eFloat("floatFieldGrp", "-v1", $capsuleLength, $capsuleColliderLengthField);
  eFloat("floatFieldGrp", "-v1", $capsuleOffset, $capsuleColliderOffsetField);
  eIndex("optionMenuGrp", "-sl", $capsulePivot, $capsuleColliderPivotMenuGrp);

  float $infinitePlaneWidth = 1.0;
  float $infinitePlaneHeight = 1.0;
  if ($containsInfinitePlane) {
    string $lastNode = $infinitePlaneColliderNodes[$numInfinitePlaneColliderNodes - 1];
    $infinitePlaneWidth = getFloatAttribute($lastNode, "colliderWidth", $infinitePlaneWidth);
    $infinitePlaneHeight = getFloatAttribute($lastNode, "colliderHeight", $infinitePlaneHeight);
  }
  // print("  infinitePlaneWidth :" + $infinitePlaneWidth + "\n"); // debug
  // print("  infinitePlaneHeight:" + $infinitePlaneHeight + "\n"); // debug
  eFloat("floatFieldGrp", "-v1", $infinitePlaneWidth, $infinitePlaneColliderWidthField);
  eFloat("floatFieldGrp", "-v1", $infinitePlaneHeight, $infinitePlaneColliderHeightField);

  float $sphereRadius = 0.5;
  if ($containsSphere) {
    string $lastNode = $sphereColliderNodes[$numSphereColliderNodes - 1];
    $sphereRadius = getFloatAttribute($lastNode, "colliderRadius", $sphereRadius);
  }
  // print("  sphereRadius:" + $sphereRadius + "\n"); // debug
  eFloat("floatFieldGrp", "-v1", $sphereRadius, $sphereColliderRadiusField);
}

/*-
@returns <>
*/
proc updateForceAttributeUI() {
  // print("updateForceAttributeUI\n"); // debug
  string $forceVectorRadioButton = getUIControl("nkBdnEditorWindow", "forceVectorRadioButton");
  string $invertForceVectorCheckBox = getUIControl("nkBdnEditorWindow", "invertForceVectorCheckBox");

  int $forceVectorIndex = 1;
  int $invertForceVector = false;

  string $forceVectorNodes[] = getSelectedForceVectorNodes();
  int $numForceVectorNodes = `size $forceVectorNodes`;
  if ($numForceVectorNodes > 0) {
    string $lastNode = $forceVectorNodes[$numForceVectorNodes - 1];
    if (isBdnType($lastNode, "force")) {
      float $forceVector[] = getFloat3Attribute($lastNode, "input1", {0.0, 1.0, 0.0});
      if ($forceVector[0] != 0.0) {
        $forceVectorIndex = 0;
      }
      else if ($forceVector[1] != 0.0) {
        $forceVectorIndex = 1;
      }
      else if ($forceVector[2] != 0.0) {
        $forceVectorIndex = 2;
      }
      $invertForceVector = $forceVector[$forceVectorIndex] < 0;
    }
  }

  eIndex("radioButtonGrp", "-sl", $forceVectorIndex, $forceVectorRadioButton);
  eInt("checkBoxGrp", "-v1", $invertForceVector, $invertForceVectorCheckBox);
}

// -----------------------------------------------------------------------------
/*-
@param $node <string>
@returns <string>
*/
proc string makeListItemLabel(string $node) {
  string $label;
  if (isNodeReferenced($node)) $label += "^";
  if (isBdnType($node, "alt")) $label += "#";
  $label += toShortName($node);
  return $label;
}

/*-
@param $bdnNodes <string[]>
@returns <>
*/
proc updateDynamicsNodeList(string $bdnNodes[]) {
  // print("updateDynamicsNodeList\n"); // debug
  // print("  bdnNodes:{\n    " + stringArrayToString($bdnNodes, ",\n    ") + "\n  }\n"); // debug
  string $dynamicsNodeList = getUIControl("nkBdnEditorWindow", "dynamicsNodeList");

  string $dynamicsNodes[];
  for ($bdnNode in $bdnNodes) {
    $dynamicsNodes = stringArrayCatenate(
      $dynamicsNodes,
      getDestConnections($bdnNode, {"outputRotate"}, "", {}, {})
    );
  }

  executeUIControl("textScrollList", "-ra", $dynamicsNodeList);
  for ($dynamicsNode in $dynamicsNodes) {
    textScrollList -e
        -a (makeListItemLabel($dynamicsNode))
        -utg $dynamicsNode
        $dynamicsNodeList;
  }
}

/*-
@param $bdnNodes <string[]>
@returns <>
*/
proc updateTargetNodeList(string $bdnNodes[]) {
  // print("updateTargetNodeList\n"); // debug
  // print("  bdnNodes:{\n    " + stringArrayToString($bdnNodes, ",\n    ") + "\n  }\n"); // debug
  string $targetNodeList = getUIControl("nkBdnEditorWindow", "targetNodeList");

  string $targetNodes[];
  for ($bdnNode in $bdnNodes) {
    $targetNodes = stringArrayCatenate(
      $targetNodes,
      getSourceConnections($bdnNode, {"rotationOffset"}, "", {}, {})
    );
  }

  executeUIControl("textScrollList", "-ra", $targetNodeList);
  for ($targetNode in $targetNodes) {
    textScrollList -e
        -a (makeListItemLabel($targetNode))
        -utg $targetNode
        $targetNodeList;
  }
}

/*-
@param $bdnNodes <string[]>
@returns <>
*/
proc updateInfluencedColliderNodeList(string $bdnNodes[]) {
  // print("updateInfluencedColliderNodeList\n"); // debug
  // print("  bdnNodes:{\n    " + stringArrayToString($bdnNodes, ",\n    ") + "\n  }\n"); // debug
  string $influencedColliderNodeList = getUIControl("nkBdnEditorWindow", "influencedColliderNodeList");

  // ToDo: bdnTypeによる判定ではなく全ての入力アトリビュートを調べてより汎用的な処理にする

  string $influencedColliderNodes[];
  for ($bdnNode in $bdnNodes) {
    string $sourceNodes[] = getSourceConnections($bdnNode, {}, "", {}, {});
    for ($sourceNode in $sourceNodes) {
      if (!isBdnType($sourceNode, "collider")) continue;

      $influencedColliderNodes[`size $influencedColliderNodes`] = $sourceNode;
    }
  }
  $influencedColliderNodes = stringArrayRemoveDuplicates($influencedColliderNodes);
  // print("  influencedColliderNodes:{\n    " + stringArrayToString($influencedColliderNodes, ",\n    ") + "\n  }\n"); // debug

  executeUIControl("textScrollList", "-ra", $influencedColliderNodeList);
  for ($influencedColliderNode in $influencedColliderNodes) {
    textScrollList -e
        -a (makeListItemLabel($influencedColliderNode))
        -utg $influencedColliderNode
        $influencedColliderNodeList;
  }
}

/*-
@returns <>
*/
proc updateAllColliderNodeList() {
  // print("updateAllColliderNodeList\n"); // debug
  string $allColliderNodeList = getUIControl("nkBdnEditorWindow", "allColliderNodeList");

  string $allColliderNodes[] = gatherColliderNodes(false);
  // print("  allColliderNodes:{\n    " + stringArrayToString($allColliderNodes, ",\n    ") + "\n  }\n"); // debug

  // ToDo: 選択の引継ぎ処理

  executeUIControl("textScrollList", "-ra", $allColliderNodeList);
  for ($allColliderNode in $allColliderNodes) {
    textScrollList -e
        -a (makeListItemLabel($allColliderNode))
        -utg $allColliderNode
        $allColliderNodeList;
  }
  updateColliderAttributeUI();
}

/*-
@param $bdnNodes <string[]>
@returns <>
*/
proc updateMeshNodeList(string $bdnNodes[]) {
  // print("updateMeshNodeList\n"); // debug
  // print("  bdnNodes:{\n    " + stringArrayToString($bdnNodes, ",\n    ") + "\n  }\n"); // debug
  string $meshNodeList = getUIControl("nkBdnEditorWindow", "meshNodeList");

  string $meshNodes[];
  for ($bdnNode in $bdnNodes) {
    int $size = `getAttr -s ($bdnNode + ".meshCollider")`;
    for ($i = 0; $i < $size; $i++) {
      $meshNodes = stringArrayCatenate(
        $meshNodes,
        getSourceConnections(
          $bdnNode,
          {"meshCollider[" + $i + "]"},
          "", {}, {}
        )
      );
    }
  }
  $meshNodes = stringArrayRemoveDuplicates($meshNodes);
  // print("  meshNodes:{\n    " + stringArrayToString($meshNodes, ",\n    ") + "\n  }\n"); // debug

  executeUIControl("textScrollList", "-ra", $meshNodeList);
  for ($meshNode in $meshNodes) {
    textScrollList -e
        -a (makeListItemLabel($meshNode))
        -utg $meshNode
        $meshNodeList;
  }
}

/*-
@param $bdnNodes <string[]>
@returns <>
*/
proc updateForceNodeList(string $bdnNodes[]) {
  // print("updateForceNodeList\n"); // debug
  // print("  bdnNodes:{\n    " + stringArrayToString($bdnNodes, ",\n    ") + "\n  }\n"); // debug
  string $forceNodeList = getUIControl("nkBdnEditorWindow", "forceNodeList");

  string $transformNodes[];
  for ($bdnNode in $bdnNodes) {
    string $transformNode = getForceNodeFromBdn($bdnNode);
    if (isType($transformNode, {"transform"}, false)) {
      $transformNodes[`size $transformNodes`] = $transformNode;
    }
  }
  $transformNodes = stringArrayRemoveDuplicates($transformNodes);
  // print("  transformNodes:{\n    " + stringArrayToString($transformNodes, ",\n    ") + "\n  }\n"); // debug

  executeUIControl("textScrollList", "-ra", $forceNodeList);
  for ($transformNode in $transformNodes) {
    textScrollList -e
        -a (makeListItemLabel($transformNode))
        -utg $transformNode
        $forceNodeList;
  }
  updateForceAttributeUI();
}

/*-
@param $bdnNodes <string[]>
@returns <>
*/
proc updateOffsetNodeList(string $bdnNodes[]) {
  // print("updateOffsetNodeList\n"); // debug
  // print("  bdnNodes:{\n    " + stringArrayToString($bdnNodes, ",\n    ") + "\n  }\n"); // debug
  string $offsetNodeList = getUIControl("nkBdnEditorWindow", "offsetNodeList");

  string $offsetNodes[];
  for ($bdnNode in $bdnNodes) {
    $offsetNodes = stringArrayCatenate(
      $offsetNodes,
      getSourceConnections($bdnNode, {"offsetMatrix"}, "", {}, {})
    );
  }
  $offsetNodes = stringArrayRemoveDuplicates($offsetNodes);
  // print("  offsetNodes:{\n    " + stringArrayToString($offsetNodes, ",\n    ") + "\n  }\n"); // debug

  executeUIControl("textScrollList", "-ra", $offsetNodeList);
  for ($offsetNode in $offsetNodes) {
    textScrollList -e
        -a (makeListItemLabel($offsetNode))
        -utg $offsetNode
        $offsetNodeList;
  }
}

/*-
@param $bdnNodes <string[]>
@returns <>
*/
proc updateBindNodeList(string $bdnNodes[]) {
  // print("updateBindNodeList\n"); // debug
  // print("  bdnNodes:{\n    " + stringArrayToString($bdnNodes, ",\n    ") + "\n  }\n"); // debug
  string $bindNodeList = getUIControl("nkBdnEditorWindow", "bindNodeList");

  string $bindNodes[];
  for ($bdnNode in $bdnNodes) {
    string $dynamicsNodes[] = getDestConnections($bdnNode, {"outputRotate"}, "", {}, {});
    for ($dynamicsNode in $dynamicsNodes) {
      $bindNodes = stringArrayCatenate(
        $bindNodes,
        getSourceConnections($dynamicsNode, {"bdnBindTarget"}, "", {}, {})
      );
    }
  }
  $bindNodes = stringArrayRemoveDuplicates($bindNodes);
  // print("  bindNodes:{\n    " + stringArrayToString($bindNodes, ",\n    ") + "\n  }\n"); // debug

  executeUIControl("textScrollList", "-ra", $bindNodeList);
  for ($bindNode in $bindNodes) {
    textScrollList -e
        -a (makeListItemLabel($bindNode))
        -utg $bindNode
        $bindNodeList;
  }
}

/*-
@param $shouldUpdateAllColliderNodeList <boolean>
@returns <>
*/
proc updateBdnRelatedNodeList(int $shouldUpdateAllColliderNodeList) {
  // print("updateBdnRelatedNodeList\n"); // debug
  // print("  shouldUpdateAllColliderNodeList:" + $shouldUpdateAllColliderNodeList + "\n"); // debug
  string $bdnRelatedNodeTab = getUIControl("nkBdnEditorWindow", "bdnRelatedNodeTab");
  string $selectedTabIndex = qIndex("tabLayout", "-sti", $bdnRelatedNodeTab);
  // print("  selectedTabIndex:" + $selectedTabIndex + "\n"); // debug

  string $bdnNodes[] = getSelectedBdnNodes();
  if ($selectedTabIndex == 0) {
    updateDynamicsNodeList($bdnNodes);
    updateTargetNodeList($bdnNodes);
  }
  else if ($selectedTabIndex == 1) {
    updateInfluencedColliderNodeList($bdnNodes);
    if ($shouldUpdateAllColliderNodeList) {
      updateAllColliderNodeList();
    }
  }
  else if ($selectedTabIndex == 2) {
    updateMeshNodeList($bdnNodes);
  }
  else if ($selectedTabIndex == 3) {
    updateForceNodeList($bdnNodes);
  }
  else if ($selectedTabIndex == 4) {
    updateOffsetNodeList($bdnNodes);
  }
  else if ($selectedTabIndex == 5) {
    updateBindNodeList($bdnNodes);
  }
}

/*-
@returns <>
*/
proc updateBdnNodeList() {
  // print("updateBdnNodeList\n"); // debug
  string $bdnNodeList = getUIControl("nkBdnEditorWindow", "bdnNodeList");

  // ToDo: 選択の引継ぎ処理

  executeUIControl("textScrollList", "-ra", $bdnNodeList);

  // BDNグループをシングルトン化
  mergeEditableBdnGroupNodes();

  if (isBdnPluginLoaded()) {
    string $bdnNodes[] = nsort(gatherBdnNodes(false));
    // print("  bdnNodes:{\n    " + stringArrayToString($bdnNodes, ",\n    ") + "\n  }\n"); // debug
    for ($bdnNode in $bdnNodes) {
      textScrollList -e
          -a (makeListItemLabel($bdnNode))
          -utg $bdnNode
          $bdnNodeList;
    }
  }
  updateBdnAttributeUI();
  updateBdnRelatedNodeList(true);
}

// -----------------------------------------------------------------------------
// UIコントロールイベントハンドラ
// -----------------------------------------------------------------------------
/*-
@returns <>
*/
proc nkBdnEditorWindowClosed() {
  // print("nkBdnEditorWindowClosed\n"); // debug
  unregisterEventJob();
  unsubscribeMainWindowObservers();
  removeUIControls("nkBdnEditorWindow", "");
}

/*-
@returns <>
*/
proc resetWindowMenuItemSelected() {
  // print("resetWindowMenuItemSelected\n"); // debug
  windowPrefRemove("window", "nkBdnEditorWindow");
  nkBdnEditor();
}

/*-
@returns <>
*/
proc quitMenuItemSelected() {
  // print("quitMenuItemSelected\n"); // debug
  string $nkBdnEditorWindow = getUIControl("nkBdnEditorWindow", "nkBdnEditorWindow");
  // print("  nkBdnEditorWindow:" + $nkBdnEditorWindow + "\n"); // debug
  windowClose($nkBdnEditorWindow);
}

/*-
@returns <>
*/
proc refreshMenuItemSelected() {
  // print("refreshMenuItemSelected\n"); // debug
  updateBdnNodeList();
}

/*-
@returns <>
*/
proc aboutMenuItemSelected() {
  // print("aboutMenuItemSelected\n"); // debug
  confirmDialog
      -b "OK"
      -db "OK"
      -m (
        "nkBdnEditor " + (nkBdnEditorVersion())
            + "\n\nMIT License\nhttps://github.com/imaoki/nkBdnEditor"
            + "\n\nboneDynamicsNode " + (getBdnPluginVersion())
            + "\nCopyright (c) 2024 Hiroyuki Akasaki"
            + "\nhttps://github.com/akasaki1211/boneDynamicsNode"
      )
      -p (getParentableWindow("nkBdnEditorWindow"))
      -t "About - nkBdnEditor";
}

/*-
@returns <>
*/
proc selectBdnNodesButtonPressed() {
  // print("selectBdnNodesButtonPressed\n"); // debug
  select -r (getSelectedBdnNodes());
}

/*-
@returns <>
*/
proc bdnNodeListDoubleClicked() {
  // print("bdnNodeListDoubleClicked\n"); // debug
  select -r (getSelectedBdnNodes());
}

/*-
@returns <>
*/
proc bdnNodeListSelected() {
  // print("bdnNodeListSelected\n"); // debug
  updateBdnAttributeUI();
  updateBdnRelatedNodeList(false);
}

/*-
@returns <>
*/
proc substituteBdnNodesButtonPressed() {
  // print("substituteBdnNodesButtonPressed\n"); // debug
  string $altNodes[] = substituteBdnNodes(gatherBdnNodes(false));
  // print("  altNodes:{\n    " + stringArrayToString($altNodes, ",\n    ") + "\n  }\n"); // debug
  select -r $altNodes;
}

/*-
@returns <>
*/
proc restoreBdnNodesButtonPressed() {
  // print("restoreBdnNodesButtonPressed\n"); // debug
  string $bdnNodes[] = restoreBdnNodes(gatherBdnNodes(false));
  // print("  bdnNodes:{\n    " + stringArrayToString($bdnNodes, ",\n    ") + "\n  }\n"); // debug
  select -r $bdnNodes;
}

/*-
@returns <>
*/
proc bdnAttributeInitializeButtonPressed() {
  // print("bdnAttributeInitializeButtonPressed\n"); // debug
  global string $nkBdnEditorDefaultBdnAttribute;
  applyDictToBdnAttributes($nkBdnEditorDefaultBdnAttribute, getSelectedBdnNodes());
}

/*-
@returns <>
*/
proc bdnAttributeExportButtonPressed() {
  // print("bdnAttributeExportButtonPressed\n"); // debug
  exportBdnAttributes(getSelectedBdnNodes(), "");
}

/*-
@returns <>
*/
proc bdnAttributeImportButtonPressed() {
  // print("bdnAttributeImportButtonPressed\n"); // debug
  importBdnAttributes(getSelectedBdnNodes(), "");
}

/*-
@returns <>
*/
proc bdnAttributeCopyButtonPressed() {
  // print("bdnAttributeCopyButtonPressed\n"); // debug
  copyBdnAttributes(getSelectedBdnNodes());
}

/*-
@returns <>
*/
proc bdnAttributePasteButtonPressed() {
  // print("bdnAttributePasteButtonPressed\n"); // debug
  pasteBdnAttributes(getSelectedBdnNodes());
}

/*-
@returns <>
*/
proc bdnEnableCheckBoxChanged() {
  // print("bdnEnableCheckBoxChanged\n"); // debug
  string $bdnEnableCheckBox = getUIControl("nkBdnEditorWindow", "bdnEnableCheckBox");
  setIntBdnAttribute(
    getSelectedBdnNodes(),
    "enable",
    qInt("checkBoxGrp", "-v1", $bdnEnableCheckBox)
  );
}

/*-
@returns <>
*/
proc bdnResetTimeFieldChanged() {
  // print("bdnResetTimeFieldChanged\n"); // debug
  string $bdnResetTimeField = getUIControl("nkBdnEditorWindow", "bdnResetTimeField");
  setFloatBdnAttribute(
    getSelectedBdnNodes(),
    "resetTime",
    qFloat("floatFieldGrp", "-v1", $bdnResetTimeField)
  );
}

/*-
@returns <>
*/
proc bdnFpsFieldChanged() {
  // print("bdnFpsFieldChanged\n"); // debug
  string $bdnFpsField = getUIControl("nkBdnEditorWindow", "bdnFpsField");
  setFloatBdnAttribute(
    getSelectedBdnNodes(),
    "fps",
    qFloat("floatFieldGrp", "-v1", $bdnFpsField)
  );
}

/*-
@returns <>
*/
proc bdnOffsetMatrixWeightFieldChanged() {
  // print("bdnOffsetMatrixWeightFieldChanged\n"); // debug
  string $bdnOffsetMatrixWeightField = getUIControl("nkBdnEditorWindow", "bdnOffsetMatrixWeightField");
  setFloatBdnAttribute(
    getSelectedBdnNodes(),
    "offsetMatrixWeight",
    qFloat("floatFieldGrp", "-v1", $bdnOffsetMatrixWeightField)
  );
}

/*-
@returns <>
*/
proc bdnDampingFieldChanged() {
  // print("bdnDampingFieldChanged\n"); // debug
  string $bdnDampingField = getUIControl("nkBdnEditorWindow", "bdnDampingField");
  setFloatBdnAttribute(
    getSelectedBdnNodes(),
    "damping",
    qFloat("floatFieldGrp", "-v1", $bdnDampingField)
  );
}

/*-
@returns <>
*/
proc bdnElasticityFieldChanged() {
  // print("bdnElasticityFieldChanged\n"); // debug
  string $bdnElasticityField = getUIControl("nkBdnEditorWindow", "bdnElasticityField");
  setFloatBdnAttribute(
    getSelectedBdnNodes(),
    "elasticity",
    qFloat("floatFieldGrp", "-v1", $bdnElasticityField)
  );
}

/*-
@returns <>
*/
proc elasticForceFunctionMenuGrpChanged() {
  // print("elasticForceFunctionMenuGrpChanged\n"); // debug
  string $elasticForceFunctionMenuGrp = getUIControl("nkBdnEditorWindow", "elasticForceFunctionMenuGrp");
  setIntBdnAttribute(
    getSelectedBdnNodes(),
    "elasticForceFunction",
    qIndex("optionMenuGrp", "-sl", $elasticForceFunctionMenuGrp)
  );
}

/*-
@returns <>
*/
proc bdnStiffnessFieldChanged() {
  // print("bdnStiffnessFieldChanged\n"); // debug
  string $bdnStiffnessField = getUIControl("nkBdnEditorWindow", "bdnStiffnessField");
  setFloatBdnAttribute(
    getSelectedBdnNodes(),
    "stiffness",
    qFloat("floatFieldGrp", "-v1", $bdnStiffnessField)
  );
}

/*-
@returns <>
*/
proc bdnMassFieldChanged() {
  // print("bdnMassFieldChanged\n"); // debug
  string $bdnMassField = getUIControl("nkBdnEditorWindow", "bdnMassField");
  setFloatBdnAttribute(
    getSelectedBdnNodes(),
    "mass",
    qFloat("floatFieldGrp", "-v1", $bdnMassField)
  );
}

/*-
@returns <>
*/
proc bdnGravityXFieldChanged() {
  // print("bdnGravityXFieldChanged\n"); // debug
  string $bdnGravityXField = getUIControl("nkBdnEditorWindow", "bdnGravityXField");
  setFloatBdnAttribute(
    getSelectedBdnNodes(),
    "gravityX",
    qFloat("floatFieldGrp", "-v1", $bdnGravityXField)
  );
}

/*-
@returns <>
*/
proc bdnGravityYFieldChanged() {
  // print("bdnGravityYFieldChanged\n"); // debug
  string $bdnGravityYField = getUIControl("nkBdnEditorWindow", "bdnGravityYField");
  setFloatBdnAttribute(
    getSelectedBdnNodes(),
    "gravityY",
    qFloat("floatFieldGrp", "-v1", $bdnGravityYField)
  );
}

/*-
@returns <>
*/
proc bdnGravityZFieldChanged() {
  // print("bdnGravityZFieldChanged\n"); // debug
  string $bdnGravityZField = getUIControl("nkBdnEditorWindow", "bdnGravityZField");
  setFloatBdnAttribute(
    getSelectedBdnNodes(),
    "gravityZ",
    qFloat("floatFieldGrp", "-v1", $bdnGravityZField)
  );
}

/*-
@returns <>
*/
proc bdnGravityMultiplyFieldChanged() {
  // print("bdnGravityMultiplyFieldChanged\n"); // debug
  string $bdnGravityMultiplyField = getUIControl("nkBdnEditorWindow", "bdnGravityMultiplyField");
  setFloatBdnAttribute(
    getSelectedBdnNodes(),
    "gravityMultiply",
    qFloat("floatFieldGrp", "-v1", $bdnGravityMultiplyField)
  );
}

/*-
@returns <>
*/
proc bdnAdditionalForceScaleFieldChanged() {
  // print("bdnAdditionalForceScaleFieldChanged\n"); // debug
  string $bdnAdditionalForceScaleField = getUIControl("nkBdnEditorWindow", "bdnAdditionalForceScaleField");
  setFloatBdnAttribute(
    getSelectedBdnNodes(),
    "additionalForceScale",
    qFloat("floatFieldGrp", "-v1", $bdnAdditionalForceScaleField)
  );
}

/*-
@returns <>
*/
proc bdnEnableTurbulenceCheckBoxChanged() {
  // print("bdnEnableTurbulenceCheckBoxChanged\n"); // debug
  string $bdnEnableTurbulenceCheckBox = getUIControl("nkBdnEditorWindow", "bdnEnableTurbulenceCheckBox");
  setIntBdnAttribute(
    getSelectedBdnNodes(),
    "enableTurbulence",
    qInt("checkBoxGrp", "-v1", $bdnEnableTurbulenceCheckBox)
  );
}

/*-
@returns <>
*/
proc bdnTurbulenceSeedFieldChanged() {
  // print("bdnTurbulenceSeedFieldChanged\n"); // debug
  string $bdnTurbulenceSeedField = getUIControl("nkBdnEditorWindow", "bdnTurbulenceSeedField");
  setIntBdnAttribute(
    getSelectedBdnNodes(),
    "turbulenceSeed",
    qInt("intFieldGrp", "-v1", $bdnTurbulenceSeedField)
  );
}

/*-
@returns <>
*/
proc bdnTurbulenceStrengthFieldChanged() {
  // print("bdnTurbulenceStrengthFieldChanged\n"); // debug
  string $bdnTurbulenceStrengthField = getUIControl("nkBdnEditorWindow", "bdnTurbulenceStrengthField");
  setFloatBdnAttribute(
    getSelectedBdnNodes(),
    "turbulenceStrength",
    qFloat("floatFieldGrp", "-v1", $bdnTurbulenceStrengthField)
  );
}

/*-
@returns <>
*/
proc bdnTurbulenceVectorChangeScaleFieldChanged() {
  // print("bdnTurbulenceVectorChangeScaleFieldChanged\n"); // debug
  string $bdnTurbulenceVectorChangeScaleField = getUIControl("nkBdnEditorWindow", "bdnTurbulenceVectorChangeScaleField");
  setFloatBdnAttribute(
    getSelectedBdnNodes(),
    "turbulenceVectorChangeScale",
    qFloat("floatFieldGrp", "-v1", $bdnTurbulenceVectorChangeScaleField)
  );
}

/*-
@returns <>
*/
proc bdnTurbulenceVectorChangeMaxFieldChanged() {
  // print("bdnTurbulenceVectorChangeMaxFieldChanged\n"); // debug
  string $bdnTurbulenceVectorChangeMaxField = getUIControl("nkBdnEditorWindow", "bdnTurbulenceVectorChangeMaxField");
  setFloatBdnAttribute(
    getSelectedBdnNodes(),
    "turbulenceVectorChangeMax",
    qFloat("floatFieldGrp", "-v1", $bdnTurbulenceVectorChangeMaxField)
  );
}

/*-
@returns <>
*/
proc bdnEnableAngleLimitCheckBoxChanged() {
  // print("bdnEnableAngleLimitCheckBoxChanged\n"); // debug
  string $bdnEnableAngleLimitCheckBox = getUIControl("nkBdnEditorWindow", "bdnEnableAngleLimitCheckBox");
  setIntBdnAttribute(
    getSelectedBdnNodes(),
    "enableAngleLimit",
    qInt("checkBoxGrp", "-v1", $bdnEnableAngleLimitCheckBox)
  );
}

/*-
@returns <>
*/
proc bdnAngleLimitFieldChanged() {
  // print("bdnAngleLimitFieldChanged\n"); // debug
  string $bdnAngleLimitField = getUIControl("nkBdnEditorWindow", "bdnAngleLimitField");
  setFloatBdnAttribute(
    getSelectedBdnNodes(),
    "angleLimit",
    qFloat("floatFieldGrp", "-v1", $bdnAngleLimitField)
  );
}

/*-
@returns <>
*/
proc bdnRadiusFieldChanged() {
  // print("bdnRadiusFieldChanged\n"); // debug
  string $bdnRadiusField = getUIControl("nkBdnEditorWindow", "bdnRadiusField");
  setFloatBdnAttribute(
    getSelectedBdnNodes(),
    "radius",
    qFloat("floatFieldGrp", "-v1", $bdnRadiusField)
  );
}

/*-
@returns <>
*/
proc bdnIterationsFieldChanged() {
  // print("bdnIterationsFieldChanged\n"); // debug
  string $bdnIterationsField = getUIControl("nkBdnEditorWindow", "bdnIterationsField");
  setIntBdnAttribute(
    getSelectedBdnNodes(),
    "iterations",
    qInt("intFieldGrp", "-v1", $bdnIterationsField)
  );
}

/*-
@returns <>
*/
proc bdnEnableGroundColCheckBoxChanged() {
  // print("bdnEnableGroundColCheckBoxChanged\n"); // debug
  string $bdnEnableGroundColCheckBox = getUIControl("nkBdnEditorWindow", "bdnEnableGroundColCheckBox");
  setIntBdnAttribute(
    getSelectedBdnNodes(),
    "enableGroundCol",
    qInt("checkBoxGrp", "-v1", $bdnEnableGroundColCheckBox)
  );
}

/*-
@returns <>
*/
proc bdnGroundHeightFieldChanged() {
  // print("bdnGroundHeightFieldChanged\n"); // debug
  string $bdnGroundHeightField = getUIControl("nkBdnEditorWindow", "bdnGroundHeightField");
  setFloatBdnAttribute(
    getSelectedBdnNodes(),
    "groundHeight",
    qFloat("floatFieldGrp", "-v1", $bdnGroundHeightField)
  );
}

/*-
@returns <>
*/
proc bdnMeshColCutoffFieldChanged() {
  // print("bdnMeshColCutoffFieldChanged\n"); // debug
  string $bdnMeshColCutoffField = getUIControl("nkBdnEditorWindow", "bdnMeshColCutoffField");
  setFloatBdnAttribute(
    getSelectedBdnNodes(),
    "meshColCutoff",
    qFloat("floatFieldGrp", "-v1", $bdnMeshColCutoffField)
  );
}

/*-
@returns <>
*/
proc bdnRelatedNodeTabChanged() {
  // print("bdnRelatedNodeTabChanged\n"); // debug
  updateBdnRelatedNodeList(true);
}

/*-
@returns <>
*/
proc generateDynamicsUnitButtonPressed() {
  // print("generateDynamicsUnitButtonPressed\n"); // debug
  string $dynamicsUnitBranchAimVectorRadioButton = getUIControl("nkBdnEditorWindow", "dynamicsUnitBranchAimVectorRadioButton");
  string $dynamicsUnitBranchUpVectorRadioButton = getUIControl("nkBdnEditorWindow", "dynamicsUnitBranchUpVectorRadioButton");
  string $dynamicsUnitBranchInvertAimVectorCheckBox = getUIControl("nkBdnEditorWindow", "dynamicsUnitBranchInvertAimVectorCheckBox");
  string $dynamicsUnitEndJointOffsetField = getUIControl("nkBdnEditorWindow", "dynamicsUnitEndJointOffsetField");

  string $sourceNodes[] = gatherNodes({"transform"}, false, true, "");
  int $branchAimVectorIndex = qIndex("radioButtonGrp", "-sl", $dynamicsUnitBranchAimVectorRadioButton);
  int $branchUpVectorIndex = qIndex("radioButtonGrp", "-sl", $dynamicsUnitBranchUpVectorRadioButton);
  int $branchInvertAimVector = qInt("checkBoxGrp", "-v1", $dynamicsUnitBranchInvertAimVectorCheckBox);
  float $endJointOffset[] = qFloatArray("floatFieldGrp", "-v", $dynamicsUnitEndJointOffsetField);

  float $branchAimVector[] = {0.0, 0.0, 0.0};
  float $branchUpVector[] = {0.0, 0.0, 0.0};
  $branchAimVector[$branchAimVectorIndex] = ($branchInvertAimVector) ? -1.0 : 1.0;
  $branchUpVector[$branchUpVectorIndex] = 1.0;

  string $dynamicsNodes[] = generateDynamicsUnit(
    $sourceNodes,
    $branchAimVector,
    $branchUpVector,
    $endJointOffset
  );
  // print("  dynamicsNodes:{\n    " + stringArrayToString($dynamicsNodes, ",\n    ") + "\n  }\n"); // debug
  select -r $dynamicsNodes;
}

/*-
@returns <>
*/
proc showDynamicsNodesButtonPressed() {
  // print("showDynamicsNodesButtonPressed\n"); // debug
  batchSetIntAttribute(getSelectedDynamicsNodes(), "visibility", true);
}

/*-
@returns <>
*/
proc hideDynamicsNodesButtonPressed() {
  // print("hideDynamicsNodesButtonPressed\n"); // debug
  batchSetIntAttribute(getSelectedDynamicsNodes(), "visibility", false);
}

/*-
@returns <>
*/
proc selectDynamicsNodesButtonPressed() {
  // print("selectDynamicsNodesButtonPressed\n"); // debug
  select -r (getSelectedDynamicsNodes());
}

/*-
@returns <>
*/
proc dynamicsNodeListDoubleClicked() {
  // print("dynamicsNodeListDoubleClicked\n"); // debug
  select -r (getSelectedDynamicsNodes());
}

/*-
@returns <>
*/
proc dynamicsNodeListSelected() {
  // print("dynamicsNodeListSelected\n"); // debug
}

/*-
@returns <>
*/
proc showTargetNodesButtonPressed() {
  // print("showTargetNodesButtonPressed\n"); // debug
  batchSetIntAttribute(getSelectedTargetNodes(), "visibility", true);
}

/*-
@returns <>
*/
proc hideTargetNodesButtonPressed() {
  // print("hideTargetNodesButtonPressed\n"); // debug
  batchSetIntAttribute(getSelectedTargetNodes(), "visibility", false);
}

/*-
@returns <>
*/
proc selectTargetNodesButtonPressed() {
  // print("selectTargetNodesButtonPressed\n"); // debug
  select -r (getSelectedTargetNodes());
}

/*-
@returns <>
*/
proc targetNodeListDoubleClicked() {
  // print("targetNodeListDoubleClicked\n"); // debug
  select -r (getSelectedTargetNodes());
}

/*-
@returns <>
*/
proc targetNodeListSelected() {
  // print("targetNodeListSelected\n"); // debug
}

/*-
@returns <>
*/
proc createColliderCapsuleButtonPressed() {
  // print("createColliderCapsuleButtonPressed\n"); // debug
  string $createMultipleCollidersCheckBox = getUIControl("nkBdnEditorWindow", "createMultipleCollidersCheckBox");

  string $sourceNodes[];
  if (qInt("checkBox", "-v", $createMultipleCollidersCheckBox)) {
    $sourceNodes = gatherNodes({"transform"}, false, true, "");
    // print("  sourceNodes:{\n    " + stringArrayToString($sourceNodes, ",\n    ") + "\n  }\n"); // debug
  }
  string $colliderNodes[] = createCapsuleCollider($sourceNodes, true);
  // print("  colliderNodes:{\n    " + stringArrayToString($colliderNodes, ",\n    ") + "\n  }\n"); // debug
  select -r $colliderNodes;
}

/*-
@returns <>
*/
proc createColliderInfinitePlaneButtonPressed() {
  // print("createColliderInfinitePlaneButtonPressed\n"); // debug
  string $createMultipleCollidersCheckBox = getUIControl("nkBdnEditorWindow", "createMultipleCollidersCheckBox");

  string $sourceNodes[];
  if (qInt("checkBox", "-v", $createMultipleCollidersCheckBox)) {
    $sourceNodes = gatherNodes({"transform"}, false, true, "");
  }
  string $colliderNodes[] = createInfinitePlaneCollider($sourceNodes);
  // print("  colliderNodes:{\n    " + stringArrayToString($colliderNodes, ",\n    ") + "\n  }\n"); // debug
  select -r $colliderNodes;
}

/*-
@returns <>
*/
proc createColliderSphereButtonPressed() {
  // print("createColliderSphereButtonPressed\n"); // debug
  string $createMultipleCollidersCheckBox = getUIControl("nkBdnEditorWindow", "createMultipleCollidersCheckBox");

  string $sourceNodes[];
  if (qInt("checkBox", "-v", $createMultipleCollidersCheckBox)) {
    $sourceNodes = gatherNodes({"transform"}, false, true, "");
  }
  string $colliderNodes[] = createSphereCollider($sourceNodes);
  // print("  colliderNodes:{\n    " + stringArrayToString($colliderNodes, ",\n    ") + "\n  }\n"); // debug
  select -r $colliderNodes;
}

/*-
@returns <>
*/
proc showInfluencedColliderNodesButtonPressed() {
  // print("showInfluencedColliderNodesButtonPressed\n"); // debug
  batchSetIntAttribute(getSelectedInfluencedColliderNodes(), "visibility", true);
}

/*-
@returns <>
*/
proc hideInfluencedColliderNodesButtonPressed() {
  // print("hideInfluencedColliderNodesButtonPressed\n"); // debug
  batchSetIntAttribute(getSelectedInfluencedColliderNodes(), "visibility", false);
}

/*-
@returns <>
*/
proc selectInfluencedColliderNodesButtonPressed() {
  // print("selectInfluencedColliderNodesButtonPressed\n"); // debug
  select -r (getSelectedInfluencedColliderNodes());
}

/*-
@returns <>
*/
proc influencedColliderNodeListDoubleClicked() {
  // print("influencedColliderNodeListDoubleClicked\n"); // debug
  select -r (getSelectedInfluencedColliderNodes());
}

/*-
@returns <>
*/
proc influencedColliderNodeListSelected() {
  // print("influencedColliderNodeListSelected\n"); // debug
}

/*-
@returns <>
*/
proc removeColliderButtonPressed() {
  // print("removeColliderButtonPressed\n"); // debug
  removeCollider(
    getSelectedInfluencedColliderNodes(),
    getSelectedBdnNodes()
  );
}

/*-
@returns <>
*/
proc allColliderExportButtonPressed() {
  // print("allColliderExportButtonPressed\n"); // debug
  exportColliders(getSelectedAllColliderNodes(""), "");
}

/*-
@returns <>
*/
proc allColliderImportButtonPressed() {
  // print("allColliderImportButtonPressed\n"); // debug
  importColliders("");
}

/*-
@returns <>
*/
proc showAllColliderNodesButtonPressed() {
  // print("showAllColliderNodesButtonPressed\n"); // debug
  batchSetIntAttribute(getSelectedAllColliderNodes(""), "visibility", true);
}

/*-
@returns <>
*/
proc hideAllColliderNodesButtonPressed() {
  // print("hideAllColliderNodesButtonPressed\n"); // debug
  batchSetIntAttribute(getSelectedAllColliderNodes(""), "visibility", false);
}

/*-
@returns <>
*/
proc selectAllColliderNodesButtonPressed() {
  // print("selectAllColliderNodesButtonPressed\n"); // debug
  select -r (getSelectedAllColliderNodes(""));
}

/*-
@returns <>
*/
proc allColliderNodeListDoubleClicked() {
  // print("allColliderNodeListDoubleClicked\n"); // debug
  select -r (getSelectedAllColliderNodes(""));
}

/*-
@returns <>
*/
proc allColliderNodeListSelected() {
  // print("allColliderNodeListSelected\n"); // debug
  updateColliderAttributeUI();
}

/*-
@returns <>
*/
proc appendColliderButtonPressed() {
  // print("appendColliderButtonPressed\n"); // debug
  appendCollider(
    getSelectedAllColliderNodes(""),
    getSelectedBdnNodes()
  );
}

/*-
@returns <>
*/
proc capsuleColliderInitializeButtonPressed() {
  // print("capsuleColliderInitializeButtonPressed\n"); // debug
  global string $nkBdnEditorDefaultCapsuleColliderAttribute;
  string $capsuleColliderSetPlacementAttributesCheckBox = getUIControl("nkBdnEditorWindow", "capsuleColliderSetPlacementAttributesCheckBox");
  applyDictToCapsuleColliderAttributes(
    $nkBdnEditorDefaultCapsuleColliderAttribute,
    getSelectedAllColliderNodes("capsule"),
    qInt("checkBox", "-v", $capsuleColliderSetPlacementAttributesCheckBox)
  );
}

/*-
@returns <>
*/
proc capsuleColliderCopyButtonPressed() {
  // print("capsuleColliderCopyButtonPressed\n"); // debug
  copyCapsuleColliderAttributes(getSelectedAllColliderNodes("capsule"));
}

/*-
@returns <>
*/
proc capsuleColliderPasteButtonPressed() {
  // print("capsuleColliderPasteButtonPressed\n"); // debug
  string $capsuleColliderSetPlacementAttributesCheckBox = getUIControl("nkBdnEditorWindow", "capsuleColliderSetPlacementAttributesCheckBox");
  pasteCapsuleColliderAttributes(
    getSelectedAllColliderNodes("capsule"),
    qInt("checkBox", "-v", $capsuleColliderSetPlacementAttributesCheckBox)
  );
}

/*-
@returns <>
*/
proc capsuleColliderRadiusAFieldChanged() {
  // print("capsuleColliderRadiusAFieldChanged\n"); // debug
  string $capsuleColliderRadiusAField = getUIControl("nkBdnEditorWindow", "capsuleColliderRadiusAField");
  setFloatColliderAttribute(
    getSelectedAllColliderNodes("capsule"),
    "colliderRadiusA",
    qFloat("floatFieldGrp", "-v1", $capsuleColliderRadiusAField)
  );
}

/*-
@returns <>
*/
proc capsuleColliderRadiusBFieldChanged() {
  // print("capsuleColliderRadiusBFieldChanged\n"); // debug
  string $capsuleColliderRadiusBField = getUIControl("nkBdnEditorWindow", "capsuleColliderRadiusBField");
  setFloatColliderAttribute(
    getSelectedAllColliderNodes("capsule"),
    "colliderRadiusB",
    qFloat("floatFieldGrp", "-v1", $capsuleColliderRadiusBField)
  );
}

/*-
@returns <>
*/
proc capsuleColliderLengthFieldChanged() {
  // print("capsuleColliderLengthFieldChanged\n"); // debug
  string $capsuleColliderLengthField = getUIControl("nkBdnEditorWindow", "capsuleColliderLengthField");
  setFloatColliderAttribute(
    getSelectedAllColliderNodes("capsule"),
    "colliderLength",
    qFloat("floatFieldGrp", "-v1", $capsuleColliderLengthField)
  );
}

/*-
@returns <>
*/
proc capsuleColliderOffsetFieldChanged() {
  // print("capsuleColliderOffsetFieldChanged\n"); // debug
  string $capsuleColliderOffsetField = getUIControl("nkBdnEditorWindow", "capsuleColliderOffsetField");
  setFloatColliderAttribute(
    getSelectedAllColliderNodes("capsule"),
    "colliderOffset",
    qFloat("floatFieldGrp", "-v1", $capsuleColliderOffsetField)
  );
}

/*-
@returns <>
*/
proc capsuleColliderPivotMenuGrpChanged() {
  // print("capsuleColliderPivotMenuGrpChanged\n"); // debug
  string $capsuleColliderPivotMenuGrp = getUIControl("nkBdnEditorWindow", "capsuleColliderPivotMenuGrp");
  setIntColliderAttribute(
    getSelectedAllColliderNodes("capsule"),
    "colliderPivot",
    qIndex("optionMenuGrp", "-sl", $capsuleColliderPivotMenuGrp)
  );
}

/*-
@returns <>
*/
proc infinitePlaneColliderInitializeButtonPressed() {
  // print("infinitePlaneColliderInitializeButtonPressed\n"); // debug
  global string $nkBdnEditorDefaultInfinitePlaneColliderAttribute;
  applyDictToInfinitePlaneColliderAttributes(
    $nkBdnEditorDefaultInfinitePlaneColliderAttribute,
    getSelectedAllColliderNodes("infinitePlane")
  );
}

/*-
@returns <>
*/
proc infinitePlaneColliderCopyButtonPressed() {
  // print("infinitePlaneColliderCopyButtonPressed\n"); // debug
  copyInfinitePlaneColliderAttributes(getSelectedAllColliderNodes("infinitePlane"));
}

/*-
@returns <>
*/
proc infinitePlaneColliderPasteButtonPressed() {
  // print("infinitePlaneColliderPasteButtonPressed\n"); // debug
  pasteInfinitePlaneColliderAttributes(getSelectedAllColliderNodes("infinitePlane"));
}

/*-
@returns <>
*/
proc infinitePlaneColliderWidthFieldChanged() {
  // print("infinitePlaneColliderWidthFieldChanged\n"); // debug
  string $infinitePlaneColliderWidthField = getUIControl("nkBdnEditorWindow", "infinitePlaneColliderWidthField");
  setFloatColliderAttribute(
    getSelectedAllColliderNodes("infinitePlane"),
    "colliderWidth",
    qFloat("floatFieldGrp", "-v1", $infinitePlaneColliderWidthField)
  );
}

/*-
@returns <>
*/
proc infinitePlaneColliderHeightFieldChanged() {
  // print("infinitePlaneColliderHeightFieldChanged\n"); // debug
  string $infinitePlaneColliderHeightField = getUIControl("nkBdnEditorWindow", "infinitePlaneColliderHeightField");
  setFloatColliderAttribute(
    getSelectedAllColliderNodes("infinitePlane"),
    "colliderHeight",
    qFloat("floatFieldGrp", "-v1", $infinitePlaneColliderHeightField)
  );
}

/*-
@returns <>
*/
proc sphereColliderInitializeButtonPressed() {
  // print("sphereColliderInitializeButtonPressed\n"); // debug
  global string $nkBdnEditorDefaultSphereColliderAttribute;
  applyDictToSphereColliderAttributes(
    $nkBdnEditorDefaultSphereColliderAttribute,
    getSelectedAllColliderNodes("sphere")
  );
}

/*-
@returns <>
*/
proc sphereColliderCopyButtonPressed() {
  // print("sphereColliderCopyButtonPressed\n"); // debug
  copySphereColliderAttributes(getSelectedAllColliderNodes("sphere"));
}

/*-
@returns <>
*/
proc sphereColliderPasteButtonPressed() {
  // print("sphereColliderPasteButtonPressed\n"); // debug
  pasteSphereColliderAttributes(getSelectedAllColliderNodes("sphere"));
}

/*-
@returns <>
*/
proc sphereColliderRadiusFieldChanged() {
  // print("sphereColliderRadiusFieldChanged\n"); // debug
  string $sphereColliderRadiusField = getUIControl("nkBdnEditorWindow", "sphereColliderRadiusField");
  setFloatColliderAttribute(
    getSelectedAllColliderNodes("sphere"),
    "colliderRadius",
    qFloat("floatFieldGrp", "-v1", $sphereColliderRadiusField)
  );
}

/*-
@returns <>
*/
proc showMeshNodesButtonPressed() {
  // print("showMeshNodesButtonPressed\n"); // debug
  batchSetIntAttribute(getSelectedMeshNodes(), "visibility", true);
}

/*-
@returns <>
*/
proc hideMeshNodesButtonPressed() {
  // print("hideMeshNodesButtonPressed\n"); // debug
  batchSetIntAttribute(getSelectedMeshNodes(), "visibility", false);
}

/*-
@returns <>
*/
proc selectMeshNodesButtonPressed() {
  // print("selectMeshNodesButtonPressed\n"); // debug
  select -r (getSelectedMeshNodes());
}

/*-
@returns <>
*/
proc meshNodeListDoubleClicked() {
  // print("meshNodeListDoubleClicked\n"); // debug
  select -r (getSelectedMeshNodes());
}

/*-
@returns <>
*/
proc meshNodeListSelected() {
  // print("meshNodeListSelected\n"); // debug
}

/*-
@returns <>
*/
proc appendMeshNodesButtonPressed() {
  // print("appendMeshNodesButtonPressed\n"); // debug
  appendMesh(
    gatherMeshNodes(true),
    getSelectedBdnNodes()
  );
}

/*-
@returns <>
*/
proc removeMeshNodesButtonPressed() {
  // print("removeMeshNodesButtonPressed\n"); // debug
  removeMesh(
    getSelectedMeshNodes(),
    getSelectedBdnNodes()
  );
}

/*-
@returns <>
*/
proc showForceNodesButtonPressed() {
  // print("showForceNodesButtonPressed\n"); // debug
  batchSetIntAttribute(getSelectedForceNodes(), "visibility", true);
}

/*-
@returns <>
*/
proc hideForceNodesButtonPressed() {
  // print("hideForceNodesButtonPressed\n"); // debug
  batchSetIntAttribute(getSelectedForceNodes(), "visibility", false);
}

/*-
@returns <>
*/
proc selectForceNodesButtonPressed() {
  // print("selectForceNodesButtonPressed\n"); // debug
  select -r (getSelectedForceNodes());
}

/*-
@returns <>
*/
proc forceNodeListDoubleClicked() {
  // print("forceNodeListDoubleClicked\n"); // debug
  select -r (getSelectedForceNodes());
}

/*-
@returns <>
*/
proc forceNodeListSelected() {
  // print("forceNodeListSelected\n"); // debug
  updateForceAttributeUI();
}

/*-
@returns <>
*/
proc connectForceNodeButtonPressed() {
  // print("connectForceNodeButtonPressed\n"); // debug
  string $forceVectorRadioButton = getUIControl("nkBdnEditorWindow", "forceVectorRadioButton");
  string $invertForceVectorCheckBox = getUIControl("nkBdnEditorWindow", "invertForceVectorCheckBox");

  int $forceVectorIndex = qIndex("radioButtonGrp", "-sl", $forceVectorRadioButton);
  int $invertForceVector = qInt("checkBoxGrp", "-v1", $invertForceVectorCheckBox);
  float $forceVector[] = {0.0, 0.0, 0.0};
  $forceVector[$forceVectorIndex] = ($invertForceVector) ? -1.0 : 1.0;

  connectForce(
    gatherNodes({"transform"}, false, true, ""),
    getSelectedBdnNodes(),
    $forceVector
  );
}

/*-
@returns <>
*/
proc disconnectForceNodeButtonPressed() {
  // print("disconnectForceNodeButtonPressed\n"); // debug
  disconnectForce(
    getSelectedForceNodes(),
    getSelectedBdnNodes()
  );
}

/*-
@returns <>
*/
proc forceVectorRadioButtonOnned() {
  // print("forceVectorRadioButtonOnned\n"); // debug
  string $forceVectorRadioButton = getUIControl("nkBdnEditorWindow", "forceVectorRadioButton");
  string $invertForceVectorCheckBox = getUIControl("nkBdnEditorWindow", "invertForceVectorCheckBox");

  int $forceVectorIndex = qIndex("radioButtonGrp", "-sl", $forceVectorRadioButton);
  int $invertForceVector = qInt("checkBoxGrp", "-v1", $invertForceVectorCheckBox);
  float $forceVector[] = {0.0, 0.0, 0.0};
  $forceVector[$forceVectorIndex] = ($invertForceVector) ? -1.0 : 1.0;

  setForceVectorAttribute(getSelectedForceVectorNodes(), $forceVector);
}

/*-
@returns <>
*/
proc invertForceVectorCheckBoxChanged() {
  // print("invertForceVectorCheckBoxChanged\n"); // debug
  string $forceVectorRadioButton = getUIControl("nkBdnEditorWindow", "forceVectorRadioButton");
  string $invertForceVectorCheckBox = getUIControl("nkBdnEditorWindow", "invertForceVectorCheckBox");

  int $forceVectorIndex = qIndex("radioButtonGrp", "-sl", $forceVectorRadioButton);
  int $invertForceVector = qInt("checkBoxGrp", "-v1", $invertForceVectorCheckBox);
  float $forceVector[] = {0.0, 0.0, 0.0};
  $forceVector[$forceVectorIndex] = ($invertForceVector) ? -1.0 : 1.0;

  setForceVectorAttribute(getSelectedForceVectorNodes(), $forceVector);
}

/*-
@returns <>
*/
proc showOffsetNodesButtonPressed() {
  // print("showOffsetNodesButtonPressed\n"); // debug
  batchSetIntAttribute(getSelectedOffsetNodes(), "visibility", true);
}

/*-
@returns <>
*/
proc hideOffsetNodesButtonPressed() {
  // print("hideOffsetNodesButtonPressed\n"); // debug
  batchSetIntAttribute(getSelectedOffsetNodes(), "visibility", false);
}

/*-
@returns <>
*/
proc selectOffsetNodesButtonPressed() {
  // print("selectOffsetNodesButtonPressed\n"); // debug
  select -r (getSelectedOffsetNodes());
}

/*-
@returns <>
*/
proc offsetNodeListDoubleClicked() {
  // print("offsetNodeListDoubleClicked\n"); // debug
  select -r (getSelectedOffsetNodes());
}

/*-
@returns <>
*/
proc offsetNodeListSelected() {
  // print("offsetNodeListSelected\n"); // debug
}

/*-
@returns <>
*/
proc connectOffsetNodeButtonPressed() {
  // print("connectOffsetNodeButtonPressed\n"); // debug
  connectOffset(
    gatherNodes({"transform"}, false, true, ""),
    getSelectedBdnNodes()
  );
}

/*-
@returns <>
*/
proc disconnectOffsetNodeButtonPressed() {
  // print("disconnectOffsetNodeButtonPressed\n"); // debug
  disconnectOffset(
    getSelectedOffsetNodes(),
    getSelectedBdnNodes()
  );
}

/*-
@returns <>
*/
proc showBindNodesButtonPressed() {
  // print("showBindNodesButtonPressed\n"); // debug
  batchSetIntAttribute(getSelectedBindNodes(), "visibility", true);
}

/*-
@returns <>
*/
proc hideBindNodesButtonPressed() {
  // print("hideBindNodesButtonPressed\n"); // debug
  batchSetIntAttribute(getSelectedBindNodes(), "visibility", false);
}

/*-
@returns <>
*/
proc selectBindNodesButtonPressed() {
  // print("selectBindNodesButtonPressed\n"); // debug
  select -r (getSelectedBindNodes());
}

/*-
@returns <>
*/
proc bindNodeListDoubleClicked() {
  // print("bindNodeListDoubleClicked\n"); // debug
  select -r (getSelectedBindNodes());
}

/*-
@returns <>
*/
proc bindNodeListSelected() {
  // print("bindNodeListSelected\n"); // debug
}

/*-
@returns <>
*/
proc bakeButtonPressed() {
  // print("bakeButtonPressed\n"); // debug
  bakeBind(getSelectedBindNodes(), getBakeTimeRange());
}

/*-
@returns <>
*/
proc rebindButtonPressed() {
  // print("rebindButtonPressed\n"); // debug
  rebind(getSelectedBindNodes());
}

// -----------------------------------------------------------------------------
// ウィンドウ定義
// -----------------------------------------------------------------------------
/*-
@returns <>
*/
proc buildMainWindow() {
  // print("buildMainWindow\n"); // debug
  windowClose("nkBdnEditorWindow");

  string $nkBdnEditorWindow = `window
      -mxb false
      -mnb false
      -s true
      -t "nkBdnEditor"
      "nkBdnEditorWindow"`;
    string $outerForm = `formLayout "outerForm"`;
      string $menuBar = `menuBarLayout
          // -bgc 0.25 0.5 0.25
          "menuBar"`;
        string $fileMenu = `menu
            -l "File"
            "fileMenu"`;
          string $resetWindowMenuItem = `menuItem
              -l "Reset Window"
              "resetWindowMenuItem"`;
          menuItem -d true;
          string $quitMenuItem = `menuItem
              -l "Quit"
              "quitMenuItem"`;
        string $viewMenu = `menu
            -l "View"
            "viewMenu"`;
          string $refreshMenuItem = `menuItem
              -l "Refresh"
              "refreshMenuItem"`;
        string $helpMenu = `menu
            -hm true
            -l "Help"
            "helpMenu"`;
          string $aboutMenuItem = `menuItem
              -l "About nkBdnEditor"
              "aboutMenuItem"`;
      setParent ..;

      string $outerPane = `paneLayout
          -cn "vertical2"
          -ps 1 40 100
          -ps 2 60 100
          "outerPane"`;

        string $bdnForm = `formLayout "bdnForm"`;
          string $bdnListFrame = `frameLayout -bgs true -cll false -cl false -l "BoneDynamicsNode List" -mh 4 -mw 8 "bdnListFrame"`;
            string $bdnListPane = `paneLayout
                -cn "horizontal2"
                -ps 1 100 40
                -ps 2 100 60
                "bdnListPane"`;

              string $bdnListForm = `formLayout "bdnListForm"`;
                string $bdnListToolRow = `rowLayout -adj 1 -nc 2 "bdnListToolRow"`;
                  separator -st "none" -vis false;
                  string $selectBdnNodesButton = `iconTextButton
                      -ann "Select"
                      -i "pickObjByType.png"
                      -w 23
                      "selectBdnNodesButton"`;
                setParent ..;
                string $bdnNodeList = `textScrollList -ams true -ekf false "bdnNodeList"`;
                string $substituteBdnNodesButton = `button -ann "Substitute all boneDynamicsNodes with alternative nodes to remove dependence on plug-ins" -l "Substitute" "substituteBdnNodesButton"`;
                string $restoreBdnNodesButton = `button -ann "Restore all alternative nodes to boneDynamicsNode" -l "Restore" "restoreBdnNodesButton"`;
              setParent ..;

              string $bdnAttributeForm = `formLayout "bdnAttributeForm"`;
                string $bdnAttributeFrame = `frameLayout -bgs false -cll false -cl false -l "BDN Attributes" -nbg true "bdnAttributeFrame"`;
                  string $bdnAttributeScroll = `scrollLayout -cr true -pe true -vsb true -w 320 "bdnAttributeScroll"`;
                    string $bdnAttributeColumn = `columnLayout -adj true -rs 0 "bdnAttributeColumn"`;
                      string $bdnAttributeToolRow = `rowLayout -adj 2 -nc 7 "bdnAttributeToolRow"`;
                        string $bdnAttributeInitializeButton = `iconTextButton
                            -ann "Initialize"
                            -i "hsClearView.png"
                            -w 23
                            "bdnAttributeInitButton"`;
                        separator -st "none" -vis false;
                        string $bdnAttributeExportButton = `iconTextButton
                            -ann "Export"
                            -i "fileSave.png"
                            -w 23
                            "bdnAttributeExportButton"`;
                        string $bdnAttributeImportButton = `iconTextButton
                            -ann "Import"
                            -i "fileOpen.png"
                            -w 23
                            "bdnAttributeImportButton"`;
                        separator -h 23 -st "single" -vis true;
                        string $bdnAttributeCopyButton = `iconTextButton
                            -ann "Copy"
                            -i "polyCopyUV.png"
                            -w 23
                            "bdnAttributeCopyButton"`;
                        string $bdnAttributePasteButton = `iconTextButton
                            -ann "Paste"
                            -i "polyPasteUV.png"
                            -w 23
                            "bdnAttributePasteButton"`;
                      setParent ..;
                      separator -h 2 -nbg false -st "none";
                      string $bdnEnableCheckBox = `checkBoxGrp
                          -adj 2
                          -cw2 170 50
                          -l ""
                          -l1 "Enable"
                          -ncb 1
                          -v1 true
                          "bdnEnableCheckBox"`;
                      string $bdnResetTimeField = `floatFieldGrp
                          -adj 2
                          -cw2 170 50
                          -l "Reset Time"
                          -nf 1
                          -pre 3
                          -tze false
                          -v1 0
                          "bdnResetTimeField"`;
                      string $bdnFpsField = `floatFieldGrp
                          -adj 2
                          -cw2 170 50
                          -l "Fps"
                          -nf 1
                          -pre 3
                          -tze false
                          -v1 30
                          "bdnFpsField"`;
                      separator -h 2 -nbg false -st "none";
                      string $bdnOffsetMatrixWeightField = `floatFieldGrp
                          -adj 2
                          -cw2 170 50
                          -l "Offset Matrix Weight"
                          -nf 1
                          -pre 3
                          -tze false
                          -s 1.0
                          -v1 1.0
                          "bdnOffsetMatrixWeightField"`;
                      separator -h 2 -nbg false -st "none";
                      string $bdnDampingField = `floatFieldGrp
                          -adj 2
                          -cw2 170 50
                          -l "Damping"
                          -nf 1
                          -pre 3
                          -tze false
                          -s 1.0
                          -v1 0.1
                          "bdnDampingField"`;
                      string $bdnElasticityField = `floatFieldGrp
                          -adj 2
                          -cw2 170 50
                          -l "Elasticity"
                          -nf 1
                          -pre 3
                          -tze false
                          -v1 30
                          "bdnElasticityField"`;
                      string $elasticForceFunctionMenuGrp = `optionMenuGrp
                          -adj 2
                          -ct2 "both" "both"
                          -cw2 170 10
                          -l "Elastic Force Function"
                          "elasticForceFunctionMenuGrp"`;
                        string $elasticForceFunction1MenuItem = `menuItem -l "Linear" "elasticForceFunction1MenuItem"`;
                        string $elasticForceFunction2MenuItem = `menuItem -l "Quadratic" "elasticForceFunction2MenuItem"`;
                        string $elasticForceFunction3MenuItem = `menuItem -l "Cubic" "elasticForceFunction3MenuItem"`;
                      optionMenuGrp -e -sl 1 $elasticForceFunctionMenuGrp;
                      string $bdnStiffnessField = `floatFieldGrp
                          -adj 2
                          -cw2 170 50
                          -l "Stiffness"
                          -nf 1
                          -pre 3
                          -tze false
                          -s 1.0
                          -v1 0
                          "bdnStiffnessField"`;
                      string $bdnMassField = `floatFieldGrp
                          -adj 2
                          -cw2 170 50
                          -l "Mass"
                          -nf 1
                          -pre 3
                          -tze false
                          -v1 1
                          "bdnMassField"`;
                      string $bdnGravityXField = `floatFieldGrp
                          -adj 2
                          -cw2 170 50
                          -l "Gravity X"
                          -nf 1
                          -pre 3
                          -tze false
                          -v1 0
                          "bdnGravityXField"`;
                      string $bdnGravityYField = `floatFieldGrp
                          -adj 2
                          -cw2 170 50
                          -l "Gravity Y"
                          -nf 1
                          -pre 3
                          -tze false
                          -v1 -980
                          "bdnGravityYField"`;
                      string $bdnGravityZField = `floatFieldGrp
                          -adj 2
                          -cw2 170 50
                          -l "Gravity Z"
                          -nf 1
                          -pre 3
                          -tze false
                          -v1 0
                          "bdnGravityZField"`;
                      string $bdnGravityMultiplyField = `floatFieldGrp
                          -adj 2
                          -cw2 170 50
                          -l "Gravity Multiply"
                          -nf 1
                          -pre 3
                          -tze false
                          -s 1.0
                          -v1 0
                          "bdnGravityMultiplyField"`;
                      separator -h 2 -nbg false -st "none";
                      string $bdnAdditionalForceScaleField = `floatFieldGrp
                          -adj 2
                          -cw2 170 50
                          -l "Additional Force Scale"
                          -nf 1
                          -pre 3
                          -tze false
                          -v1 1
                          "bdnAdditionalForceScaleField"`;
                      separator -h 2 -nbg false -st "none";
                      string $bdnEnableTurbulenceCheckBox = `checkBoxGrp
                          -adj 2
                          -cw2 170 50
                          -l ""
                          -l1 "Enable Turbulence"
                          -ncb 1
                          -v1 false
                          "bdnEnableTurbulenceCheckBox"`;
                      string $bdnTurbulenceSeedField = `intFieldGrp
                          -adj 2
                          -cw2 170 50
                          -l "Turbulence Seed"
                          -nf 1
                          -v1 0
                          "bdnTurbulenceSeedField"`;
                      string $bdnTurbulenceStrengthField = `floatFieldGrp
                          -adj 2
                          -cw2 170 50
                          -l "Turbulence Strength"
                          -nf 1
                          -pre 3
                          -tze false
                          -v1 10
                          "bdnTurbulenceStrengthField"`;
                      string $bdnTurbulenceVectorChangeScaleField = `floatFieldGrp
                          -adj 2
                          -cw2 170 50
                          -l "Turbulence Vector Change Scale"
                          -nf 1
                          -pre 3
                          -tze false
                          -s 0.1
                          -v1 0.05
                          "bdnTurbulenceVectorChangeScaleField"`;
                      string $bdnTurbulenceVectorChangeMaxField = `floatFieldGrp
                          -adj 2
                          -cw2 170 50
                          -l "Turbulence Vector Change Max"
                          -nf 1
                          -pre 3
                          -tze false
                          -s 1.0
                          -v1 0.1
                          "bdnTurbulenceVectorChangeMaxField"`;
                      separator -h 2 -nbg false -st "none";
                      string $bdnEnableAngleLimitCheckBox = `checkBoxGrp
                          -adj 2
                          -cw2 170 50
                          -l ""
                          -l1 "Enable Angle Limit"
                          -ncb 1
                          -v1 false
                          "bdnEnableAngleLimitCheckBox"`;
                      string $bdnAngleLimitField = `floatFieldGrp
                          -adj 2
                          -cw2 170 50
                          -l "Angle Limit"
                          -nf 1
                          -pre 3
                          -tze false
                          -v1 60
                          "bdnAngleLimitField"`;
                      separator -h 2 -nbg false -st "none";
                      string $bdnRadiusField = `floatFieldGrp
                          -adj 2
                          -cw2 170 50
                          -l "Radius"
                          -nf 1
                          -pre 3
                          -tze false
                          -s 1.0
                          -v1 0
                          "bdnRadiusField"`;
                      string $bdnIterationsField = `intFieldGrp
                          -adj 2
                          -cw2 170 50
                          -l "Iterations"
                          -nf 1
                          -v1 5
                          "bdnIterationsField"`;
                      string $bdnEnableGroundColCheckBox = `checkBoxGrp
                          -adj 2
                          -cw2 170 50
                          -l ""
                          -l1 "Enable Ground Col"
                          -ncb 1
                          -v1 false
                          "bdnEnableGroundColCheckBox"`;
                      string $bdnGroundHeightField = `floatFieldGrp
                          -adj 2
                          -cw2 170 50
                          -l "Ground Height"
                          -nf 1
                          -pre 3
                          -tze false
                          -v1 0
                          "bdnGroundHeightField"`;
                      separator -h 2 -nbg false -st "none";
                      string $bdnMeshColCutoffField = `floatFieldGrp
                          -adj 2
                          -cw2 170 50
                          -l "Mesh Col Cutoff"
                          -nf 1
                          -pre 3
                          -tze false
                          -v1 10
                          "bdnMeshColCutoffField"`;
                    setParent ..;
                  setParent ..;
                setParent ..;
              setParent ..;

            setParent ..;
          setParent ..;
        setParent ..;

        string $bdnRelatedNodeForm = `formLayout "bdnRelatedNodeForm"`;
          string $bdnRelatedNodeTab = `tabLayout -bs "none" -stb false -w 400 "bdnRelatedNodeTab"`;

            string $dynamicsUnitForm = `formLayout "dynamicsUnitForm"`;
              string $dynamicsUnitBuildFrame = `frameLayout -bgs true -cll false -cl false -l "Build" -mh 4 -mw 8 "dynamicsUnitBuildFrame"`;
                string $dynamicsUnitBuildColumn = `columnLayout -adj true -rs 4 "dynamicsUnitBuildColumn"`;
                  string $dynamicsUnitBranchColumn = `columnLayout -adj true -rs 4 "dynamicsUnitBranchColumn"`;
                    text -al "left" -l "Branch Handling";
                    string $dynamicsUnitBranchAimVectorRadioButton = `radioButtonGrp
                        -cw4 90 50 50 50
                        -l "Aim Vector"
                        -la3 "X" "Y" "Z"
                        -nrb 3
                        -sl 1
                        "dynamicsUnitBranchAimVectorRadioButton"`;
                    string $dynamicsUnitBranchUpVectorRadioButton = `radioButtonGrp
                        -cw4 90 50 50 50
                        -l "Up Vector"
                        -la3 "X" "Y" "Z"
                        -nrb 3
                        -sl 2
                        "dynamicsUnitBranchUpVectorRadioButton"`;
                    string $dynamicsUnitBranchInvertAimVectorCheckBox = `checkBoxGrp
                        -adj 2
                        -cw2 90 50
                        -l ""
                        -l1 "Invert Aim Vector"
                        -ncb 1
                        -v1 false
                        "dynamicsUnitBranchInvertAimVectorCheckBox"`;
                  setParent ..;
                  separator -h 2 -nbg false -st "none";
                  string $dynamicsUnitEndJointOffsetField = `floatFieldGrp
                      -adj 0
                      -cw4 90 49 49 49
                      -l "End Joint Offset"
                      -nf 3
                      -pre 3
                      -tze true
                      -v1 1.0 -v2 0.0 -v3 0.0
                      "dynamicsUnitEndJointOffsetField"`;
                  string $generateDynamicsUnitButton = `button -l "Generate Dynamics Unit" "generateDynamicsUnitButton"`;
                setParent ..;
              setParent ..;

              string $dynamicsUnitListFrame = `frameLayout -bgs true -cll false -cl false -l "Joint List" -mh 4 -mw 8 "dynamicsUnitListFrame"`;
                string $dynamicsUnitListForm = `formLayout "dynamicsUnitListForm"`;

                  string $dynamicsNodeListToolRow = `rowLayout -adj 2 -nc 5 "dynamicsNodeListToolRow"`;
                    string $dynamicsNodeListLabel = `text -al "left" -l "Dynamics" "dynamicsNodeListLabel"`;
                    separator -st "none" -vis false;
                    string $showDynamicsNodesButton = `iconTextButton
                        -ann "Show"
                        -i "ghostingVisible.png"
                        -w 23
                        "showDynamicsNodesButton"`;
                    string $hideDynamicsNodesButton = `iconTextButton
                        -ann "Hide"
                        -i "ghostingHidden.png"
                        -w 23
                        "hideDynamicsNodesButton"`;
                    string $selectDynamicsNodesButton = `iconTextButton
                        -ann "Select"
                        -i "pickObjByType.png"
                        -w 23
                        "selectDynamicsNodesButton"`;
                  setParent ..;
                  string $dynamicsNodeList = `textScrollList -ams true -ekf false "dynamicsNodeList"`;

                  string $targetNodeListToolRow = `rowLayout -adj 2 -nc 5 "targetNodeListToolRow"`;
                    string $targetNodeListLabel = `text -al "left" -l "Target" "targetNodeListLabel"`;
                    separator -st "none" -vis false;
                    string $showTargetNodesButton = `iconTextButton
                        -ann "Show"
                        -i "ghostingVisible.png"
                        -w 23
                        "showTargetNodesButton"`;
                    string $hideTargetNodesButton = `iconTextButton
                        -ann "Hide"
                        -i "ghostingHidden.png"
                        -w 23
                        "hideTargetNodesButton"`;
                    string $selectTargetNodesButton = `iconTextButton
                        -ann "Select"
                        -i "pickObjByType.png"
                        -w 23
                        "selectTargetNodesButton"`;
                  setParent ..;
                  string $targetNodeList = `textScrollList -ams true -ekf false "targetNodeList"`;

                setParent ..;
              setParent ..;
            setParent ..;

            string $colliderForm = `formLayout "colliderForm"`;
              string $colliderBuildFrame = `frameLayout -bgs true -cll false -cl false -l "Build" -mh 4 -mw 8 "colliderBuildFrame"`;
                string $colliderBuildColumn = `columnLayout -adj true -rs 4 "colliderBuildColumn"`;
                  string $createMultipleCollidersCheckBox = `checkBox
                      -l "Create and constrain colliders for selected nodes"
                      -v false
                      "createMultipleCollidersCheckBox"`;
                  string $createColliderCapsuleButton = `button -l "Capsule" "createColliderCapsuleButton"`;
                  string $createColliderInfinitePlaneButton = `button -l "Infinite Plane" "createColliderInfinitePlaneButton"`;
                  string $createColliderSphereButton = `button -l "Sphere" "createColliderSphereButton"`;
                setParent ..;
              setParent ..;

              string $colliderListFrame = `frameLayout -bgs true -cll false -cl false -l "Collider List" -mh 4 -mw 8 "colliderListFrame"`;
                string $colliderListPane = `paneLayout
                    -cn "horizontal2"
                    -ps 1 100 50
                    -ps 2 100 50
                    "colliderListPane"`;
                  string $colliderListForm = `formLayout "colliderListForm"`;
                    string $influencedColliderNodeListToolRow = `rowLayout -adj 2 -nc 5 "influencedColliderNodeListToolRow"`;
                      string $influencedColliderNodeLabel = `text -al "left" -l "Influenced" "influencedColliderNodeLabel"`;
                      separator -st "none" -vis false;
                      string $showInfluencedColliderNodesButton = `iconTextButton
                          -ann "Show"
                          -i "ghostingVisible.png"
                          -w 23
                          "showInfluencedColliderNodesButton"`;
                      string $hideInfluencedColliderNodesButton = `iconTextButton
                          -ann "Hide"
                          -i "ghostingHidden.png"
                          -w 23
                          "hideInfluencedColliderNodesButton"`;
                      string $selectInfluencedColliderNodesButton = `iconTextButton
                          -ann "Select"
                          -i "pickObjByType.png"
                          -w 23
                          "selectInfluencedColliderNodesButton"`;
                    setParent ..;
                    string $influencedColliderNodeList = `textScrollList -ams true -ekf false "influencedColliderNodeList"`;
                    string $removeColliderButton = `button -l "Remove >" "removeColliderButton"`;

                    string $allColliderNodeListToolRow = `rowLayout -adj 2 -nc 8 "allColliderNodeListToolRow"`;
                      string $allColliderNodeLabel = `text -al "left" -l "All" "allColliderNodeLabel"`;
                      separator -st "none" -vis false;
                      string $allColliderExportButton = `iconTextButton
                          -ann "Export"
                          -i "fileSave.png"
                          -w 23
                          "allColliderExportButton"`;
                      string $allColliderImportButton = `iconTextButton
                          -ann "Import"
                          -i "fileOpen.png"
                          -w 23
                          "allColliderImportButton"`;
                      separator -h 23 -st "single" -vis true;
                      string $showAllColliderNodesButton = `iconTextButton
                          -ann "Show"
                          -i "ghostingVisible.png"
                          -w 23
                          "showAllColliderNodesButton"`;
                      string $hideAllColliderNodesButton = `iconTextButton
                          -ann "Hide"
                          -i "ghostingHidden.png"
                          -w 23
                          "hideAllColliderNodesButton"`;
                      string $selectAllColliderNodesButton = `iconTextButton
                          -ann "Select"
                          -i "pickObjByType.png"
                          -w 23
                          "selectAllColliderNodesButton"`;
                    setParent ..;
                    string $allColliderNodeList = `textScrollList -ams true -ekf false "allColliderNodeList"`;
                    string $appendColliderButton = `button -l "< Append" "appendColliderButton"`;
                  setParent ..;

                  string $colliderAttributeForm = `formLayout "colliderAttributeForm"`;
                    string $colliderAttributeFrame = `frameLayout -bgs false -cll false -cl false -l "Collider Attributes" -nbg true "colliderAttributeFrame"`;
                      string $colliderAttributeScroll = `scrollLayout -cr true -pe true -vsb true -w 286 "colliderAttributeScroll"`;

                        string $capsuleColliderFrame = `frameLayout -bgs false -cll false -cl false -l "Capsule" -vis false "capsuleColliderFrame"`;
                          string $capsuleColliderColumn = `columnLayout -adj true -rs 0 "capsuleColliderColumn"`;
                            string $capsuleColliderToolRow = `rowLayout -adj 2 -nc 5 "capsuleColliderToolRow"`;
                              string $capsuleColliderInitializeButton = `iconTextButton
                                  -ann "Initialize"
                                  -i "hsClearView.png"
                                  -w 23
                                  "capsuleColliderInitButton"`;
                              separator -st "none" -vis false;
                              string $capsuleColliderSetPlacementAttributesCheckBox = `checkBox
                                  -ann "Set Length, Offset, and Pivot attributes when initializing or pasting"
                                  -l "Set Placement Attributes"
                                  -v false
                                  "capsuleColliderSetPlacementAttributesCheckBox"`;
                              string $capsuleColliderCopyButton = `iconTextButton
                                  -ann "Copy"
                                  -i "polyCopyUV.png"
                                  -w 23
                                  "capsuleColliderCopyButton"`;
                              string $capsuleColliderPasteButton = `iconTextButton
                                  -ann "Paste"
                                  -i "polyPasteUV.png"
                                  -w 23
                                  "capsuleColliderPasteButton"`;
                            setParent ..;
                            separator -h 2 -nbg false -st "none";
                            string $capsuleColliderRadiusAField = `floatFieldGrp
                                -adj 2
                                -cw2 180 50
                                -l "Collider Radius A"
                                -nf 1
                                -pre 3
                                -tze false
                                -s 1.0
                                -v1 0.5
                                "capsuleColliderRadiusAField"`;
                            string $capsuleColliderRadiusBField = `floatFieldGrp
                                -adj 2
                                -cw2 180 50
                                -l "Collider Radius B"
                                -nf 1
                                -pre 3
                                -tze false
                                -s 1.0
                                -v1 0.5
                                "capsuleColliderRadiusBField"`;
                            string $capsuleColliderLengthField = `floatFieldGrp
                                -adj 2
                                -cw2 180 50
                                -l "Collider Length"
                                -nf 1
                                -pre 3
                                -tze false
                                -s 1.0
                                -v1 2
                                "capsuleColliderLengthField"`;
                            string $capsuleColliderOffsetField = `floatFieldGrp
                                -adj 2
                                -cw2 180 50
                                -l "Collider Offset"
                                -nf 1
                                -pre 3
                                -tze false
                                -s 1.0
                                -v1 0
                                "capsuleColliderOffsetField"`;
                            string $capsuleColliderPivotMenuGrp = `optionMenuGrp
                                -adj 2
                                -ct2 "both" "both"
                                -cw2 180 10
                                -l "Collider Pivot"
                                "capsuleColliderPivotMenuGrp"`;
                              string $capsuleColliderPivot1MenuItem = `menuItem -l "A" "capsuleColliderPivot1MenuItem"`;
                              string $capsuleColliderPivot2MenuItem = `menuItem -l "Center" "capsuleColliderPivot2MenuItem"`;
                              string $capsuleColliderPivot3MenuItem = `menuItem -l "B" "capsuleColliderPivot3MenuItem"`;
                            optionMenuGrp -e -sl 1 $capsuleColliderPivotMenuGrp;
                          setParent ..;
                        setParent ..;

                        string $infinitePlaneColliderFrame = `frameLayout -bgs false -cll false -cl false -l "Infinite Plane" -vis false "infinitePlaneColliderFrame"`;
                          string $infinitePlaneColliderColumn = `columnLayout -adj true -rs 0 "infinitePlaneColliderColumn"`;
                            string $infinitePlaneColliderToolRow = `rowLayout -adj 2 -nc 4 "infinitePlaneColliderToolRow"`;
                              string $infinitePlaneColliderInitializeButton = `iconTextButton
                                  -ann "Initialize"
                                  -i "hsClearView.png"
                                  -w 23
                                  "infinitePlaneColliderInitButton"`;
                              separator -st "none" -vis false;
                              string $infinitePlaneColliderCopyButton = `iconTextButton
                                  -ann "Copy"
                                  -i "polyCopyUV.png"
                                  -w 23
                                  "infinitePlaneColliderCopyButton"`;
                              string $infinitePlaneColliderPasteButton = `iconTextButton
                                  -ann "Paste"
                                  -i "polyPasteUV.png"
                                  -w 23
                                  "infinitePlaneColliderPasteButton"`;
                            setParent ..;
                            separator -h 2 -nbg false -st "none";
                            string $infinitePlaneColliderWidthField = `floatFieldGrp
                                -adj 2
                                -cw2 180 50
                                -l "Collider Width"
                                -nf 1
                                -pre 3
                                -tze false
                                -s 1.0
                                -v1 1
                                "infinitePlaneColliderWidthField"`;
                            string $infinitePlaneColliderHeightField = `floatFieldGrp
                                -adj 2
                                -cw2 180 50
                                -l "Collider Height"
                                -nf 1
                                -pre 3
                                -tze false
                                -s 1.0
                                -v1 1
                                "infinitePlaneColliderHeightField"`;
                          setParent ..;
                        setParent ..;

                        string $sphereColliderFrame = `frameLayout -bgs false -cll false -cl false -l "Sphere" -vis false "sphereColliderFrame"`;
                          string $sphereColliderColumn = `columnLayout -adj true -rs 0 "sphereColliderColumn"`;
                            string $sphereColliderToolRow = `rowLayout -adj 2 -nc 4 "sphereColliderToolRow"`;
                              string $sphereColliderInitializeButton = `iconTextButton
                                  -ann "Initialize"
                                  -i "hsClearView.png"
                                  -w 23
                                  "sphereColliderInitButton"`;
                              separator -st "none" -vis false;
                              string $sphereColliderCopyButton = `iconTextButton
                                  -ann "Copy"
                                  -i "polyCopyUV.png"
                                  -w 23
                                  "sphereColliderCopyButton"`;
                              string $sphereColliderPasteButton = `iconTextButton
                                  -ann "Paste"
                                  -i "polyPasteUV.png"
                                  -w 23
                                  "sphereColliderPasteButton"`;
                            setParent ..;
                            separator -h 2 -nbg false -st "none";
                            string $sphereColliderRadiusField = `floatFieldGrp
                                -adj 2
                                -cw2 180 50
                                -l "Collider Radius"
                                -nf 1
                                -pre 3
                                -tze false
                                -s 1.0
                                -v1 0.5
                                "sphereColliderRadiusField"`;
                          setParent ..;
                        setParent ..;

                      setParent ..;
                    setParent ..;
                  setParent ..;

                setParent ..;
              setParent ..;
            setParent ..;

            string $meshForm = `formLayout "meshForm"`;
              string $meshListFrame = `frameLayout -bgs true -cll false -cl false -l "Mesh List" -mh 4 -mw 8 "meshListFrame"`;
                string $meshListForm = `formLayout "meshListForm"`;
                  string $meshNodeListToolRow = `rowLayout -adj 1 -nc 4 "meshNodeListToolRow"`;
                    separator -st "none" -vis false;
                    string $showMeshNodesButton = `iconTextButton
                        -ann "Show"
                        -i "ghostingVisible.png"
                        -w 23
                        "showMeshNodesButton"`;
                    string $hideMeshNodesButton = `iconTextButton
                        -ann "Hide"
                        -i "ghostingHidden.png"
                        -w 23
                        "hideMeshNodesButton"`;
                    string $selectMeshNodesButton = `iconTextButton
                        -ann "Select"
                        -i "pickObjByType.png"
                        -w 23
                        "selectMeshNodesButton"`;
                  setParent ..;
                  string $meshNodeList = `textScrollList -ams true -ekf false "meshNodeList"`;
                  string $appendMeshNodesButton = `button -l "Append" "appendMeshNodesButton"`;
                  string $removeMeshNodesButton = `button -l "Remove" "removeMeshNodesButton"`;
                setParent ..;
              setParent ..;
            setParent ..;

            string $forceForm = `formLayout "forceForm"`;
              string $forceListFrame = `frameLayout -bgs true -cll false -cl false -l "Force List" -mh 4 -mw 8 "forceListFrame"`;
                string $forceListForm = `formLayout "forceListForm"`;
                  string $forceNodeListToolRow = `rowLayout -adj 1 -nc 4 "forceNodeListToolRow"`;
                    separator -st "none" -vis false;
                    string $showForceNodesButton = `iconTextButton
                        -ann "Show"
                        -i "ghostingVisible.png"
                        -w 23
                        "showForceNodesButton"`;
                    string $hideForceNodesButton = `iconTextButton
                        -ann "Hide"
                        -i "ghostingHidden.png"
                        -w 23
                        "hideForceNodesButton"`;
                    string $selectForceNodesButton = `iconTextButton
                        -ann "Select"
                        -i "pickObjByType.png"
                        -w 23
                        "selectForceNodesButton"`;
                  setParent ..;
                  string $forceNodeList = `textScrollList -ams true -ekf false "forceNodeList"`;
                  string $connectForceNodeButton = `button -l "Connect" "connectForceNodeButton"`;
                  string $disconnectForceNodeButton = `button -l "Disconnect" "disconnectForceNodeButton"`;
                  string $forceFrame = `frameLayout -bgs false -cll false -cl false -l "Force" -nbg true "forceFrame"`;
                    string $forceColumn = `columnLayout -adj true -rs 4 "forceColumn"`;
                      string $forceVectorRadioButton = `radioButtonGrp
                          -cw4 90 50 50 50
                          -l "Force Vector"
                          -la3 "X" "Y" "Z"
                          -nrb 3
                          -sl 1
                          "forceVectorRadioButton"`;
                      string $invertForceVectorCheckBox = `checkBoxGrp
                          -adj 2
                          -cw2 90 50
                          -l ""
                          -l1 "Invert Force Vector"
                          -ncb 1
                          -v1 false
                          "invertForceVectorCheckBox"`;
                    setParent ..;
                  setParent ..;
                setParent ..;
              setParent ..;
            setParent ..;

            string $offsetForm = `formLayout "offsetForm"`;
              string $offsetListFrame = `frameLayout -bgs true -cll false -cl false -l "Mesh List" -mh 4 -mw 8 "offsetListFrame"`;
                string $offsetListForm = `formLayout "offsetListForm"`;
                  string $offsetNodeListToolRow = `rowLayout -adj 1 -nc 4 "offsetNodeListToolRow"`;
                    separator -st "none" -vis false;
                    string $showOffsetNodesButton = `iconTextButton
                        -ann "Show"
                        -i "ghostingVisible.png"
                        -w 23
                        "showOffsetNodesButton"`;
                    string $hideOffsetNodesButton = `iconTextButton
                        -ann "Hide"
                        -i "ghostingHidden.png"
                        -w 23
                        "hideOffsetNodesButton"`;
                    string $selectOffsetNodesButton = `iconTextButton
                        -ann "Select"
                        -i "pickObjByType.png"
                        -w 23
                        "selectOffsetNodesButton"`;
                  setParent ..;
                  string $offsetNodeList = `textScrollList -ams true -ekf false "offsetNodeList"`;
                  string $connectOffsetNodeButton = `button -l "Connect" "connectOffsetNodeButton"`;
                  string $disconnectOffsetNodeButton = `button -l "Disconnect" "disconnectOffsetNodeButton"`;
                setParent ..;
              setParent ..;
            setParent ..;

            string $bakeForm = `formLayout "bakeForm"`;
              string $bakeListFrame = `frameLayout -bgs true -cll false -cl false -l "Bind List" -mh 4 -mw 8 "bakeListFrame"`;
                string $bakeListForm = `formLayout "bakeListForm"`;
                  string $bindNodeListToolRow = `rowLayout -adj 1 -nc 4 "bindNodeListToolRow"`;
                    separator -st "none" -vis false;
                    string $showBindNodesButton = `iconTextButton
                        -ann "Show"
                        -i "ghostingVisible.png"
                        -w 23
                        "showBindNodesButton"`;
                    string $hideBindNodesButton = `iconTextButton
                        -ann "Hide"
                        -i "ghostingHidden.png"
                        -w 23
                        "hideBindNodesButton"`;
                    string $selectBindNodesButton = `iconTextButton
                        -ann "Select"
                        -i "pickObjByType.png"
                        -w 23
                        "selectBindNodesButton"`;
                  setParent ..;
                  string $bindNodeList = `textScrollList -ams true -ekf false "bindNodeList"`;

                  string $bakeFrame = `frameLayout -bgs false -cll false -cl false -l "Bake" -nbg true "bakeFrame"`;
                    string $bakeColumn = `columnLayout -adj true -rs 4 "bakeColumn"`;
                      string $bakeTimeRangeRadioButton = `radioButtonGrp
                          -cw3 90 90 90
                          -l "Time Range"
                          -la2 "Time Slider" "Start/End"
                          -nrb 2
                          -sl 1
                          "bakeTimeRangeRadioButton"`;
                      string $bakeStartEndField = `floatFieldGrp
                          -adj 0
                          -cw3 90 90 90
                          -l "Start/End"
                          -nf 2
                          -pre 3
                          -tze true
                          -v1 0.0 -v2 30.0
                          "bakeStartEndField"`;
                      string $bakeButton = `button -l "Bake" "bakeButton"`;
                      string $rebindButton = `button -ann "Delete all keys and reconnect" -l "Rebind" "rebindButton"`;
                    setParent ..;
                  setParent ..;

                setParent ..;
              setParent ..;
            setParent ..;

          setParent ..;
        setParent ..;

      setParent ..;
    setParent ..;

  tabLayout -e -tli 1 "Dynamics Unit" $bdnRelatedNodeTab;
  tabLayout -e -tli 2 "Collider" $bdnRelatedNodeTab;
  tabLayout -e -tli 3 "Mesh Col" $bdnRelatedNodeTab;
  tabLayout -e -tli 4 "Force" $bdnRelatedNodeTab;
  tabLayout -e -tli 5 "Offset" $bdnRelatedNodeTab;
  tabLayout -e -tli 6 "Bake" $bdnRelatedNodeTab;
  tabLayout -e -sti 1 $bdnRelatedNodeTab;

  formLayout -e
      -af $menuBar "top" 0
      -af $menuBar "left" 0
      -af $menuBar "right" 0
      -ac $outerPane "top" 0 $menuBar
      -af $outerPane "left" 4
      -af $outerPane "right" 4
      -af $outerPane "bottom" 4
      $outerForm;

  formLayout -e
      -af $bdnListFrame "top" 0
      -af $bdnListFrame "left" 0
      -af $bdnListFrame "right" 0
      -af $bdnListFrame "bottom" 0
      $bdnForm;

  formLayout -e
      -af $bdnListToolRow "top" 0
      -af $bdnListToolRow "left" 0
      -af $bdnListToolRow "right" 0
      -af $substituteBdnNodesButton "left" 0
      -ap $substituteBdnNodesButton "right" 2 50
      -af $substituteBdnNodesButton "bottom" 4
      -ap $restoreBdnNodesButton "left" 2 50
      -af $restoreBdnNodesButton "right" 0
      -af $restoreBdnNodesButton "bottom" 4
      -ac $bdnNodeList "top" 0 $bdnListToolRow
      -af $bdnNodeList "left" 0
      -af $bdnNodeList "right" 0
      -ac $bdnNodeList "bottom" 4 $substituteBdnNodesButton
      $bdnListForm;

  formLayout -e
      -af $bdnAttributeFrame "top" 4
      -af $bdnAttributeFrame "left" 0
      -af $bdnAttributeFrame "right" 0
      -af $bdnAttributeFrame "bottom" 0
      $bdnAttributeForm;

  formLayout -e
      -af $bdnRelatedNodeTab "top" 0
      -af $bdnRelatedNodeTab "left" 0
      -af $bdnRelatedNodeTab "right" 0
      -af $bdnRelatedNodeTab "bottom" 0
      $bdnRelatedNodeForm;

  formLayout -e
      -af $dynamicsUnitBuildFrame "top" 0
      -af $dynamicsUnitBuildFrame "left" 0
      -af $dynamicsUnitBuildFrame "right" 0
      -ac $dynamicsUnitListFrame "top" 2 $dynamicsUnitBuildFrame
      -af $dynamicsUnitListFrame "left" 0
      -af $dynamicsUnitListFrame "right" 0
      -af $dynamicsUnitListFrame "bottom" 0
      $dynamicsUnitForm;

  formLayout -e
      -af $dynamicsNodeListToolRow "top" 0
      -af $dynamicsNodeListToolRow "left" 0
      -ap $dynamicsNodeListToolRow "right" 2 50
      -ac $dynamicsNodeList "top" 0 $dynamicsNodeListToolRow
      -af $dynamicsNodeList "left" 0
      -ap $dynamicsNodeList "right" 2 50
      -af $dynamicsNodeList "bottom" 0

      -af $targetNodeListToolRow "top" 0
      -ap $targetNodeListToolRow "left" 2 50
      -af $targetNodeListToolRow "right" 0
      -ac $targetNodeList "top" 0 $targetNodeListToolRow
      -ap $targetNodeList "left" 2 50
      -af $targetNodeList "right" 0
      -af $targetNodeList "bottom" 0
      $dynamicsUnitListForm;

  formLayout -e
      -af $colliderBuildFrame "top" 0
      -af $colliderBuildFrame "left" 0
      -af $colliderBuildFrame "right" 0
      -ac $colliderListFrame "top" 2 $colliderBuildFrame
      -af $colliderListFrame "left" 0
      -af $colliderListFrame "right" 0
      -af $colliderListFrame "bottom" 0
      $colliderForm;

  formLayout -e
      -af $influencedColliderNodeListToolRow "top" 0
      -af $influencedColliderNodeListToolRow "left" 0
      -ap $influencedColliderNodeListToolRow "right" 2 50
      -af $removeColliderButton "left" 0
      -ap $removeColliderButton "right" 2 50
      -af $removeColliderButton "bottom" 4
      -ac $influencedColliderNodeList "top" 0 $influencedColliderNodeListToolRow
      -af $influencedColliderNodeList "left" 0
      -ap $influencedColliderNodeList "right" 2 50
      -ac $influencedColliderNodeList "bottom" 4 $removeColliderButton

      -af $allColliderNodeListToolRow "top" 0
      -ap $allColliderNodeListToolRow "left" 2 50
      -af $allColliderNodeListToolRow "right" 0
      -ap $appendColliderButton "left" 2 50
      -af $appendColliderButton "right" 0
      -af $appendColliderButton "bottom" 4
      -ac $allColliderNodeList "top" 0 $allColliderNodeListToolRow
      -ap $allColliderNodeList "left" 2 50
      -af $allColliderNodeList "right" 0
      -ac $allColliderNodeList "bottom" 4 $appendColliderButton
      $colliderListForm;

  formLayout -e
      -af $colliderAttributeFrame "top" 4
      -af $colliderAttributeFrame "left" 0
      -af $colliderAttributeFrame "right" 0
      -af $colliderAttributeFrame "bottom" 0
      $colliderAttributeForm;

  formLayout -e
      -af $meshListFrame "top" 0
      -af $meshListFrame "left" 0
      -af $meshListFrame "right" 0
      -af $meshListFrame "bottom" 0
      $meshForm;

  formLayout -e
      -af $meshNodeListToolRow "top" 0
      -af $meshNodeListToolRow "left" 0
      -af $meshNodeListToolRow "right" 0
      -af $appendMeshNodesButton "left" 0
      -ap $appendMeshNodesButton "right" 2 50
      -af $appendMeshNodesButton "bottom" 0
      -ap $removeMeshNodesButton "left" 2 50
      -af $removeMeshNodesButton "right" 0
      -af $removeMeshNodesButton "bottom" 0
      -ac $meshNodeList "top" 0 $meshNodeListToolRow
      -af $meshNodeList "left" 0
      -af $meshNodeList "right" 0
      -ac $meshNodeList "bottom" 4 $appendMeshNodesButton
      $meshListForm;

  formLayout -e
      -af $forceListFrame "top" 0
      -af $forceListFrame "left" 0
      -af $forceListFrame "right" 0
      -af $forceListFrame "bottom" 0
      $forceForm;

  formLayout -e
      -af $forceFrame "left" 0
      -af $forceFrame "right" 0
      -af $forceFrame "bottom" 0

      -af $forceNodeListToolRow "top" 0
      -af $forceNodeListToolRow "left" 0
      -af $forceNodeListToolRow "right" 0
      -af $connectForceNodeButton "left" 0
      -ap $connectForceNodeButton "right" 2 50
      -ac $connectForceNodeButton "bottom" 4 $forceFrame
      -ap $disconnectForceNodeButton "left" 2 50
      -af $disconnectForceNodeButton "right" 0
      -ac $disconnectForceNodeButton "bottom" 4 $forceFrame
      -ac $forceNodeList "top" 0 $forceNodeListToolRow
      -af $forceNodeList "left" 0
      -af $forceNodeList "right" 0
      -ac $forceNodeList "bottom" 4 $connectForceNodeButton
      $forceListForm;

  formLayout -e
      -af $offsetListFrame "top" 0
      -af $offsetListFrame "left" 0
      -af $offsetListFrame "right" 0
      -af $offsetListFrame "bottom" 0
      $offsetForm;

  formLayout -e
      -af $offsetNodeListToolRow "top" 0
      -af $offsetNodeListToolRow "left" 0
      -af $offsetNodeListToolRow "right" 0
      -af $connectOffsetNodeButton "left" 0
      -ap $connectOffsetNodeButton "right" 2 50
      -af $connectOffsetNodeButton "bottom" 0
      -ap $disconnectOffsetNodeButton "left" 2 50
      -af $disconnectOffsetNodeButton "right" 0
      -af $disconnectOffsetNodeButton "bottom" 0
      -ac $offsetNodeList "top" 0 $offsetNodeListToolRow
      -af $offsetNodeList "left" 0
      -af $offsetNodeList "right" 0
      -ac $offsetNodeList "bottom" 4 $connectOffsetNodeButton
      $offsetListForm;

  formLayout -e
      -af $bakeListFrame "top" 0
      -af $bakeListFrame "left" 0
      -af $bakeListFrame "right" 0
      -af $bakeListFrame "bottom" 0
      $bakeForm;

  formLayout -e
      -af $bakeFrame "left" 0
      -af $bakeFrame "right" 0
      -af $bakeFrame "bottom" 0

      -af $bindNodeListToolRow "top" 0
      -af $bindNodeListToolRow "left" 0
      -af $bindNodeListToolRow "right" 0
      -ac $bindNodeList "top" 0 $bindNodeListToolRow
      -af $bindNodeList "left" 0
      -af $bindNodeList "right" 0
      -ac $bindNodeList "bottom" 4 $bakeFrame
      $bakeListForm;

  window -e -cc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"cc\", \"nkBdnEditorWindow\");" $nkBdnEditorWindow;
  menuItem -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"resetWindowMenuItem\");" $resetWindowMenuItem;
  menuItem -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"quitMenuItem\");" $quitMenuItem;
  menuItem -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"refreshMenuItem\");" $refreshMenuItem;
  menuItem -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"aboutMenuItem\");" $aboutMenuItem;

  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"selectBdnNodesButton\");" $selectBdnNodesButton;
  textScrollList -e -dcc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"dcc\", \"bdnNodeList\");" $bdnNodeList;
  textScrollList -e -sc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"sc\", \"bdnNodeList\");" $bdnNodeList;
  button -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"substituteBdnNodesButton\");" $substituteBdnNodesButton;
  button -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"restoreBdnNodesButton\");" $restoreBdnNodesButton;

  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"bdnAttributeInitializeButton\");" $bdnAttributeInitializeButton;
  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"bdnAttributeExportButton\");" $bdnAttributeExportButton;
  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"bdnAttributeImportButton\");" $bdnAttributeImportButton;
  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"bdnAttributeCopyButton\");" $bdnAttributeCopyButton;
  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"bdnAttributePasteButton\");" $bdnAttributePasteButton;

  checkBoxGrp -e -cc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"cc\", \"bdnEnableCheckBox\");" $bdnEnableCheckBox;
  floatFieldGrp -e -cc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"cc\", \"bdnResetTimeField\");" $bdnResetTimeField;
  floatFieldGrp -e -cc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"cc\", \"bdnFpsField\");" $bdnFpsField;
  floatFieldGrp -e -cc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"cc\", \"bdnOffsetMatrixWeightField\");" $bdnOffsetMatrixWeightField;
  floatFieldGrp -e -cc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"cc\", \"bdnDampingField\");" $bdnDampingField;
  floatFieldGrp -e -cc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"cc\", \"bdnElasticityField\");" $bdnElasticityField;
  optionMenuGrp -e -cc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"cc\", \"elasticForceFunctionMenuGrp\");" $elasticForceFunctionMenuGrp;
  floatFieldGrp -e -cc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"cc\", \"bdnStiffnessField\");" $bdnStiffnessField;
  floatFieldGrp -e -cc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"cc\", \"bdnMassField\");" $bdnMassField;
  floatFieldGrp -e -cc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"cc\", \"bdnGravityXField\");" $bdnGravityXField;
  floatFieldGrp -e -cc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"cc\", \"bdnGravityYField\");" $bdnGravityYField;
  floatFieldGrp -e -cc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"cc\", \"bdnGravityZField\");" $bdnGravityZField;
  floatFieldGrp -e -cc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"cc\", \"bdnGravityMultiplyField\");" $bdnGravityMultiplyField;
  floatFieldGrp -e -cc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"cc\", \"bdnAdditionalForceScaleField\");" $bdnAdditionalForceScaleField;
  checkBoxGrp -e -cc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"cc\", \"bdnEnableTurbulenceCheckBox\");" $bdnEnableTurbulenceCheckBox;
  intFieldGrp -e -cc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"cc\", \"bdnTurbulenceSeedField\");" $bdnTurbulenceSeedField;
  floatFieldGrp -e -cc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"cc\", \"bdnTurbulenceStrengthField\");" $bdnTurbulenceStrengthField;
  floatFieldGrp -e -cc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"cc\", \"bdnTurbulenceVectorChangeScaleField\");" $bdnTurbulenceVectorChangeScaleField;
  floatFieldGrp -e -cc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"cc\", \"bdnTurbulenceVectorChangeMaxField\");" $bdnTurbulenceVectorChangeMaxField;
  checkBoxGrp -e -cc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"cc\", \"bdnEnableAngleLimitCheckBox\");" $bdnEnableAngleLimitCheckBox;
  floatFieldGrp -e -cc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"cc\", \"bdnAngleLimitField\");" $bdnAngleLimitField;
  floatFieldGrp -e -cc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"cc\", \"bdnRadiusField\");" $bdnRadiusField;
  floatFieldGrp -e -dc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"dc\", \"bdnRadiusField\");" $bdnRadiusField;
  intFieldGrp -e -cc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"cc\", \"bdnIterationsField\");" $bdnIterationsField;
  checkBoxGrp -e -cc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"cc\", \"bdnEnableGroundColCheckBox\");" $bdnEnableGroundColCheckBox;
  floatFieldGrp -e -cc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"cc\", \"bdnGroundHeightField\");" $bdnGroundHeightField;
  floatFieldGrp -e -cc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"cc\", \"bdnMeshColCutoffField\");" $bdnMeshColCutoffField;

  tabLayout -e -cc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"cc\", \"bdnRelatedNodeTab\");" $bdnRelatedNodeTab;

  button -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"generateDynamicsUnitButton\");" $generateDynamicsUnitButton;

  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"showDynamicsNodesButton\");" $showDynamicsNodesButton;
  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"hideDynamicsNodesButton\");" $hideDynamicsNodesButton;
  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"selectDynamicsNodesButton\");" $selectDynamicsNodesButton;
  textScrollList -e -dcc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"dcc\", \"dynamicsNodeList\");" $dynamicsNodeList;
  textScrollList -e -sc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"sc\", \"dynamicsNodeList\");" $dynamicsNodeList;

  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"showTargetNodesButton\");" $showTargetNodesButton;
  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"hideTargetNodesButton\");" $hideTargetNodesButton;
  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"selectTargetNodesButton\");" $selectTargetNodesButton;
  textScrollList -e -dcc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"dcc\", \"targetNodeList\");" $targetNodeList;
  textScrollList -e -sc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"sc\", \"targetNodeList\");" $targetNodeList;

  button -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"createColliderCapsuleButton\");" $createColliderCapsuleButton;
  button -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"createColliderInfinitePlaneButton\");" $createColliderInfinitePlaneButton;
  button -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"createColliderSphereButton\");" $createColliderSphereButton;

  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"showInfluencedColliderNodesButton\");" $showInfluencedColliderNodesButton;
  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"hideInfluencedColliderNodesButton\");" $hideInfluencedColliderNodesButton;
  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"selectInfluencedColliderNodesButton\");" $selectInfluencedColliderNodesButton;
  textScrollList -e -dcc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"dcc\", \"influencedColliderNodeList\");" $influencedColliderNodeList;
  textScrollList -e -sc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"sc\", \"influencedColliderNodeList\");" $influencedColliderNodeList;
  button -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"removeColliderButton\");" $removeColliderButton;

  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"allColliderExportButton\");" $allColliderExportButton;
  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"allColliderImportButton\");" $allColliderImportButton;
  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"showAllColliderNodesButton\");" $showAllColliderNodesButton;
  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"hideAllColliderNodesButton\");" $hideAllColliderNodesButton;
  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"selectAllColliderNodesButton\");" $selectAllColliderNodesButton;
  textScrollList -e -dcc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"dcc\", \"allColliderNodeList\");" $allColliderNodeList;
  textScrollList -e -sc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"sc\", \"allColliderNodeList\");" $allColliderNodeList;
  button -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"appendColliderButton\");" $appendColliderButton;

  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"capsuleColliderInitializeButton\");" $capsuleColliderInitializeButton;
  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"capsuleColliderCopyButton\");" $capsuleColliderCopyButton;
  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"capsuleColliderPasteButton\");" $capsuleColliderPasteButton;
  floatFieldGrp -e -cc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"cc\", \"capsuleColliderRadiusAField\");" $capsuleColliderRadiusAField;
  floatFieldGrp -e -dc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"dc\", \"capsuleColliderRadiusAField\");" $capsuleColliderRadiusAField;
  floatFieldGrp -e -cc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"cc\", \"capsuleColliderRadiusBField\");" $capsuleColliderRadiusBField;
  floatFieldGrp -e -dc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"dc\", \"capsuleColliderRadiusBField\");" $capsuleColliderRadiusBField;
  floatFieldGrp -e -cc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"cc\", \"capsuleColliderLengthField\");" $capsuleColliderLengthField;
  floatFieldGrp -e -dc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"dc\", \"capsuleColliderLengthField\");" $capsuleColliderLengthField;
  floatFieldGrp -e -cc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"cc\", \"capsuleColliderOffsetField\");" $capsuleColliderOffsetField;
  floatFieldGrp -e -dc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"dc\", \"capsuleColliderOffsetField\");" $capsuleColliderOffsetField;
  optionMenuGrp -e -cc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"cc\", \"capsuleColliderPivotMenuGrp\");" $capsuleColliderPivotMenuGrp;

  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"infinitePlaneColliderInitializeButton\");" $infinitePlaneColliderInitializeButton;
  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"infinitePlaneColliderCopyButton\");" $infinitePlaneColliderCopyButton;
  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"infinitePlaneColliderPasteButton\");" $infinitePlaneColliderPasteButton;
  floatFieldGrp -e -cc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"cc\", \"infinitePlaneColliderWidthField\");" $infinitePlaneColliderWidthField;
  floatFieldGrp -e -dc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"dc\", \"infinitePlaneColliderWidthField\");" $infinitePlaneColliderWidthField;
  floatFieldGrp -e -cc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"cc\", \"infinitePlaneColliderHeightField\");" $infinitePlaneColliderHeightField;
  floatFieldGrp -e -dc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"dc\", \"infinitePlaneColliderHeightField\");" $infinitePlaneColliderHeightField;

  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"sphereColliderInitializeButton\");" $sphereColliderInitializeButton;
  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"sphereColliderCopyButton\");" $sphereColliderCopyButton;
  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"sphereColliderPasteButton\");" $sphereColliderPasteButton;
  floatFieldGrp -e -cc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"cc\", \"sphereColliderRadiusField\");" $sphereColliderRadiusField;
  floatFieldGrp -e -dc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"dc\", \"sphereColliderRadiusField\");" $sphereColliderRadiusField;

  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"showMeshNodesButton\");" $showMeshNodesButton;
  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"hideMeshNodesButton\");" $hideMeshNodesButton;
  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"selectMeshNodesButton\");" $selectMeshNodesButton;
  textScrollList -e -dcc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"dcc\", \"meshNodeList\");" $meshNodeList;
  textScrollList -e -sc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"sc\", \"meshNodeList\");" $meshNodeList;
  button -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"appendMeshNodesButton\");" $appendMeshNodesButton;
  button -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"removeMeshNodesButton\");" $removeMeshNodesButton;

  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"showForceNodesButton\");" $showForceNodesButton;
  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"hideForceNodesButton\");" $hideForceNodesButton;
  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"selectForceNodesButton\");" $selectForceNodesButton;
  textScrollList -e -dcc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"dcc\", \"forceNodeList\");" $forceNodeList;
  textScrollList -e -sc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"sc\", \"forceNodeList\");" $forceNodeList;
  button -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"connectForceNodeButton\");" $connectForceNodeButton;
  button -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"disconnectForceNodeButton\");" $disconnectForceNodeButton;
  radioButtonGrp -e -onc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"onc\", \"forceVectorRadioButton\");" $forceVectorRadioButton;
  checkBoxGrp -e -cc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"cc\", \"invertForceVectorCheckBox\");" $invertForceVectorCheckBox;

  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"showOffsetNodesButton\");" $showOffsetNodesButton;
  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"hideOffsetNodesButton\");" $hideOffsetNodesButton;
  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"selectOffsetNodesButton\");" $selectOffsetNodesButton;
  textScrollList -e -dcc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"dcc\", \"offsetNodeList\");" $offsetNodeList;
  textScrollList -e -sc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"sc\", \"offsetNodeList\");" $offsetNodeList;
  button -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"connectOffsetNodeButton\");" $connectOffsetNodeButton;
  button -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"disconnectOffsetNodeButton\");" $disconnectOffsetNodeButton;

  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"showBindNodesButton\");" $showBindNodesButton;
  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"hideBindNodesButton\");" $hideBindNodesButton;
  iconTextButton -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"selectBindNodesButton\");" $selectBindNodesButton;
  textScrollList -e -dcc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"dcc\", \"bindNodeList\");" $bindNodeList;
  textScrollList -e -sc "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"sc\", \"bindNodeList\");" $bindNodeList;
  button -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"bakeButton\");" $bakeButton;
  button -e -c "nkBdnEditorEventController(\"nkBdnEditorWindow\", \"c\", \"rebindButton\");" $rebindButton;

  appendUIControls({
    $nkBdnEditorWindow,

    $bdnNodeList,
    $bdnEnableCheckBox,
    $bdnResetTimeField,
    $bdnFpsField,
    $bdnOffsetMatrixWeightField,
    $bdnDampingField,
    $bdnElasticityField,
    $elasticForceFunctionMenuGrp,
    $bdnStiffnessField,
    $bdnMassField,
    $bdnGravityXField,
    $bdnGravityYField,
    $bdnGravityZField,
    $bdnGravityMultiplyField,
    $bdnAdditionalForceScaleField,
    $bdnEnableTurbulenceCheckBox,
    $bdnTurbulenceSeedField,
    $bdnTurbulenceStrengthField,
    $bdnTurbulenceVectorChangeScaleField,
    $bdnTurbulenceVectorChangeMaxField,
    $bdnEnableAngleLimitCheckBox,
    $bdnAngleLimitField,
    $bdnRadiusField,
    $bdnIterationsField,
    $bdnEnableGroundColCheckBox,
    $bdnGroundHeightField,
    $bdnMeshColCutoffField,

    $bdnRelatedNodeTab,

    $dynamicsUnitBranchAimVectorRadioButton,
    $dynamicsUnitBranchUpVectorRadioButton,
    $dynamicsUnitBranchInvertAimVectorCheckBox,
    $dynamicsUnitEndJointOffsetField,
    $dynamicsNodeList,
    $targetNodeList,

    $createMultipleCollidersCheckBox,
    $influencedColliderNodeList,
    $allColliderNodeList,

    $capsuleColliderFrame,
    $capsuleColliderSetPlacementAttributesCheckBox,
    $capsuleColliderRadiusAField,
    $capsuleColliderRadiusBField,
    $capsuleColliderLengthField,
    $capsuleColliderOffsetField,
    $capsuleColliderPivotMenuGrp,

    $infinitePlaneColliderFrame,
    $infinitePlaneColliderWidthField,
    $infinitePlaneColliderHeightField,

    $sphereColliderFrame,
    $sphereColliderRadiusField,

    $meshNodeList,
    $forceNodeList,
    $forceVectorRadioButton,
    $invertForceVectorCheckBox,
    $offsetNodeList,

    $bindNodeList,
    $bakeTimeRangeRadioButton,
    $bakeStartEndField
  });

  loadBdnPlugin();
  subscribeMainWindowObservers();
  updateBdnNodeList();
  showWindow $nkBdnEditorWindow;
  setFocus $nkBdnEditorWindow;
}

// -----------------------------------------------------------------------------
// イベントコントローラ
// -----------------------------------------------------------------------------
/*-
@param $window <string>
@param $event <string>
@param $control <string>
@returns <>
*/
global proc nkBdnEditorEventController(
  string $window,
  string $event,
  string $control
) {
  // print("nkBdnEditorEventController\n"); // debug
  // print("  window :" + $window + "\n"); // debug
  // print("  event  :" + $event + "\n"); // debug
  // print("  control:" + $control + "\n"); // debug
  switch ($window) {
    case "nkBdnEditorWindow":
      switch ($event) {
        case "c":
          switch ($control) {
            case "resetWindowMenuItem": resetWindowMenuItemSelected(); break;
            case "quitMenuItem": quitMenuItemSelected(); break;
            case "refreshMenuItem": refreshMenuItemSelected(); break;
            case "aboutMenuItem": aboutMenuItemSelected(); break;

            case "selectBdnNodesButton": selectBdnNodesButtonPressed(); break;
            case "substituteBdnNodesButton": substituteBdnNodesButtonPressed(); break;
            case "restoreBdnNodesButton": restoreBdnNodesButtonPressed(); break;

            case "bdnAttributeInitializeButton": bdnAttributeInitializeButtonPressed(); break;
            case "bdnAttributeExportButton": bdnAttributeExportButtonPressed(); break;
            case "bdnAttributeImportButton": bdnAttributeImportButtonPressed(); break;
            case "bdnAttributeCopyButton": bdnAttributeCopyButtonPressed(); break;
            case "bdnAttributePasteButton": bdnAttributePasteButtonPressed(); break;

            case "generateDynamicsUnitButton": generateDynamicsUnitButtonPressed(); break;

            case "showDynamicsNodesButton": showDynamicsNodesButtonPressed(); break;
            case "hideDynamicsNodesButton": hideDynamicsNodesButtonPressed(); break;
            case "selectDynamicsNodesButton": selectDynamicsNodesButtonPressed(); break;

            case "showTargetNodesButton": showTargetNodesButtonPressed(); break;
            case "hideTargetNodesButton": hideTargetNodesButtonPressed(); break;
            case "selectTargetNodesButton": selectTargetNodesButtonPressed(); break;

            case "createColliderCapsuleButton": createColliderCapsuleButtonPressed(); break;
            case "createColliderInfinitePlaneButton": createColliderInfinitePlaneButtonPressed(); break;
            case "createColliderSphereButton": createColliderSphereButtonPressed(); break;

            case "showInfluencedColliderNodesButton": showInfluencedColliderNodesButtonPressed(); break;
            case "hideInfluencedColliderNodesButton": hideInfluencedColliderNodesButtonPressed(); break;
            case "selectInfluencedColliderNodesButton": selectInfluencedColliderNodesButtonPressed(); break;
            case "removeColliderButton": removeColliderButtonPressed(); break;

            case "allColliderExportButton": allColliderExportButtonPressed(); break;
            case "allColliderImportButton": allColliderImportButtonPressed(); break;
            case "showAllColliderNodesButton": showAllColliderNodesButtonPressed(); break;
            case "hideAllColliderNodesButton": hideAllColliderNodesButtonPressed(); break;
            case "selectAllColliderNodesButton": selectAllColliderNodesButtonPressed(); break;
            case "appendColliderButton": appendColliderButtonPressed(); break;

            case "capsuleColliderInitializeButton": capsuleColliderInitializeButtonPressed(); break;
            case "capsuleColliderCopyButton": capsuleColliderCopyButtonPressed(); break;
            case "capsuleColliderPasteButton": capsuleColliderPasteButtonPressed(); break;
            case "infinitePlaneColliderInitializeButton": infinitePlaneColliderInitializeButtonPressed(); break;
            case "infinitePlaneColliderCopyButton": infinitePlaneColliderCopyButtonPressed(); break;
            case "infinitePlaneColliderPasteButton": infinitePlaneColliderPasteButtonPressed(); break;
            case "sphereColliderInitializeButton": sphereColliderInitializeButtonPressed(); break;
            case "sphereColliderCopyButton": sphereColliderCopyButtonPressed(); break;
            case "sphereColliderPasteButton": sphereColliderPasteButtonPressed(); break;

            case "showMeshNodesButton": showMeshNodesButtonPressed(); break;
            case "hideMeshNodesButton": hideMeshNodesButtonPressed(); break;
            case "selectMeshNodesButton": selectMeshNodesButtonPressed(); break;
            case "appendMeshNodesButton": appendMeshNodesButtonPressed(); break;
            case "removeMeshNodesButton": removeMeshNodesButtonPressed(); break;

            case "showForceNodesButton": showForceNodesButtonPressed(); break;
            case "hideForceNodesButton": hideForceNodesButtonPressed(); break;
            case "selectForceNodesButton": selectForceNodesButtonPressed(); break;
            case "connectForceNodeButton": connectForceNodeButtonPressed(); break;
            case "disconnectForceNodeButton": disconnectForceNodeButtonPressed(); break;

            case "showOffsetNodesButton": showOffsetNodesButtonPressed(); break;
            case "hideOffsetNodesButton": hideOffsetNodesButtonPressed(); break;
            case "selectOffsetNodesButton": selectOffsetNodesButtonPressed(); break;
            case "connectOffsetNodeButton": connectOffsetNodeButtonPressed(); break;
            case "disconnectOffsetNodeButton": disconnectOffsetNodeButtonPressed(); break;

            case "showBindNodesButton": showBindNodesButtonPressed(); break;
            case "hideBindNodesButton": hideBindNodesButtonPressed(); break;
            case "selectBindNodesButton": selectBindNodesButtonPressed(); break;
            case "bakeButton": bakeButtonPressed(); break;
            case "rebindButton": rebindButtonPressed(); break;
          }
          break;
        case "cc":
          switch ($control) {
            case "nkBdnEditorWindow": nkBdnEditorWindowClosed(); break;
            case "bdnRelatedNodeTab": bdnRelatedNodeTabChanged(); break;

            case "bdnEnableCheckBox": bdnEnableCheckBoxChanged(); break;
            case "bdnResetTimeField": bdnResetTimeFieldChanged(); break;
            case "bdnFpsField": bdnFpsFieldChanged(); break;
            case "bdnOffsetMatrixWeightField": bdnOffsetMatrixWeightFieldChanged(); break;
            case "bdnDampingField": bdnDampingFieldChanged(); break;
            case "bdnElasticityField": bdnElasticityFieldChanged(); break;
            case "elasticForceFunctionMenuGrp": elasticForceFunctionMenuGrpChanged(); break;
            case "bdnStiffnessField": bdnStiffnessFieldChanged(); break;
            case "bdnMassField": bdnMassFieldChanged(); break;
            case "bdnGravityXField": bdnGravityXFieldChanged(); break;
            case "bdnGravityYField": bdnGravityYFieldChanged(); break;
            case "bdnGravityZField": bdnGravityZFieldChanged(); break;
            case "bdnGravityMultiplyField": bdnGravityMultiplyFieldChanged(); break;
            case "bdnAdditionalForceScaleField": bdnAdditionalForceScaleFieldChanged(); break;
            case "bdnEnableTurbulenceCheckBox": bdnEnableTurbulenceCheckBoxChanged(); break;
            case "bdnTurbulenceSeedField": bdnTurbulenceSeedFieldChanged(); break;
            case "bdnTurbulenceStrengthField": bdnTurbulenceStrengthFieldChanged(); break;
            case "bdnTurbulenceVectorChangeScaleField": bdnTurbulenceVectorChangeScaleFieldChanged(); break;
            case "bdnTurbulenceVectorChangeMaxField": bdnTurbulenceVectorChangeMaxFieldChanged(); break;
            case "bdnEnableAngleLimitCheckBox": bdnEnableAngleLimitCheckBoxChanged(); break;
            case "bdnAngleLimitField": bdnAngleLimitFieldChanged(); break;
            case "bdnRadiusField": bdnRadiusFieldChanged(); break;
            case "bdnIterationsField": bdnIterationsFieldChanged(); break;
            case "bdnEnableGroundColCheckBox": bdnEnableGroundColCheckBoxChanged(); break;
            case "bdnGroundHeightField": bdnGroundHeightFieldChanged(); break;
            case "bdnMeshColCutoffField": bdnMeshColCutoffFieldChanged(); break;

            case "capsuleColliderRadiusAField": capsuleColliderRadiusAFieldChanged(); break;
            case "capsuleColliderRadiusBField": capsuleColliderRadiusBFieldChanged(); break;
            case "capsuleColliderLengthField": capsuleColliderLengthFieldChanged(); break;
            case "capsuleColliderOffsetField": capsuleColliderOffsetFieldChanged(); break;
            case "capsuleColliderPivotMenuGrp": capsuleColliderPivotMenuGrpChanged(); break;
            case "infinitePlaneColliderWidthField": infinitePlaneColliderWidthFieldChanged(); break;
            case "infinitePlaneColliderHeightField": infinitePlaneColliderHeightFieldChanged(); break;
            case "sphereColliderRadiusField": sphereColliderRadiusFieldChanged(); break;

            case "invertForceVectorCheckBox": invertForceVectorCheckBoxChanged(); break;
            default: break;
          }
          break;
        case "dc":
          switch ($control) {
            case "bdnRadiusField": bdnRadiusFieldChanged(); break;
            case "infinitePlaneColliderWidthField": infinitePlaneColliderWidthFieldChanged(); break;
            case "infinitePlaneColliderHeightField": infinitePlaneColliderHeightFieldChanged(); break;
            case "sphereColliderRadiusField": sphereColliderRadiusFieldChanged(); break;
            case "capsuleColliderRadiusAField": capsuleColliderRadiusAFieldChanged(); break;
            case "capsuleColliderRadiusBField": capsuleColliderRadiusBFieldChanged(); break;
            case "capsuleColliderLengthField": capsuleColliderLengthFieldChanged(); break;
            case "capsuleColliderOffsetField": capsuleColliderOffsetFieldChanged(); break;
            default: break;
          }
          break;
        case "dcc":
          switch ($control) {
            case "bdnNodeList": bdnNodeListDoubleClicked(); break;
            case "dynamicsNodeList": dynamicsNodeListDoubleClicked(); break;
            case "targetNodeList": targetNodeListDoubleClicked(); break;
            case "influencedColliderNodeList": influencedColliderNodeListDoubleClicked(); break;
            case "allColliderNodeList": allColliderNodeListDoubleClicked(); break;
            case "meshNodeList": meshNodeListDoubleClicked(); break;
            case "forceNodeList": forceNodeListDoubleClicked(); break;
            case "offsetNodeList": offsetNodeListDoubleClicked(); break;
            case "bindNodeList": bindNodeListDoubleClicked(); break;
            default: break;
          }
          break;
        case "onc":
          switch ($control) {
            case "forceVectorRadioButton": forceVectorRadioButtonOnned(); break;
            default: break;
          }
          break;
        case "sc":
          switch ($control) {
            case "bdnNodeList": bdnNodeListSelected(); break;
            case "dynamicsNodeList": dynamicsNodeListSelected(); break;
            case "targetNodeList": targetNodeListSelected(); break;
            case "influencedColliderNodeList": influencedColliderNodeListSelected(); break;
            case "allColliderNodeList": allColliderNodeListSelected(); break;
            case "meshNodeList": meshNodeListSelected(); break;
            case "forceNodeList": forceNodeListSelected(); break;
            case "offsetNodeList": offsetNodeListSelected(); break;
            case "bindNodeList": bindNodeListSelected(); break;
            default: break;
          }
          break;
        default: break;
      }
      break;
    default: break;
  }
}

// /////////////////////////////////////////////////////////////////////////////
// オブザーバ
// /////////////////////////////////////////////////////////////////////////////
// -----------------------------------------------------------------------------
// ドメインオブザーバ
// -----------------------------------------------------------------------------
/*-
@returns <>
*/
global proc nkBdnEditorDynamicsNodeCreated() {
  // print("nkBdnEditorDynamicsNodeCreated\n"); // debug
  updateBdnNodeList();
}

/*-
@returns <>
*/
global proc nkBdnEditorBdnAttributeChanged() {
  // print("nkBdnEditorBdnAttributeChanged\n"); // debug
  updateBdnAttributeUI();
}

/*-
@returns <>
*/
global proc nkBdnEditorBdnColliderConnectionChanged() {
  // print("nkBdnEditorBdnColliderConnectionChanged\n"); // debug
  updateInfluencedColliderNodeList(getSelectedBdnNodes());
}

/*-
@returns <>
*/
global proc nkBdnEditorBdnMeshConnectionChanged() {
  // print("nkBdnEditorBdnMeshConnectionChanged\n"); // debug
  updateMeshNodeList(getSelectedBdnNodes());
}

/*-
@returns <>
*/
global proc nkBdnEditorBdnForceConnectionChanged() {
  // print("nkBdnEditorBdnForceConnectionChanged\n"); // debug
  updateForceNodeList(getSelectedBdnNodes());
}

/*-
@returns <>
*/
global proc nkBdnEditorBdnOffsetConnectionChanged() {
  // print("nkBdnEditorBdnOffsetConnectionChanged\n"); // debug
  updateOffsetNodeList(getSelectedBdnNodes());
}

/*-
@returns <>
*/
global proc nkBdnEditorColliderCreated() {
  // print("nkBdnEditorColliderCreated\n"); // debug
  updateAllColliderNodeList();
}

/*-
@returns <>
*/
global proc nkBdnEditorColliderAttributeChanged() {
  // print("nkBdnEditorColliderAttributeChanged\n"); // debug
  updateColliderAttributeUI();
}

/*-
@returns <>
*/
global proc nkBdnEditorForceAttributeChanged() {
  // print("nkBdnEditorForceAttributeChanged\n"); // debug
  updateForceAttributeUI();
}

// -----------------------------------------------------------------------------
// イベントオブザーバ
// -----------------------------------------------------------------------------
/*-
@returns <>
*/
global proc nkBdnEditorNewSceneOpened() {
  // print("nkBdnEditorNewSceneOpened\n"); // debug
  updateBdnNodeList();
}

/*-
@returns <>
*/
global proc nkBdnEditorPostSceneRead() {
  // print("nkBdnEditorPostSceneRead\n"); // debug
  updateBdnNodeList();
}

/*-
@returns <>
*/
global proc nkBdnEditorTimeChanged() {
  // print("nkBdnEditorTimeChanged\n"); // debug
  updateBdnAttributeUI();
}

// /*-
// @param $nodes <string[]>
// @returns <>
// */
// global proc nkBdnEditorNodeAdded(string $nodes[]) {
//   print("nkBdnEditorNodeAdded\n"); // debug
//   print("  nodes:{\n    " + stringArrayToString($nodes, ",\n    ") + "\n  }\n"); // debug
// }

/*-
@param $nodes <string[]>
@returns <>
*/
global proc nkBdnEditorNodeRemoved(string $nodes[]) {
  // print("nkBdnEditorNodeRemoved\n"); // debug
  // print("  nodes:{\n    " + stringArrayToString($nodes, ",\n    ") + "\n  }\n"); // debug
  updateBdnNodeList();
}

// -----------------------------------------------------------------------------
// ノードオブザーバ
// -----------------------------------------------------------------------------

// /////////////////////////////////////////////////////////////////////////////
// メイン
// /////////////////////////////////////////////////////////////////////////////
/*-
@returns <string>
*/
global proc string nkBdnEditorVersion() {
  return "1.1.0";
}

/*-
@returns <>
*/
global proc nkBdnEditor() {
  if (!loadBdnPlugin()) {
    confirmDialog
        -b "OK" -cb "OK" -db "OK" -ds "OK"
        -m "boneDynamicsNode is required.\n\nhttps://github.com/akasaki1211/boneDynamicsNode"
        -t "nkBdnEditor";
    return;
  }

  buildMainWindow();
  registerEventJob();
}

/*
eval ("source \"" + `getenv "MAYA_APP_DIR"` + "/dev/nkBdnEditor/nkBdnEditor.mel\"");
nkBdnEditor;
*/

// /////////////////////////////////////////////////////////////////////////////
// テスト
// /////////////////////////////////////////////////////////////////////////////
/*-
@returns <>
@remarks プラグイン。
*/
proc test0() {
  print("test0 start\n");
  string $r;

  // isBdnPluginLoaded / loadBdnPlugin / unloadBdnPlugin
  {
    // catchQuiet(`loadPlugin "boneDynamicsNode"`);
    testNewScene();
    catchQuiet(`unloadPlugin -f "boneDynamicsNode"`);

    $r = assertFalse(isBdnPluginLoaded()); if (`size $r`) warning $r;
    $r = assertTrue(loadBdnPlugin()); if (`size $r`) warning $r;
    $r = assertTrue(isBdnPluginLoaded()); if (`size $r`) warning $r;
    $r = assertTrue(unloadBdnPlugin()); if (`size $r`) warning $r;
    $r = assertFalse(isBdnPluginLoaded()); if (`size $r`) warning $r;
    $r = assertStringMatch("^[0-9]+\.[0-9]+\.[0-9]+$", getBdnPluginVersion()); if (`size $r`) warning $r;
  }

  print("test0 end\n");
}

/*-
@returns <>
@remarks ノード。
*/
proc test1() {
  print("test1 start\n");
  string $r;
  string $n;

  // getTimeNode
  {
    // catchQuiet(`loadPlugin "boneDynamicsNode"`);
    testNewScene();
    catchQuiet(`unloadPlugin -f "boneDynamicsNode"`);

    string $t = getTimeNode();
    $r = assertStringEqual("time1", $t); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $t`); if (`size $r`) warning $r;

    if (`objExists $n`) delete $n;
  }

  print("test1 end\n");
}

/*-
@returns <>
@remarks アトリビュート。
*/
proc test2() {
  print("test2 start\n");
  string $r;

  // unlockTransformAttributes
  {
    // catchQuiet(`loadPlugin "boneDynamicsNode"`);
    testNewScene();
    catchQuiet(`unloadPlugin -f "boneDynamicsNode"`);

    $n = longNameOf(`createNode -ss "transform"`);

    $r = assertTrue(unlockTransformAttributes($n, true, true, true)); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l ($n + ".tx")`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l ($n + ".ty")`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l ($n + ".tz")`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l ($n + ".rx")`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l ($n + ".ry")`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l ($n + ".rz")`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l ($n + ".sx")`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l ($n + ".sy")`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l ($n + ".sz")`); if (`size $r`) warning $r;

    batchSetAttributeLock({$n}, {"tx", "ty", "tz", "rx", "ry", "rz", "sx", "sy", "sz"}, true);
    $r = assertTrue(`getAttr -l ($n + ".tx")`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l ($n + ".ty")`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l ($n + ".tz")`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l ($n + ".rx")`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l ($n + ".ry")`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l ($n + ".rz")`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l ($n + ".sx")`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l ($n + ".sy")`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l ($n + ".sz")`); if (`size $r`) warning $r;

    $r = assertTrue(unlockTransformAttributes($n, true, true, false)); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l ($n + ".tx")`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l ($n + ".ty")`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l ($n + ".tz")`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l ($n + ".rx")`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l ($n + ".ry")`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l ($n + ".rz")`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l ($n + ".sx")`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l ($n + ".sy")`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l ($n + ".sz")`); if (`size $r`) warning $r;

    if (`objExists $n`) delete $n;
  }

  print("test2 end\n");
}

/*-
@returns <>
@remarks BDNノード。
*/
proc test3() {
  print("test3 start\n");
  string $r;
  string $n;

  string $mayaAppDir = `getenv "MAYA_APP_DIR"`;
  string $groupFilename = $mayaAppDir + "/dev/nkBdnEditor/test/group.ma";
  string $nodeFilename = $mayaAppDir + "/dev/nkBdnEditor/test/node.ma";

  string $bgrp0 = "|i:BDN_GRP0";
  string $pgrp0 = "|i:BDN_GRP0|Dynamics_GRP";
  string $pspc0 = "|i:BDN_GRP0|Dynamics_GRP|Dynamics_SPC";
  string $tgrp0 = "|i:BDN_GRP0|Target_GRP";
  string $tspc0 = "|i:BDN_GRP0|Target_GRP|Target_SPC";
  string $cgrp0 = "|i:BDN_GRP0|Collider_GRP";
  string $cspc0 = "|i:BDN_GRP0|Collider_GRP|Collider_SPC";
  string $bgrp1 = "|j:BDN_GRP1";
  string $pgrp1 = "|j:BDN_GRP1|Dynamics_GRP";
  string $pspc1 = "|j:BDN_GRP1|Dynamics_GRP|Dynamics_SPC";
  string $tgrp1 = "|j:BDN_GRP1|Target_GRP";
  string $tspc1 = "|j:BDN_GRP1|Target_GRP|Target_SPC";
  string $cgrp1 = "|j:BDN_GRP1|Collider_GRP";
  string $cspc1 = "|j:BDN_GRP1|Collider_GRP|Collider_SPC";
  string $bgrp2 = "|k:BDN_GRP2";
  string $pgrp2 = "|k:BDN_GRP2|Dynamics_GRP";
  string $pspc2 = "|k:BDN_GRP2|Dynamics_GRP|Dynamics_SPC";
  string $tgrp2 = "|k:BDN_GRP2|Target_GRP";
  string $tspc2 = "|k:BDN_GRP2|Target_GRP|Target_SPC";
  string $cgrp2 = "|k:BDN_GRP2|Collider_GRP";
  string $cspc2 = "|k:BDN_GRP2|Collider_GRP|Collider_SPC";

  string $bgrp0m = "|i:BDN_GRP";
  string $pgrp0m = "|i:BDN_GRP|Dynamics_GRP";
  string $pspc0m = "|i:BDN_GRP|Dynamics_GRP|Dynamics_SPC";
  string $tgrp0m = "|i:BDN_GRP|Target_GRP";
  string $tspc0m = "|i:BDN_GRP|Target_GRP|Target_SPC";
  string $cgrp0m = "|i:BDN_GRP|Collider_GRP";
  string $cspc0m = "|i:BDN_GRP|Collider_GRP|Collider_SPC";
  string $pspc1m = "|i:BDN_GRP|Dynamics_GRP|Dynamics_SPC1";
  string $tspc1m = "|i:BDN_GRP|Target_GRP|Target_SPC1";
  string $cspc1m = "|i:BDN_GRP|Collider_GRP|Collider_SPC1";
  string $pspc2m = "|i:BDN_GRP|Dynamics_GRP|Dynamics_SPC2";
  string $tspc2m = "|i:BDN_GRP|Target_GRP|Target_SPC2";
  string $cspc2m = "|i:BDN_GRP|Collider_GRP|Collider_SPC2";

  string $rbgrp0 = "|referenced:a:BDN_GRP0";
  string $rpgrp0 = "|referenced:a:BDN_GRP0|referenced:Dynamics_GRP";
  string $rpspc0 = "|referenced:a:BDN_GRP0|referenced:Dynamics_GRP|referenced:Dynamics_SPC";
  string $rtgrp0 = "|referenced:a:BDN_GRP0|referenced:Target_GRP";
  string $rtspc0 = "|referenced:a:BDN_GRP0|referenced:Target_GRP|referenced:Target_SPC";
  string $rcgrp0 = "|referenced:a:BDN_GRP0|referenced:Collider_GRP";
  string $rcspc0 = "|referenced:a:BDN_GRP0|referenced:Collider_GRP|referenced:Collider_SPC";
  string $rbgrp1 = "|referenced:b:BDN_GRP1";
  string $rpgrp1 = "|referenced:b:BDN_GRP1|referenced:Dynamics_GRP";
  string $rpspc1 = "|referenced:b:BDN_GRP1|referenced:Dynamics_GRP|referenced:Dynamics_SPC";
  string $rtgrp1 = "|referenced:b:BDN_GRP1|referenced:Target_GRP";
  string $rtspc1 = "|referenced:b:BDN_GRP1|referenced:Target_GRP|referenced:Target_SPC";
  string $rcgrp1 = "|referenced:b:BDN_GRP1|referenced:Collider_GRP";
  string $rcspc1 = "|referenced:b:BDN_GRP1|referenced:Collider_GRP|referenced:Collider_SPC";
  string $rbgrp2 = "|referenced:c:BDN_GRP2";
  string $rpgrp2 = "|referenced:c:BDN_GRP2|referenced:Dynamics_GRP";
  string $rpspc2 = "|referenced:c:BDN_GRP2|referenced:Dynamics_GRP|referenced:Dynamics_SPC";
  string $rtgrp2 = "|referenced:c:BDN_GRP2|referenced:Target_GRP";
  string $rtspc2 = "|referenced:c:BDN_GRP2|referenced:Target_GRP|referenced:Target_SPC";
  string $rcgrp2 = "|referenced:c:BDN_GRP2|referenced:Collider_GRP";
  string $rcspc2 = "|referenced:c:BDN_GRP2|referenced:Collider_GRP|referenced:Collider_SPC";

  string $bdn1 = "CTL_joint1_Dynamics_BDN";
  string $bdn2 = "CTL_joint2_Dynamics_BDN";
  string $bdn3 = "CTL_joint3_Dynamics_BDN";

  string $ccp = "|BDN_GRP|Collider_GRP|CapsuleCollider_SPC";
  string $cc = "|BDN_GRP|Collider_GRP|CapsuleCollider_SPC|CapsuleCollider";
  string $ccc1 = "|BDN_GRP|Collider_GRP|CapsuleCollider_SPC|CapsuleCollider|CapsuleCollider_SphereA";
  string $ccc2 = "|BDN_GRP|Collider_GRP|CapsuleCollider_SPC|CapsuleCollider|CapsuleCollider_SphereB";
  string $ccc3 = "|BDN_GRP|Collider_GRP|CapsuleCollider_SPC|CapsuleCollider|CapsuleCollider_CircleA";
  string $ccc4 = "|BDN_GRP|Collider_GRP|CapsuleCollider_SPC|CapsuleCollider|CapsuleCollider_CircleB";
  string $ccc5 = "|BDN_GRP|Collider_GRP|CapsuleCollider_SPC|CapsuleCollider|CapsuleCollider_Loft";

  string $icp = "|BDN_GRP|Collider_GRP|InfinitePlaneCollider_SPC";
  string $ic = "|BDN_GRP|Collider_GRP|InfinitePlaneCollider_SPC|InfinitePlaneCollider";

  string $scp = "|BDN_GRP|Collider_GRP|SphereCollider_SPC";
  string $sc = "|BDN_GRP|Collider_GRP|SphereCollider_SPC|SphereCollider";

  string $m1t = "|pCube1";
  string $m1 = "|pCube1|pCubeShape1";
  string $m2t = "|pTorus1";
  string $m2 = "|pTorus1|pTorusShape1";

  // initGroupNode
  {
    catchQuiet(`loadPlugin "boneDynamicsNode"`);
    testNewScene();
    // catchQuiet(`unloadPlugin -f "boneDynamicsNode"`);

    $n = longNameOf(`createNode -ss "transform"`);

    $r = assertStringEqual($n, initGroupNode($n, "x")); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $n`); if (`size $r`) warning $r;
    $r = assertStringEqual("type=\"group\";groupType=\"x\";", getDictValue($n, "bdnData")); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l ($n + ".bdnData")`); if (`size $r`) warning $r;

    if (`objExists $n`) delete $n;
  }

  // initSpaceNode
  {
    catchQuiet(`loadPlugin "boneDynamicsNode"`);
    testNewScene();
    // catchQuiet(`unloadPlugin -f "boneDynamicsNode"`);

    $n = longNameOf(`createNode -ss "transform"`);

    $r = assertStringEqual($n, initSpaceNode($n, "x")); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $n`); if (`size $r`) warning $r;
    $r = assertStringEqual("type=\"space\";spaceType=\"x\";", getDictValue($n, "bdnData")); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l ($n + ".bdnData")`); if (`size $r`) warning $r;

    if (`objExists $n`) delete $n;
  }

  // initAltNode
  {
    catchQuiet(`loadPlugin "boneDynamicsNode"`);
    testNewScene();
    // catchQuiet(`unloadPlugin -f "boneDynamicsNode"`);

    $n = longNameOf(`createNode -ss "transform"`);

    $r = assertStringEqual($n, initAltNode($n, "x")); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $n`); if (`size $r`) warning $r;
    $r = assertStringMatch("^type=\"alt\";sourceName=\"x\";bdnVersion=\"[0-9]+\.[0-9]+\.[0-9]+\";$", getDictValue($n, "bdnData")); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l ($n + ".bdnData")`); if (`size $r`) warning $r;

    if (`objExists $n`) delete $n;
  }

  // initJointNode
  {
    catchQuiet(`loadPlugin "boneDynamicsNode"`);
    testNewScene();
    // catchQuiet(`unloadPlugin -f "boneDynamicsNode"`);

    $n = longNameOf(`createNode -ss "transform"`);

    $r = assertStringEqual($n, initJointNode($n, "x", "y")); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $n`); if (`size $r`) warning $r;
    $r = assertStringEqual("type=\"joint\";jointKind=\"x\";jointType=\"y\";", getDictValue($n, "bdnData")); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l ($n + ".bdnData")`); if (`size $r`) warning $r;

    if (`objExists $n`) delete $n;
  }

  // initRadiusNode
  {
    catchQuiet(`loadPlugin "boneDynamicsNode"`);
    testNewScene();
    // catchQuiet(`unloadPlugin -f "boneDynamicsNode"`);

    $n = longNameOf(`createNode -ss "transform"`);

    $r = assertStringEqual($n, initRadiusNode($n)); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $n`); if (`size $r`) warning $r;
    $r = assertStringEqual("type=\"radius\";", getDictValue($n, "bdnData")); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l ($n + ".bdnData")`); if (`size $r`) warning $r;

    if (`objExists $n`) delete $n;
  }

  // initColliderNode
  {
    catchQuiet(`loadPlugin "boneDynamicsNode"`);
    testNewScene();
    // catchQuiet(`unloadPlugin -f "boneDynamicsNode"`);

    $n = longNameOf(`createNode -ss "transform"`);

    $r = assertStringEqual($n, initColliderNode($n, "x")); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $n`); if (`size $r`) warning $r;
    $r = assertStringEqual("type=\"collider\";colliderType=\"x\";", getDictValue($n, "bdnData")); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l ($n + ".bdnData")`); if (`size $r`) warning $r;

    if (`objExists $n`) delete $n;
  }

  // initColliderComponentNode
  {
    catchQuiet(`loadPlugin "boneDynamicsNode"`);
    testNewScene();
    // catchQuiet(`unloadPlugin -f "boneDynamicsNode"`);

    $n = longNameOf(`createNode -ss "transform"`);

    $r = assertStringEqual($n, initColliderComponentNode($n)); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $n`); if (`size $r`) warning $r;
    $r = assertStringEqual("type=\"colliderComponent\";", getDictValue($n, "bdnData")); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l ($n + ".bdnData")`); if (`size $r`) warning $r;

    if (`objExists $n`) delete $n;
  }

  // initForceNode
  {
    catchQuiet(`loadPlugin "boneDynamicsNode"`);
    testNewScene();
    // catchQuiet(`unloadPlugin -f "boneDynamicsNode"`);

    $n = longNameOf(`createNode -ss "transform"`);

    $r = assertStringEqual($n, initForceNode($n)); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $n`); if (`size $r`) warning $r;
    $r = assertStringEqual("type=\"force\";", getDictValue($n, "bdnData")); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l ($n + ".bdnData")`); if (`size $r`) warning $r;

    if (`objExists $n`) delete $n;
  }

  // getBdnType / isBdnType
  {
    catchQuiet(`loadPlugin "boneDynamicsNode"`);
    testNewScene();
    // catchQuiet(`unloadPlugin -f "boneDynamicsNode"`);

    $n = longNameOf(`createNode -ss "transform"`);
    initGroupNode($n, "x");
    $r = assertStringEqual("group", getBdnType($n)); if (`size $r`) warning $r;
    $r = assertTrue(isBdnType($n, "group")); if (`size $r`) warning $r;
    if (`objExists $n`) delete $n;

    $n = longNameOf(`createNode -ss "transform"`);
    initSpaceNode($n, "x");
    $r = assertStringEqual("space", getBdnType($n)); if (`size $r`) warning $r;
    $r = assertTrue(isBdnType($n, "space")); if (`size $r`) warning $r;
    if (`objExists $n`) delete $n;

    $n = longNameOf(`createNode -ss "transform"`);
    initAltNode($n, "x");
    $r = assertStringEqual("alt", getBdnType($n)); if (`size $r`) warning $r;
    $r = assertTrue(isBdnType($n, "alt")); if (`size $r`) warning $r;
    if (`objExists $n`) delete $n;

    $n = longNameOf(`createNode -ss "transform"`);
    initJointNode($n, "x", "y");
    $r = assertStringEqual("joint", getBdnType($n)); if (`size $r`) warning $r;
    $r = assertTrue(isBdnType($n, "joint")); if (`size $r`) warning $r;
    if (`objExists $n`) delete $n;

    $n = longNameOf(`createNode -ss "transform"`);
    initRadiusNode($n);
    $r = assertStringEqual("radius", getBdnType($n)); if (`size $r`) warning $r;
    $r = assertTrue(isBdnType($n, "radius")); if (`size $r`) warning $r;
    if (`objExists $n`) delete $n;

    $n = longNameOf(`createNode -ss "transform"`);
    initColliderNode($n, "x");
    $r = assertStringEqual("collider", getBdnType($n)); if (`size $r`) warning $r;
    $r = assertTrue(isBdnType($n, "collider")); if (`size $r`) warning $r;
    if (`objExists $n`) delete $n;

    $n = longNameOf(`createNode -ss "transform"`);
    initColliderComponentNode($n);
    $r = assertStringEqual("colliderComponent", getBdnType($n)); if (`size $r`) warning $r;
    $r = assertTrue(isBdnType($n, "colliderComponent")); if (`size $r`) warning $r;
    if (`objExists $n`) delete $n;

    $n = longNameOf(`createNode -ss "transform"`);
    initForceNode($n);
    $r = assertStringEqual("force", getBdnType($n)); if (`size $r`) warning $r;
    $r = assertTrue(isBdnType($n, "force")); if (`size $r`) warning $r;
    if (`objExists $n`) delete $n;
  }

  // getGroupType / isGroupType
  {
    catchQuiet(`loadPlugin "boneDynamicsNode"`);
    testNewScene();
    // catchQuiet(`unloadPlugin -f "boneDynamicsNode"`);

    $n = longNameOf(`createNode -ss "transform"`);
    initGroupNode($n, "x");
    $r = assertStringEqual("x", getGroupType($n)); if (`size $r`) warning $r;
    $r = assertTrue(isGroupType($n, "x")); if (`size $r`) warning $r;
    if (`objExists $n`) delete $n;

    $n = longNameOf(`createNode -ss "transform"`);
    initSpaceNode($n, "x");
    $r = assertStringEqual("", getGroupType($n)); if (`size $r`) warning $r;
    $r = assertFalse(isGroupType($n, "x")); if (`size $r`) warning $r;
    if (`objExists $n`) delete $n;
  }

  // getSpaceType / isSpaceType
  {
    catchQuiet(`loadPlugin "boneDynamicsNode"`);
    testNewScene();
    // catchQuiet(`unloadPlugin -f "boneDynamicsNode"`);

    $n = longNameOf(`createNode -ss "transform"`);
    initGroupNode($n, "x");
    $r = assertStringEqual("", getSpaceType($n)); if (`size $r`) warning $r;
    $r = assertFalse(isSpaceType($n, "x")); if (`size $r`) warning $r;
    if (`objExists $n`) delete $n;

    $n = longNameOf(`createNode -ss "transform"`);
    initSpaceNode($n, "x");
    $r = assertStringEqual("x", getSpaceType($n)); if (`size $r`) warning $r;
    $r = assertTrue(isSpaceType($n, "x")); if (`size $r`) warning $r;
    if (`objExists $n`) delete $n;
  }

  // getJointKind / isJointKind / getJointType / isJointType
  {
    catchQuiet(`loadPlugin "boneDynamicsNode"`);
    testNewScene();
    // catchQuiet(`unloadPlugin -f "boneDynamicsNode"`);

    $n = longNameOf(`createNode -ss "transform"`);
    initSpaceNode($n, "x");
    $r = assertStringEqual("", getJointKind($n)); if (`size $r`) warning $r;
    $r = assertFalse(isJointKind($n, "x")); if (`size $r`) warning $r;
    $r = assertStringEqual("", getJointType($n)); if (`size $r`) warning $r;
    $r = assertFalse(isJointType($n, "y")); if (`size $r`) warning $r;
    if (`objExists $n`) delete $n;

    $n = longNameOf(`createNode -ss "transform"`);
    initJointNode($n, "x", "y");
    $r = assertStringEqual("x", getJointKind($n)); if (`size $r`) warning $r;
    $r = assertTrue(isJointKind($n, "x")); if (`size $r`) warning $r;
    $r = assertStringEqual("y", getJointType($n)); if (`size $r`) warning $r;
    $r = assertTrue(isJointType($n, "y")); if (`size $r`) warning $r;
    if (`objExists $n`) delete $n;
  }

  // getColliderType / isColliderType
  {
    catchQuiet(`loadPlugin "boneDynamicsNode"`);
    testNewScene();
    // catchQuiet(`unloadPlugin -f "boneDynamicsNode"`);

    $n = longNameOf(`createNode -ss "transform"`);
    initSpaceNode($n, "x");
    $r = assertStringEqual("", getColliderType($n)); if (`size $r`) warning $r;
    $r = assertFalse(isColliderType($n, "x")); if (`size $r`) warning $r;
    if (`objExists $n`) delete $n;

    $n = longNameOf(`createNode -ss "transform"`);
    initColliderNode($n, "x");
    $r = assertStringEqual("x", getColliderType($n)); if (`size $r`) warning $r;
    $r = assertTrue(isColliderType($n, "x")); if (`size $r`) warning $r;
    if (`objExists $n`) delete $n;
  }

  // getBdnGroupNodes / getEditableBdnGroupNode / getColliderGroupNodes / getEditableColliderGroupNode
  {
    catchQuiet(`loadPlugin "boneDynamicsNode"`);
    testOpenScene($groupFilename);
    // catchQuiet(`unloadPlugin -f "boneDynamicsNode"`);

    $r = assertStringArrayEqual({$bgrp0, $bgrp1, $bgrp2, $rbgrp0, $rbgrp1, $rbgrp2}, getBdnGroupNodes()); if (`size $r`) warning $r;
    $r = assertStringEqual($bgrp0, getEditableBdnGroupNode()); if (`size $r`) warning $r;
    $r = assertStringArrayEqual({$cgrp0, $cgrp1, $cgrp2, $rcgrp0, $rcgrp1, $rcgrp2}, getColliderGroupNodes()); if (`size $r`) warning $r;
    $r = assertStringEqual($cgrp0, getEditableColliderGroupNode()); if (`size $r`) warning $r;
  }

  // mergeEditableBdnGroupNodes
  {
    catchQuiet(`loadPlugin "boneDynamicsNode"`);
    testOpenScene($groupFilename);
    // catchQuiet(`unloadPlugin -f "boneDynamicsNode"`);

    $r = assertTrue(`objExists $bgrp0`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $pgrp0`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $pspc0`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $tgrp0`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $tspc0`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $cgrp0`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $cspc0`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $bgrp1`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $pgrp1`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $pspc1`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $tgrp1`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $tspc1`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $cgrp1`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $cspc1`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $bgrp2`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $pgrp2`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $pspc2`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $tgrp2`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $tspc2`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $cgrp2`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $cspc2`); if (`size $r`) warning $r;

    $r = assertFalse(`objExists $pspc1m`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $tspc1m`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $cspc1m`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $pspc2m`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $tspc2m`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $cspc2m`); if (`size $r`) warning $r;

    $r = assertTrue(`objExists $rbgrp0`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rpgrp0`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rpspc0`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rtgrp0`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rtspc0`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rcgrp0`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rcspc0`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rbgrp1`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rpgrp1`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rpspc1`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rtgrp1`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rtspc1`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rcgrp1`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rcspc1`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rbgrp2`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rpgrp2`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rpspc2`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rtgrp2`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rtspc2`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rcgrp2`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rcspc2`); if (`size $r`) warning $r;

    mergeEditableBdnGroupNodes();
    $r = assertFalse(`objExists $bgrp0`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $pgrp0`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $pspc0`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $tgrp0`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $tspc0`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $cgrp0`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $cspc0`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $bgrp1`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $pgrp1`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $pspc1`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $tgrp1`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $tspc1`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $cgrp1`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $cspc1`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $bgrp2`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $pgrp2`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $pspc2`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $tgrp2`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $tspc2`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $cgrp2`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $cspc2`); if (`size $r`) warning $r;

    $r = assertTrue(`objExists $bgrp0m`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $pgrp0m`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $pspc0m`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $tgrp0m`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $tspc0m`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $cgrp0m`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $cspc0m`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $pspc1m`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $tspc1m`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $cspc1m`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $pspc2m`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $tspc2m`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $cspc2m`); if (`size $r`) warning $r;

    $r = assertTrue(`objExists $rbgrp0`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rpgrp0`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rpspc0`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rtgrp0`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rtspc0`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rcgrp0`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rcspc0`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rbgrp1`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rpgrp1`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rpspc1`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rtgrp1`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rtspc1`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rcgrp1`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rcspc1`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rbgrp2`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rpgrp2`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rpspc2`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rtgrp2`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rtspc2`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rcgrp2`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $rcspc2`); if (`size $r`) warning $r;
  }

  // gatherBdnNodes / gatherColliderNodes / gatherMeshNodes
  {
    catchQuiet(`loadPlugin "boneDynamicsNode"`);
    testOpenScene($nodeFilename);
    // catchQuiet(`unloadPlugin -f "boneDynamicsNode"`);

    // gatherBdnNodes
    select -cl;
    $r = assertStringArrayEqual({$bdn1, $bdn2, $bdn3}, gatherBdnNodes(false)); if (`size $r`) warning $r;
    $r = assertStringArrayEqual({}, gatherBdnNodes(true)); if (`size $r`) warning $r;
    select -r {$bdn3, $bdn1};
    $r = assertStringArrayEqual({$bdn3, $bdn1}, gatherBdnNodes(true)); if (`size $r`) warning $r;

    // gatherColliderNodes
    select -cl;
    $r = assertStringArrayEqual({$cc, $ic, $sc}, gatherColliderNodes(false)); if (`size $r`) warning $r;
    $r = assertStringArrayEqual({}, gatherColliderNodes(true)); if (`size $r`) warning $r;
    select -r {$sc, $cc};
    $r = assertStringArrayEqual({$sc, $cc}, gatherColliderNodes(true)); if (`size $r`) warning $r;
    select -r {$ccp, $icp, $scp};
    $r = assertStringArrayEqual({$cc, $ic, $sc}, gatherColliderNodes(true)); if (`size $r`) warning $r;
    select -r {$ccc1};
    $r = assertStringArrayEqual({$cc}, gatherColliderNodes(true)); if (`size $r`) warning $r;
    select -r {$ccc2};
    $r = assertStringArrayEqual({$cc}, gatherColliderNodes(true)); if (`size $r`) warning $r;
    select -r {$ccc3};
    $r = assertStringArrayEqual({$cc}, gatherColliderNodes(true)); if (`size $r`) warning $r;
    select -r {$ccc4};
    $r = assertStringArrayEqual({$cc}, gatherColliderNodes(true)); if (`size $r`) warning $r;
    select -r {$ccc5};
    $r = assertStringArrayEqual({$cc}, gatherColliderNodes(true)); if (`size $r`) warning $r;

    // gatherMeshNodes
    select -cl;
    $r = assertStringArrayEqual({$m1, $m2}, gatherMeshNodes(false)); if (`size $r`) warning $r;
    $r = assertStringArrayEqual({}, gatherMeshNodes(true)); if (`size $r`) warning $r;
    select -r {$m1};
    $r = assertStringArrayEqual({$m1}, gatherMeshNodes(true)); if (`size $r`) warning $r;
    select -r {$m2t, $m1t};
    $r = assertStringArrayEqual({$m2, $m1}, gatherMeshNodes(true)); if (`size $r`) warning $r;
  }

  print("test3 end\n");
}

/*-
@returns <>
@remarks BDNアトリビュート。
*/
proc test4() {
  print("test4 start\n");
  global string $nkBdnEditorDefaultBdnAttribute;
  global string $nkBdnEditorBdnAttributeCache;

  string $r;
  string $n;
  string $bdn;
  string $dict;
  string $expectDict;

  string $mayaAppDir = `getenv "MAYA_APP_DIR"`;
  string $testBdnFilename = $mayaAppDir + "/dev/nkBdnEditor/test/test.bdn";

  // bdnAttributesToDict
  {
    catchQuiet(`loadPlugin "boneDynamicsNode"`);
    testNewScene();
    // catchQuiet(`unloadPlugin -f "boneDynamicsNode"`);

    $n = longNameOf(`createNode -ss "transform"`);
    $bdn = longNameOf(`createNode -ss "boneDynamicsNode"`);

    $dict = dictAddString(bdnAttributesToDict($n), "name", "");
    $r = assertStringEqual("name=\"\";", $dict); if (`size $r`) warning $r;
    $dict = dictAddString(bdnAttributesToDict($bdn), "name", "");
    $r = assertStringEqual($nkBdnEditorDefaultBdnAttribute, $dict); if (`size $r`) warning $r;

    if (`objExists $n`) delete $n;
    if (`objExists $bdn`) delete $bdn;
  }

  // applyDictToBdnAttributes
  {
    catchQuiet(`loadPlugin "boneDynamicsNode"`);
    testNewScene();
    // catchQuiet(`unloadPlugin -f "boneDynamicsNode"`);

    $bdn = longNameOf(`createNode -ss "boneDynamicsNode"`);

    setAttr ($bdn + ".damping") 0.9;
    setAttr ($bdn + ".elasticity") 45.0;
    setAttr ($bdn + ".elasticForceFunction") 2;
    setAttr ($bdn + ".stiffness") 0.3;
    setAttr ($bdn + ".mass") 1.5;
    setAttr ($bdn + ".gravityX") 10.0;
    setAttr ($bdn + ".gravityY") -780.0;
    setAttr ($bdn + ".gravityZ") 30.0;
    setAttr ($bdn + ".gravityMultiply") 0.2;
    setAttr ($bdn + ".additionalForceScale") 1.2;
    setAttr ($bdn + ".enableTurbulence") true;
    setAttr ($bdn + ".turbulenceSeed") 123;
    setAttr ($bdn + ".turbulenceStrength") 35.7;
    setAttr ($bdn + ".turbulenceVectorChangeScale") 1.25;
    setAttr ($bdn + ".turbulenceVectorChangeMax") 3.3;
    setAttr ($bdn + ".enableAngleLimit") true;
    setAttr ($bdn + ".angleLimit") 120.4;
    setAttr ($bdn + ".radius") 4.5;
    setAttr ($bdn + ".iterations") 3;
    setAttr ($bdn + ".enableGroundCol") true;
    setAttr ($bdn + ".groundHeight") 25.3;
    setAttr ($bdn + ".meshColCutoff") 12.8;
    $r = assertFloatEqual(0.9, `getAttr ($bdn + ".damping")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(45.0, `getAttr ($bdn + ".elasticity")`, 0.001); if (`size $r`) warning $r;
    $r = assertIntEqual(2, `getAttr ($bdn + ".elasticForceFunction")`); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.3, `getAttr ($bdn + ".stiffness")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(1.5, `getAttr ($bdn + ".mass")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(10.0, `getAttr ($bdn + ".gravityX")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(-780.0, `getAttr ($bdn + ".gravityY")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(30.0, `getAttr ($bdn + ".gravityZ")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.2, `getAttr ($bdn + ".gravityMultiply")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(1.2, `getAttr ($bdn + ".additionalForceScale")`, 0.001); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr ($bdn + ".enableTurbulence")`); if (`size $r`) warning $r;
    $r = assertIntEqual(123, `getAttr ($bdn + ".turbulenceSeed")`); if (`size $r`) warning $r;
    $r = assertFloatEqual(35.7, `getAttr ($bdn + ".turbulenceStrength")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(1.25, `getAttr ($bdn + ".turbulenceVectorChangeScale")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(3.3, `getAttr ($bdn + ".turbulenceVectorChangeMax")`, 0.001); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr ($bdn + ".enableAngleLimit")`); if (`size $r`) warning $r;
    $r = assertFloatEqual(120.4, `getAttr ($bdn + ".angleLimit")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(4.5, `getAttr ($bdn + ".radius")`, 0.001); if (`size $r`) warning $r;
    $r = assertIntEqual(3, `getAttr ($bdn + ".iterations")`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr ($bdn + ".enableGroundCol")`); if (`size $r`) warning $r;
    $r = assertFloatEqual(25.3, `getAttr ($bdn + ".groundHeight")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(12.8, `getAttr ($bdn + ".meshColCutoff")`, 0.001); if (`size $r`) warning $r;

    applyDictToBdnAttributes($nkBdnEditorDefaultBdnAttribute, {$bdn});
    $r = assertFloatEqual(0.1, `getAttr ($bdn + ".damping")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(30.0, `getAttr ($bdn + ".elasticity")`, 0.001); if (`size $r`) warning $r;
    $r = assertIntEqual(0, `getAttr ($bdn + ".elasticForceFunction")`); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.0, `getAttr ($bdn + ".stiffness")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(1.0, `getAttr ($bdn + ".mass")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.0, `getAttr ($bdn + ".gravityX")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(-980.0, `getAttr ($bdn + ".gravityY")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.0, `getAttr ($bdn + ".gravityZ")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.0, `getAttr ($bdn + ".gravityMultiply")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(1.0, `getAttr ($bdn + ".additionalForceScale")`, 0.001); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr ($bdn + ".enableTurbulence")`); if (`size $r`) warning $r;
    $r = assertIntEqual(0, `getAttr ($bdn + ".turbulenceSeed")`); if (`size $r`) warning $r;
    $r = assertFloatEqual(10.0, `getAttr ($bdn + ".turbulenceStrength")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.05, `getAttr ($bdn + ".turbulenceVectorChangeScale")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.1, `getAttr ($bdn + ".turbulenceVectorChangeMax")`, 0.001); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr ($bdn + ".enableAngleLimit")`); if (`size $r`) warning $r;
    $r = assertFloatEqual(60.0, `getAttr ($bdn + ".angleLimit")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.0, `getAttr ($bdn + ".radius")`, 0.001); if (`size $r`) warning $r;
    $r = assertIntEqual(5, `getAttr ($bdn + ".iterations")`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr ($bdn + ".enableGroundCol")`); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.0, `getAttr ($bdn + ".groundHeight")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(10.0, `getAttr ($bdn + ".meshColCutoff")`, 0.001); if (`size $r`) warning $r;

    if (`objExists $bdn`) delete $bdn;
  }

  // setFloatBdnAttribute / setIntBdnAttribute
  {
    catchQuiet(`loadPlugin "boneDynamicsNode"`);
    testNewScene();
    // catchQuiet(`unloadPlugin -f "boneDynamicsNode"`);

    $bdn = longNameOf(`createNode -ss "boneDynamicsNode"`);

    $r = assertFloatEqual(0.1, `getAttr ($bdn + ".damping")`, 0.001); if (`size $r`) warning $r;
    setFloatBdnAttribute({$bdn}, "damping", 0.3);
    $r = assertFloatEqual(0.3, `getAttr ($bdn + ".damping")`, 0.001); if (`size $r`) warning $r;

    $r = assertIntEqual(0, `getAttr ($bdn + ".turbulenceSeed")`); if (`size $r`) warning $r;
    setIntBdnAttribute({$bdn}, "turbulenceSeed", 4);
    $r = assertIntEqual(4, `getAttr ($bdn + ".turbulenceSeed")`); if (`size $r`) warning $r;

    if (`objExists $bdn`) delete $bdn;
  }

  // exportBdnAttributes / importBdnAttributes
  {
    catchQuiet(`loadPlugin "boneDynamicsNode"`);
    testNewScene();
    // catchQuiet(`unloadPlugin -f "boneDynamicsNode"`);

    $r = assertFalse(existsFilename($testBdnFilename)); if (`size $r`) warning $r;

    $bdn = longNameOf(`createNode -ss "boneDynamicsNode"`);

    setAttr ($bdn + ".damping") 0.9;
    setAttr ($bdn + ".elasticity") 45.0;
    setAttr ($bdn + ".elasticForceFunction") 2;
    setAttr ($bdn + ".stiffness") 0.3;
    setAttr ($bdn + ".mass") 1.5;
    setAttr ($bdn + ".gravityX") 10.0;
    setAttr ($bdn + ".gravityY") -780.0;
    setAttr ($bdn + ".gravityZ") 30.0;
    setAttr ($bdn + ".gravityMultiply") 0.2;
    setAttr ($bdn + ".additionalForceScale") 1.2;
    setAttr ($bdn + ".enableTurbulence") true;
    setAttr ($bdn + ".turbulenceSeed") 123;
    setAttr ($bdn + ".turbulenceStrength") 35.7;
    setAttr ($bdn + ".turbulenceVectorChangeScale") 1.25;
    setAttr ($bdn + ".turbulenceVectorChangeMax") 3.3;
    setAttr ($bdn + ".enableAngleLimit") true;
    setAttr ($bdn + ".angleLimit") 120.4;
    setAttr ($bdn + ".radius") 4.5;
    setAttr ($bdn + ".iterations") 3;
    setAttr ($bdn + ".enableGroundCol") true;
    setAttr ($bdn + ".groundHeight") 25.3;
    setAttr ($bdn + ".meshColCutoff") 12.8;
    $r = assertFloatEqual(0.9, `getAttr ($bdn + ".damping")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(45.0, `getAttr ($bdn + ".elasticity")`, 0.001); if (`size $r`) warning $r;
    $r = assertIntEqual(2, `getAttr ($bdn + ".elasticForceFunction")`); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.3, `getAttr ($bdn + ".stiffness")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(1.5, `getAttr ($bdn + ".mass")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(10.0, `getAttr ($bdn + ".gravityX")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(-780.0, `getAttr ($bdn + ".gravityY")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(30.0, `getAttr ($bdn + ".gravityZ")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.2, `getAttr ($bdn + ".gravityMultiply")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(1.2, `getAttr ($bdn + ".additionalForceScale")`, 0.001); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr ($bdn + ".enableTurbulence")`); if (`size $r`) warning $r;
    $r = assertIntEqual(123, `getAttr ($bdn + ".turbulenceSeed")`); if (`size $r`) warning $r;
    $r = assertFloatEqual(35.7, `getAttr ($bdn + ".turbulenceStrength")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(1.25, `getAttr ($bdn + ".turbulenceVectorChangeScale")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(3.3, `getAttr ($bdn + ".turbulenceVectorChangeMax")`, 0.001); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr ($bdn + ".enableAngleLimit")`); if (`size $r`) warning $r;
    $r = assertFloatEqual(120.4, `getAttr ($bdn + ".angleLimit")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(4.5, `getAttr ($bdn + ".radius")`, 0.001); if (`size $r`) warning $r;
    $r = assertIntEqual(3, `getAttr ($bdn + ".iterations")`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr ($bdn + ".enableGroundCol")`); if (`size $r`) warning $r;
    $r = assertFloatEqual(25.3, `getAttr ($bdn + ".groundHeight")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(12.8, `getAttr ($bdn + ".meshColCutoff")`, 0.001); if (`size $r`) warning $r;

    $expectDict = "name=\"\";enable=true;resetTime=0.0;fps=30.0;offsetMatrixWeight=1.0;damping=0.9;elasticity=45.0;elasticForceFunction=2;stiffness=0.3;mass=1.5;gravityX=10.0;gravityY=-780.0;gravityZ=30.0;gravityMultiply=0.2;additionalForceScale=1.2;enableTurbulence=true;turbulenceSeed=123;turbulenceStrength=35.7;turbulenceVectorChangeScale=1.25;turbulenceVectorChangeMax=3.3;enableAngleLimit=true;angleLimit=120.4;radius=4.5;iterations=3;enableGroundCol=true;groundHeight=25.3;meshColCutoff=12.8;";
    exportBdnAttributes({$bdn}, $testBdnFilename);
    $r = assertTrue(existsFilename($testBdnFilename)); if (`size $r`) warning $r;
    $dict = dictAddString(readAllText($testBdnFilename, ""), "name", "");
    $r = assertStringEqual($expectDict, $dict); if (`size $r`) warning $r;

    applyDictToBdnAttributes($nkBdnEditorDefaultBdnAttribute, {$bdn});
    $r = assertFloatEqual(0.1, `getAttr ($bdn + ".damping")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(30.0, `getAttr ($bdn + ".elasticity")`, 0.001); if (`size $r`) warning $r;
    $r = assertIntEqual(0, `getAttr ($bdn + ".elasticForceFunction")`); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.0, `getAttr ($bdn + ".stiffness")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(1.0, `getAttr ($bdn + ".mass")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.0, `getAttr ($bdn + ".gravityX")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(-980.0, `getAttr ($bdn + ".gravityY")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.0, `getAttr ($bdn + ".gravityZ")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.0, `getAttr ($bdn + ".gravityMultiply")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(1.0, `getAttr ($bdn + ".additionalForceScale")`, 0.001); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr ($bdn + ".enableTurbulence")`); if (`size $r`) warning $r;
    $r = assertIntEqual(0, `getAttr ($bdn + ".turbulenceSeed")`); if (`size $r`) warning $r;
    $r = assertFloatEqual(10.0, `getAttr ($bdn + ".turbulenceStrength")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.05, `getAttr ($bdn + ".turbulenceVectorChangeScale")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.1, `getAttr ($bdn + ".turbulenceVectorChangeMax")`, 0.001); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr ($bdn + ".enableAngleLimit")`); if (`size $r`) warning $r;
    $r = assertFloatEqual(60.0, `getAttr ($bdn + ".angleLimit")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.0, `getAttr ($bdn + ".radius")`, 0.001); if (`size $r`) warning $r;
    $r = assertIntEqual(5, `getAttr ($bdn + ".iterations")`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr ($bdn + ".enableGroundCol")`); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.0, `getAttr ($bdn + ".groundHeight")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(10.0, `getAttr ($bdn + ".meshColCutoff")`, 0.001); if (`size $r`) warning $r;

    importBdnAttributes({$bdn}, $testBdnFilename);
    $r = assertFloatEqual(0.9, `getAttr ($bdn + ".damping")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(45.0, `getAttr ($bdn + ".elasticity")`, 0.001); if (`size $r`) warning $r;
    $r = assertIntEqual(2, `getAttr ($bdn + ".elasticForceFunction")`); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.3, `getAttr ($bdn + ".stiffness")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(1.5, `getAttr ($bdn + ".mass")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(10.0, `getAttr ($bdn + ".gravityX")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(-780.0, `getAttr ($bdn + ".gravityY")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(30.0, `getAttr ($bdn + ".gravityZ")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.2, `getAttr ($bdn + ".gravityMultiply")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(1.2, `getAttr ($bdn + ".additionalForceScale")`, 0.001); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr ($bdn + ".enableTurbulence")`); if (`size $r`) warning $r;
    $r = assertIntEqual(123, `getAttr ($bdn + ".turbulenceSeed")`); if (`size $r`) warning $r;
    $r = assertFloatEqual(35.7, `getAttr ($bdn + ".turbulenceStrength")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(1.25, `getAttr ($bdn + ".turbulenceVectorChangeScale")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(3.3, `getAttr ($bdn + ".turbulenceVectorChangeMax")`, 0.001); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr ($bdn + ".enableAngleLimit")`); if (`size $r`) warning $r;
    $r = assertFloatEqual(120.4, `getAttr ($bdn + ".angleLimit")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(4.5, `getAttr ($bdn + ".radius")`, 0.001); if (`size $r`) warning $r;
    $r = assertIntEqual(3, `getAttr ($bdn + ".iterations")`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr ($bdn + ".enableGroundCol")`); if (`size $r`) warning $r;
    $r = assertFloatEqual(25.3, `getAttr ($bdn + ".groundHeight")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(12.8, `getAttr ($bdn + ".meshColCutoff")`, 0.001); if (`size $r`) warning $r;

    if (`objExists $bdn`) delete $bdn;
    $r = assertTrue(deleteFile($testBdnFilename)); if (`size $r`) warning $r;
    $r = assertFalse(existsFilename($testBdnFilename)); if (`size $r`) warning $r;
  }

  // copyBdnAttributes / pasteBdnAttributes
  {
    catchQuiet(`loadPlugin "boneDynamicsNode"`);
    testNewScene();
    // catchQuiet(`unloadPlugin -f "boneDynamicsNode"`);

    $nkBdnEditorBdnAttributeCache = "";
    $r = assertStringEqual("", $nkBdnEditorBdnAttributeCache); if (`size $r`) warning $r;

    $bdn = longNameOf(`createNode -ss "boneDynamicsNode"`);

    setAttr ($bdn + ".damping") 0.9;
    setAttr ($bdn + ".elasticity") 45.0;
    setAttr ($bdn + ".elasticForceFunction") 2;
    setAttr ($bdn + ".stiffness") 0.3;
    setAttr ($bdn + ".mass") 1.5;
    setAttr ($bdn + ".gravityX") 10.0;
    setAttr ($bdn + ".gravityY") -780.0;
    setAttr ($bdn + ".gravityZ") 30.0;
    setAttr ($bdn + ".gravityMultiply") 0.2;
    setAttr ($bdn + ".additionalForceScale") 1.2;
    setAttr ($bdn + ".enableTurbulence") true;
    setAttr ($bdn + ".turbulenceSeed") 123;
    setAttr ($bdn + ".turbulenceStrength") 35.7;
    setAttr ($bdn + ".turbulenceVectorChangeScale") 1.25;
    setAttr ($bdn + ".turbulenceVectorChangeMax") 3.3;
    setAttr ($bdn + ".enableAngleLimit") true;
    setAttr ($bdn + ".angleLimit") 120.4;
    setAttr ($bdn + ".radius") 4.5;
    setAttr ($bdn + ".iterations") 3;
    setAttr ($bdn + ".enableGroundCol") true;
    setAttr ($bdn + ".groundHeight") 25.3;
    setAttr ($bdn + ".meshColCutoff") 12.8;
    $r = assertFloatEqual(0.9, `getAttr ($bdn + ".damping")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(45.0, `getAttr ($bdn + ".elasticity")`, 0.001); if (`size $r`) warning $r;
    $r = assertIntEqual(2, `getAttr ($bdn + ".elasticForceFunction")`); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.3, `getAttr ($bdn + ".stiffness")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(1.5, `getAttr ($bdn + ".mass")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(10.0, `getAttr ($bdn + ".gravityX")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(-780.0, `getAttr ($bdn + ".gravityY")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(30.0, `getAttr ($bdn + ".gravityZ")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.2, `getAttr ($bdn + ".gravityMultiply")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(1.2, `getAttr ($bdn + ".additionalForceScale")`, 0.001); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr ($bdn + ".enableTurbulence")`); if (`size $r`) warning $r;
    $r = assertIntEqual(123, `getAttr ($bdn + ".turbulenceSeed")`); if (`size $r`) warning $r;
    $r = assertFloatEqual(35.7, `getAttr ($bdn + ".turbulenceStrength")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(1.25, `getAttr ($bdn + ".turbulenceVectorChangeScale")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(3.3, `getAttr ($bdn + ".turbulenceVectorChangeMax")`, 0.001); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr ($bdn + ".enableAngleLimit")`); if (`size $r`) warning $r;
    $r = assertFloatEqual(120.4, `getAttr ($bdn + ".angleLimit")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(4.5, `getAttr ($bdn + ".radius")`, 0.001); if (`size $r`) warning $r;
    $r = assertIntEqual(3, `getAttr ($bdn + ".iterations")`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr ($bdn + ".enableGroundCol")`); if (`size $r`) warning $r;
    $r = assertFloatEqual(25.3, `getAttr ($bdn + ".groundHeight")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(12.8, `getAttr ($bdn + ".meshColCutoff")`, 0.001); if (`size $r`) warning $r;

    $expectDict = "name=\"\";enable=true;resetTime=0.0;fps=30.0;offsetMatrixWeight=1.0;damping=0.9;elasticity=45.0;elasticForceFunction=2;stiffness=0.3;mass=1.5;gravityX=10.0;gravityY=-780.0;gravityZ=30.0;gravityMultiply=0.2;additionalForceScale=1.2;enableTurbulence=true;turbulenceSeed=123;turbulenceStrength=35.7;turbulenceVectorChangeScale=1.25;turbulenceVectorChangeMax=3.3;enableAngleLimit=true;angleLimit=120.4;radius=4.5;iterations=3;enableGroundCol=true;groundHeight=25.3;meshColCutoff=12.8;";
    copyBdnAttributes({$bdn});
    $dict = dictAddString($nkBdnEditorBdnAttributeCache, "name", "");
    $r = assertStringEqual($expectDict, $dict); if (`size $r`) warning $r;

    applyDictToBdnAttributes($nkBdnEditorDefaultBdnAttribute, {$bdn});
    $r = assertFloatEqual(0.1, `getAttr ($bdn + ".damping")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(30.0, `getAttr ($bdn + ".elasticity")`, 0.001); if (`size $r`) warning $r;
    $r = assertIntEqual(0, `getAttr ($bdn + ".elasticForceFunction")`); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.0, `getAttr ($bdn + ".stiffness")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(1.0, `getAttr ($bdn + ".mass")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.0, `getAttr ($bdn + ".gravityX")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(-980.0, `getAttr ($bdn + ".gravityY")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.0, `getAttr ($bdn + ".gravityZ")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.0, `getAttr ($bdn + ".gravityMultiply")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(1.0, `getAttr ($bdn + ".additionalForceScale")`, 0.001); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr ($bdn + ".enableTurbulence")`); if (`size $r`) warning $r;
    $r = assertIntEqual(0, `getAttr ($bdn + ".turbulenceSeed")`); if (`size $r`) warning $r;
    $r = assertFloatEqual(10.0, `getAttr ($bdn + ".turbulenceStrength")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.05, `getAttr ($bdn + ".turbulenceVectorChangeScale")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.1, `getAttr ($bdn + ".turbulenceVectorChangeMax")`, 0.001); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr ($bdn + ".enableAngleLimit")`); if (`size $r`) warning $r;
    $r = assertFloatEqual(60.0, `getAttr ($bdn + ".angleLimit")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.0, `getAttr ($bdn + ".radius")`, 0.001); if (`size $r`) warning $r;
    $r = assertIntEqual(5, `getAttr ($bdn + ".iterations")`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr ($bdn + ".enableGroundCol")`); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.0, `getAttr ($bdn + ".groundHeight")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(10.0, `getAttr ($bdn + ".meshColCutoff")`, 0.001); if (`size $r`) warning $r;

    pasteBdnAttributes({$bdn});
    $r = assertFloatEqual(0.9, `getAttr ($bdn + ".damping")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(45.0, `getAttr ($bdn + ".elasticity")`, 0.001); if (`size $r`) warning $r;
    $r = assertIntEqual(2, `getAttr ($bdn + ".elasticForceFunction")`); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.3, `getAttr ($bdn + ".stiffness")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(1.5, `getAttr ($bdn + ".mass")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(10.0, `getAttr ($bdn + ".gravityX")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(-780.0, `getAttr ($bdn + ".gravityY")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(30.0, `getAttr ($bdn + ".gravityZ")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.2, `getAttr ($bdn + ".gravityMultiply")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(1.2, `getAttr ($bdn + ".additionalForceScale")`, 0.001); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr ($bdn + ".enableTurbulence")`); if (`size $r`) warning $r;
    $r = assertIntEqual(123, `getAttr ($bdn + ".turbulenceSeed")`); if (`size $r`) warning $r;
    $r = assertFloatEqual(35.7, `getAttr ($bdn + ".turbulenceStrength")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(1.25, `getAttr ($bdn + ".turbulenceVectorChangeScale")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(3.3, `getAttr ($bdn + ".turbulenceVectorChangeMax")`, 0.001); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr ($bdn + ".enableAngleLimit")`); if (`size $r`) warning $r;
    $r = assertFloatEqual(120.4, `getAttr ($bdn + ".angleLimit")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(4.5, `getAttr ($bdn + ".radius")`, 0.001); if (`size $r`) warning $r;
    $r = assertIntEqual(3, `getAttr ($bdn + ".iterations")`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr ($bdn + ".enableGroundCol")`); if (`size $r`) warning $r;
    $r = assertFloatEqual(25.3, `getAttr ($bdn + ".groundHeight")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(12.8, `getAttr ($bdn + ".meshColCutoff")`, 0.001); if (`size $r`) warning $r;

    if (`objExists $bdn`) delete $bdn;
  }

  print("test4 end\n");
}

/*-
@returns <>
@remarks コライダー。
*/
proc test5() {
  print("test5 start\n");
  string $r;

  print("test5 end\n");
}

/*-
@returns <>
@remarks コライダーアトリビュート。
*/
proc test6() {
  print("test6 start\n");
  global string $nkBdnEditorDefaultCapsuleColliderAttribute;
  global string $nkBdnEditorDefaultInfinitePlaneColliderAttribute;
  global string $nkBdnEditorDefaultSphereColliderAttribute;

  global string $nkBdnEditorCapsuleColliderAttributeCache;
  global string $nkBdnEditorInfinitePlaneColliderAttributeCache;
  global string $nkBdnEditorSphereColliderAttributeCache;

  string $r;
  string $n;
  string $dict;
  string $dicts[];
  string $expectDict;

  string $mayaAppDir = `getenv "MAYA_APP_DIR"`;
  string $colliderFilename = $mayaAppDir + "/dev/nkBdnEditor/test/collider.ma";
  string $testColliderFilename = $mayaAppDir + "/dev/nkBdnEditor/test/test.collider";

  string $bdnRootNode = "|BDN_GRP";
  string $j1ccp = $bdnRootNode + "|Collider_GRP|joint1_CapsuleCollider_SPC";
  string $j1cc = $bdnRootNode + "|Collider_GRP|joint1_CapsuleCollider_SPC|joint1_CapsuleCollider";
  string $j2ccp = $bdnRootNode + "|Collider_GRP|joint2_CapsuleCollider_SPC";
  string $j2cc = $bdnRootNode + "|Collider_GRP|joint2_CapsuleCollider_SPC|joint2_CapsuleCollider";
  string $j3icp = $bdnRootNode + "|Collider_GRP|joint3_InfinitePlaneCollider_SPC";
  string $j3ic = $bdnRootNode + "|Collider_GRP|joint3_InfinitePlaneCollider_SPC|joint3_InfinitePlaneCollider";
  string $j4scp = $bdnRootNode + "|Collider_GRP|joint4_SphereCollider_SPC";
  string $j4sc = $bdnRootNode + "|Collider_GRP|joint4_SphereCollider_SPC|joint4_SphereCollider";
  string $ccp = $bdnRootNode + "|Collider_GRP|CapsuleCollider_SPC";
  string $cc = $bdnRootNode + "|Collider_GRP|CapsuleCollider_SPC|CapsuleCollider";
  string $icp = $bdnRootNode + "|Collider_GRP|InfinitePlaneCollider_SPC";
  string $ic = $bdnRootNode + "|Collider_GRP|InfinitePlaneCollider_SPC|InfinitePlaneCollider";
  string $scp = $bdnRootNode + "|Collider_GRP|SphereCollider_SPC";
  string $sc = $bdnRootNode + "|Collider_GRP|SphereCollider_SPC|SphereCollider";

  // capsuleColliderAttributesToDict / infinitePlaneColliderAttributesToDict / sphereColliderAttributesToDict
  {
    // catchQuiet(`loadPlugin "boneDynamicsNode"`);
    testOpenScene($colliderFilename);
    catchQuiet(`unloadPlugin -f "boneDynamicsNode"`);

    $dict = dictAddString(capsuleColliderAttributesToDict($ccp), "name", "");
    $r = assertStringEqual("name=\"\";", $dict); if (`size $r`) warning $r;
    $dict = dictAddString(capsuleColliderAttributesToDict($cc), "name", "");
    $r = assertStringEqual($nkBdnEditorDefaultCapsuleColliderAttribute, $dict); if (`size $r`) warning $r;

    $dict = dictAddString(infinitePlaneColliderAttributesToDict($icp), "name", "");
    $r = assertStringEqual("name=\"\";", $dict); if (`size $r`) warning $r;
    $dict = dictAddString(infinitePlaneColliderAttributesToDict($ic), "name", "");
    $r = assertStringEqual($nkBdnEditorDefaultInfinitePlaneColliderAttribute, $dict); if (`size $r`) warning $r;

    $dict = dictAddString(sphereColliderAttributesToDict($scp), "name", "");
    $r = assertStringEqual("name=\"\";", $dict); if (`size $r`) warning $r;
    $dict = dictAddString(sphereColliderAttributesToDict($sc), "name", "");
    $r = assertStringEqual($nkBdnEditorDefaultSphereColliderAttribute, $dict); if (`size $r`) warning $r;
  }

  // applyDictToCapsuleColliderAttributes / applyDictToInfinitePlaneColliderAttributes / applyDictToSphereColliderAttributes
  {
    // catchQuiet(`loadPlugin "boneDynamicsNode"`);
    testOpenScene($colliderFilename);
    catchQuiet(`unloadPlugin -f "boneDynamicsNode"`);

    // applyDictToCapsuleColliderAttributes
    setAttr ($cc + ".colliderRadiusA") 0.9;
    setAttr ($cc + ".colliderRadiusB") 0.3;
    setAttr ($cc + ".colliderLength") 1.2;
    setAttr ($cc + ".colliderOffset") -0.6;
    setAttr ($cc + ".colliderPivot") 1;
    $r = assertFloatEqual(0.9, `getAttr ($cc + ".colliderRadiusA")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.3, `getAttr ($cc + ".colliderRadiusB")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(1.2, `getAttr ($cc + ".colliderLength")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(-0.6, `getAttr ($cc + ".colliderOffset")`, 0.001); if (`size $r`) warning $r;
    $r = assertIntEqual(1, `getAttr ($cc + ".colliderPivot")`); if (`size $r`) warning $r;

    applyDictToCapsuleColliderAttributes($nkBdnEditorDefaultCapsuleColliderAttribute, {$cc}, false);
    $r = assertFloatEqual(0.5, `getAttr ($cc + ".colliderRadiusA")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.5, `getAttr ($cc + ".colliderRadiusB")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(1.2, `getAttr ($cc + ".colliderLength")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(-0.6, `getAttr ($cc + ".colliderOffset")`, 0.001); if (`size $r`) warning $r;
    $r = assertIntEqual(1, `getAttr ($cc + ".colliderPivot")`); if (`size $r`) warning $r;

    applyDictToCapsuleColliderAttributes($nkBdnEditorDefaultCapsuleColliderAttribute, {$cc}, true);
    $r = assertFloatEqual(0.5, `getAttr ($cc + ".colliderRadiusA")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.5, `getAttr ($cc + ".colliderRadiusB")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(2.0, `getAttr ($cc + ".colliderLength")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.0, `getAttr ($cc + ".colliderOffset")`, 0.001); if (`size $r`) warning $r;
    $r = assertIntEqual(0, `getAttr ($cc + ".colliderPivot")`); if (`size $r`) warning $r;

    // applyDictToInfinitePlaneColliderAttributes
    setAttr ($ic + ".colliderWidth") 1.3;
    setAttr ($ic + ".colliderHeight") 0.6;
    $r = assertFloatEqual(1.3, `getAttr ($ic + ".colliderWidth")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.6, `getAttr ($ic + ".colliderHeight")`, 0.001); if (`size $r`) warning $r;

    applyDictToInfinitePlaneColliderAttributes($nkBdnEditorDefaultInfinitePlaneColliderAttribute, {$ic});
    $r = assertFloatEqual(1.0, `getAttr ($ic + ".colliderWidth")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(1.0, `getAttr ($ic + ".colliderHeight")`, 0.001); if (`size $r`) warning $r;

    // applyDictToSphereColliderAttributes
    setAttr ($sc + ".colliderRadius") 0.9;
    $r = assertFloatEqual(0.9, `getAttr ($sc + ".colliderRadius")`, 0.001); if (`size $r`) warning $r;

    applyDictToSphereColliderAttributes($nkBdnEditorDefaultSphereColliderAttribute, {$sc});
    $r = assertFloatEqual(0.5, `getAttr ($sc + ".colliderRadius")`, 0.001); if (`size $r`) warning $r;
  }

  // setFloatColliderAttribute / setIntColliderAttribute
  {
    // catchQuiet(`loadPlugin "boneDynamicsNode"`);
    testOpenScene($colliderFilename);
    catchQuiet(`unloadPlugin -f "boneDynamicsNode"`);

    // setFloatColliderAttribute
    $r = assertFloatEqual(0.5, `getAttr ($cc + ".colliderRadiusA")`, 0.001); if (`size $r`) warning $r;
    setFloatColliderAttribute({$cc}, "colliderRadiusA", 0.3);
    $r = assertFloatEqual(0.3, `getAttr ($cc + ".colliderRadiusA")`, 0.001); if (`size $r`) warning $r;

    $r = assertFloatEqual(1.0, `getAttr ($ic + ".colliderWidth")`, 0.001); if (`size $r`) warning $r;
    setFloatColliderAttribute({$ic}, "colliderWidth", 0.3);
    $r = assertFloatEqual(0.3, `getAttr ($ic + ".colliderWidth")`, 0.001); if (`size $r`) warning $r;

    $r = assertFloatEqual(0.5, `getAttr ($sc + ".colliderRadius")`, 0.001); if (`size $r`) warning $r;
    setFloatColliderAttribute({$sc}, "colliderRadius", 0.3);
    $r = assertFloatEqual(0.3, `getAttr ($sc + ".colliderRadius")`, 0.001); if (`size $r`) warning $r;

    // setIntColliderAttribute
    $r = assertIntEqual(0, `getAttr ($cc + ".colliderPivot")`); if (`size $r`) warning $r;
    setIntColliderAttribute({$cc}, "colliderPivot", 2);
    $r = assertIntEqual(2, `getAttr ($cc + ".colliderPivot")`); if (`size $r`) warning $r;
  }

  // exportColliders / importColliders
  {
    // catchQuiet(`loadPlugin "boneDynamicsNode"`);
    testOpenScene($colliderFilename);
    catchQuiet(`unloadPlugin -f "boneDynamicsNode"`);

    $r = assertFalse(existsFilename($testColliderFilename)); if (`size $r`) warning $r;

    setAttr ($cc + ".colliderRadiusA") 0.9;
    setAttr ($cc + ".colliderRadiusB") 0.3;
    setAttr ($cc + ".colliderLength") 1.2;
    setAttr ($cc + ".colliderOffset") -0.6;
    setAttr ($cc + ".colliderPivot") 1;
    $r = assertFloatEqual(0.9, `getAttr ($cc + ".colliderRadiusA")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.3, `getAttr ($cc + ".colliderRadiusB")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(1.2, `getAttr ($cc + ".colliderLength")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(-0.6, `getAttr ($cc + ".colliderOffset")`, 0.001); if (`size $r`) warning $r;
    $r = assertIntEqual(1, `getAttr ($cc + ".colliderPivot")`); if (`size $r`) warning $r;
    setAttr ($j1cc + ".colliderRadiusA") 0.9;
    setAttr ($j1cc + ".colliderRadiusB") 0.3;
    setAttr ($j1cc + ".colliderLength") 1.2;
    setAttr ($j1cc + ".colliderOffset") -0.6;
    setAttr ($j1cc + ".colliderPivot") 1;
    $r = assertFloatEqual(0.9, `getAttr ($j1cc + ".colliderRadiusA")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.3, `getAttr ($j1cc + ".colliderRadiusB")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(1.2, `getAttr ($j1cc + ".colliderLength")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(-0.6, `getAttr ($j1cc + ".colliderOffset")`, 0.001); if (`size $r`) warning $r;
    $r = assertIntEqual(1, `getAttr ($j1cc + ".colliderPivot")`); if (`size $r`) warning $r;
    setAttr ($j2cc + ".colliderRadiusA") 0.9;
    setAttr ($j2cc + ".colliderRadiusB") 0.3;
    setAttr ($j2cc + ".colliderLength") 1.2;
    setAttr ($j2cc + ".colliderOffset") -0.6;
    setAttr ($j2cc + ".colliderPivot") 1;
    $r = assertFloatEqual(0.9, `getAttr ($j2cc + ".colliderRadiusA")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.3, `getAttr ($j2cc + ".colliderRadiusB")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(1.2, `getAttr ($j2cc + ".colliderLength")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(-0.6, `getAttr ($j2cc + ".colliderOffset")`, 0.001); if (`size $r`) warning $r;
    $r = assertIntEqual(1, `getAttr ($j2cc + ".colliderPivot")`); if (`size $r`) warning $r;

    setAttr ($ic + ".colliderWidth") 1.3;
    setAttr ($ic + ".colliderHeight") 0.6;
    $r = assertFloatEqual(1.3, `getAttr ($ic + ".colliderWidth")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.6, `getAttr ($ic + ".colliderHeight")`, 0.001); if (`size $r`) warning $r;
    setAttr ($j3ic + ".colliderWidth") 1.3;
    setAttr ($j3ic + ".colliderHeight") 0.6;
    $r = assertFloatEqual(1.3, `getAttr ($j3ic + ".colliderWidth")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.6, `getAttr ($j3ic + ".colliderHeight")`, 0.001); if (`size $r`) warning $r;

    setAttr ($sc + ".colliderRadius") 0.9;
    $r = assertFloatEqual(0.9, `getAttr ($sc + ".colliderRadius")`, 0.001); if (`size $r`) warning $r;
    setAttr ($j4sc + ".colliderRadius") 0.9;
    $r = assertFloatEqual(0.9, `getAttr ($j4sc + ".colliderRadius")`, 0.001); if (`size $r`) warning $r;

    string $expectDicts[] = {
      "name=\"\";colliderType=\"capsule\";colliderRadiusA=0.9;colliderRadiusB=0.3;colliderLength=1.2;colliderOffset=-0.6;colliderPivot=1;colliderSource=\"\";colliderAimTarget=\"\";spaceTranslate={-3.0, 0.0, -2.0};spaceRotate={0.0, 0.0, 0.0};spaceScale={1.0, 1.0, 1.0};colliderTranslate={0.0, 0.0, 0.0};colliderRotate={0.0, 0.0, 0.0};colliderScale={1.0, 1.0, 1.0};",
      "name=\"\";colliderType=\"infinitePlane\";colliderWidth=1.3;colliderHeight=0.6;colliderSource=\"\";spaceTranslate={-2.0, 0.0, 2.0};spaceRotate={0.0, 0.0, 0.0};spaceScale={1.0, 1.0, 1.0};colliderTranslate={0.0, 0.0, 0.0};colliderRotate={0.0, 0.0, 0.0};colliderScale={1.0, 1.0, 1.0};",
      "name=\"\";colliderType=\"sphere\";colliderRadius=0.9;colliderSource=\"\";spaceTranslate={0.0, 0.0, 0.0};spaceRotate={0.0, 0.0, 0.0};spaceScale={1.0, 1.0, 1.0};colliderTranslate={0.0, 0.0, 0.0};colliderRotate={0.0, 0.0, 0.0};colliderScale={1.0, 1.0, 1.0};",
      "name=\"\";colliderType=\"capsule\";colliderRadiusA=0.9;colliderRadiusB=0.3;colliderLength=1.2;colliderOffset=-0.6;colliderPivot=1;colliderSource=\"|joint1\";colliderAimTarget=\"\";spaceTranslate={0.0, 0.0, -4.0};spaceRotate={0.0, -60.0, 0.0};spaceScale={1.0, 1.0, 1.0};colliderTranslate={0.0, 0.0, 0.0};colliderRotate={20.0, 30.0, 10.0};colliderScale={1.0, 1.0, 1.0};",
      "name=\"\";colliderType=\"capsule\";colliderRadiusA=0.9;colliderRadiusB=0.3;colliderLength=1.2;colliderOffset=-0.6;colliderPivot=1;colliderSource=\"|joint1|joint2\";colliderAimTarget=\"|joint1|joint2|joint3\";spaceTranslate={2.0, 0.0, -0.5358983849};spaceRotate={0.0, 255.9637565, 0.0};spaceScale={1.0, 1.0, 1.0};colliderTranslate={0.0, 0.0, 0.0};colliderRotate={0.0, 0.0, 0.0};colliderScale={1.0, 1.0, 1.0};",
      "name=\"\";colliderType=\"infinitePlane\";colliderWidth=1.3;colliderHeight=0.6;colliderSource=\"|joint1|joint2|joint3\";spaceTranslate={1.0, 0.0, 3.464101615};spaceRotate={0.0, -150.0, 0.0};spaceScale={1.0, 1.0, 1.0};colliderTranslate={-0.05, 0.0, -1.5};colliderRotate={0.0, 0.0, 0.0};colliderScale={1.0, 1.0, 1.0};",
      "name=\"\";colliderType=\"sphere\";colliderRadius=0.9;colliderSource=\"|joint1|joint2|joint3|joint4\";spaceTranslate={-1.598076211, 0.0, 4.964101615};spaceRotate={0.0, -150.0, 0.0};spaceScale={1.0, 1.0, 1.0};colliderTranslate={0.0, 0.0, 0.0};colliderRotate={0.0, 0.0, 0.0};colliderScale={1.5, 1.5, 1.5};"
    };

    exportColliders({$cc, $ic, $sc, $j1cc, $j2cc, $j3ic, $j4sc}, $testColliderFilename);
    $r = assertTrue(existsFilename($testColliderFilename)); if (`size $r`) warning $r;
    $dicts = readAllLines($testColliderFilename, "");
    for ($i = 0; $i < `size $dicts`; $i++) {
      $dicts[$i] = dictAddString($dicts[$i], "name", "");
    }
    $r = assertStringArrayEqual($expectDicts, $dicts); if (`size $r`) warning $r;

    // catchQuiet(`loadPlugin "boneDynamicsNode"`);
    testOpenScene($colliderFilename);
    catchQuiet(`unloadPlugin -f "boneDynamicsNode"`);

    if (`objExists $bdnRootNode`) delete $bdnRootNode;
    $r = assertFalse(`objExists $j1ccp`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $j1cc`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $j2ccp`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $j2cc`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $j3icp`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $j3ic`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $j4scp`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $j4sc`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $ccp`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $cc`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $icp`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $ic`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $scp`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $sc`); if (`size $r`) warning $r;

    importColliders($testColliderFilename);
    $r = assertTrue(`objExists $j1ccp`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $j1cc`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $j2ccp`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $j2cc`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $j3icp`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $j3ic`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $j4scp`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $j4sc`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $ccp`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $cc`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $icp`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $ic`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $scp`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $sc`); if (`size $r`) warning $r;

    $r = assertFloatEqual(0.9, `getAttr ($cc + ".colliderRadiusA")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.3, `getAttr ($cc + ".colliderRadiusB")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(1.2, `getAttr ($cc + ".colliderLength")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(-0.6, `getAttr ($cc + ".colliderOffset")`, 0.001); if (`size $r`) warning $r;
    $r = assertIntEqual(1, `getAttr ($cc + ".colliderPivot")`); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.9, `getAttr ($j1cc + ".colliderRadiusA")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.3, `getAttr ($j1cc + ".colliderRadiusB")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(1.2, `getAttr ($j1cc + ".colliderLength")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(-0.6, `getAttr ($j1cc + ".colliderOffset")`, 0.001); if (`size $r`) warning $r;
    $r = assertIntEqual(1, `getAttr ($j1cc + ".colliderPivot")`); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.9, `getAttr ($j2cc + ".colliderRadiusA")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.3, `getAttr ($j2cc + ".colliderRadiusB")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(1.2, `getAttr ($j2cc + ".colliderLength")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(-0.6, `getAttr ($j2cc + ".colliderOffset")`, 0.001); if (`size $r`) warning $r;
    $r = assertIntEqual(1, `getAttr ($j2cc + ".colliderPivot")`); if (`size $r`) warning $r;

    $r = assertFloatEqual(1.3, `getAttr ($ic + ".colliderWidth")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.6, `getAttr ($ic + ".colliderHeight")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(1.3, `getAttr ($j3ic + ".colliderWidth")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.6, `getAttr ($j3ic + ".colliderHeight")`, 0.001); if (`size $r`) warning $r;

    $r = assertFloatEqual(0.9, `getAttr ($sc + ".colliderRadius")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.9, `getAttr ($j4sc + ".colliderRadius")`, 0.001); if (`size $r`) warning $r;

    $r = assertTrue(deleteFile($testColliderFilename)); if (`size $r`) warning $r;
    $r = assertFalse(existsFilename($testColliderFilename)); if (`size $r`) warning $r;
  }

  // copyCapsuleColliderAttributes / pasteCapsuleColliderAttributes
  {
    // catchQuiet(`loadPlugin "boneDynamicsNode"`);
    testOpenScene($colliderFilename);
    catchQuiet(`unloadPlugin -f "boneDynamicsNode"`);

    $nkBdnEditorCapsuleColliderAttributeCache = "";
    $r = assertStringEqual("", $nkBdnEditorCapsuleColliderAttributeCache); if (`size $r`) warning $r;

    setAttr ($cc + ".colliderRadiusA") 0.9;
    setAttr ($cc + ".colliderRadiusB") 0.3;
    setAttr ($cc + ".colliderLength") 1.2;
    setAttr ($cc + ".colliderOffset") -0.6;
    setAttr ($cc + ".colliderPivot") 1;
    $r = assertFloatEqual(0.9, `getAttr ($cc + ".colliderRadiusA")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.3, `getAttr ($cc + ".colliderRadiusB")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(1.2, `getAttr ($cc + ".colliderLength")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(-0.6, `getAttr ($cc + ".colliderOffset")`, 0.001); if (`size $r`) warning $r;
    $r = assertIntEqual(1, `getAttr ($cc + ".colliderPivot")`); if (`size $r`) warning $r;

    $expectDict = "name=\"\";colliderType=\"capsule\";colliderRadiusA=0.9;colliderRadiusB=0.3;colliderLength=1.2;colliderOffset=-0.6;colliderPivot=1;";
    copyCapsuleColliderAttributes({$cc});
    $dict = dictAddString($nkBdnEditorCapsuleColliderAttributeCache, "name", "");
    $r = assertStringEqual($expectDict, $dict); if (`size $r`) warning $r;

    applyDictToCapsuleColliderAttributes($nkBdnEditorDefaultCapsuleColliderAttribute, {$cc}, true);
    $r = assertFloatEqual(0.5, `getAttr ($cc + ".colliderRadiusA")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.5, `getAttr ($cc + ".colliderRadiusB")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(2.0, `getAttr ($cc + ".colliderLength")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.0, `getAttr ($cc + ".colliderOffset")`, 0.001); if (`size $r`) warning $r;
    $r = assertIntEqual(0, `getAttr ($cc + ".colliderPivot")`); if (`size $r`) warning $r;

    pasteCapsuleColliderAttributes({$cc}, false);
    $r = assertFloatEqual(0.9, `getAttr ($cc + ".colliderRadiusA")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.3, `getAttr ($cc + ".colliderRadiusB")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(2.0, `getAttr ($cc + ".colliderLength")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.0, `getAttr ($cc + ".colliderOffset")`, 0.001); if (`size $r`) warning $r;
    $r = assertIntEqual(0, `getAttr ($cc + ".colliderPivot")`); if (`size $r`) warning $r;

    pasteCapsuleColliderAttributes({$cc}, true);
    $r = assertFloatEqual(0.9, `getAttr ($cc + ".colliderRadiusA")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.3, `getAttr ($cc + ".colliderRadiusB")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(1.2, `getAttr ($cc + ".colliderLength")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(-0.6, `getAttr ($cc + ".colliderOffset")`, 0.001); if (`size $r`) warning $r;
    $r = assertIntEqual(1, `getAttr ($cc + ".colliderPivot")`); if (`size $r`) warning $r;
  }

  // copyInfinitePlaneColliderAttributes / pasteInfinitePlaneColliderAttributes
  {
    // catchQuiet(`loadPlugin "boneDynamicsNode"`);
    testOpenScene($colliderFilename);
    catchQuiet(`unloadPlugin -f "boneDynamicsNode"`);

    $nkBdnEditorInfinitePlaneColliderAttributeCache = "";
    $r = assertStringEqual("", $nkBdnEditorInfinitePlaneColliderAttributeCache); if (`size $r`) warning $r;

    setAttr ($ic + ".colliderWidth") 1.3;
    setAttr ($ic + ".colliderHeight") 0.6;
    $r = assertFloatEqual(1.3, `getAttr ($ic + ".colliderWidth")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.6, `getAttr ($ic + ".colliderHeight")`, 0.001); if (`size $r`) warning $r;

    $expectDict = "name=\"\";colliderType=\"infinitePlane\";colliderWidth=1.3;colliderHeight=0.6;";
    copyInfinitePlaneColliderAttributes({$ic});
    $dict = dictAddString($nkBdnEditorInfinitePlaneColliderAttributeCache, "name", "");
    $r = assertStringEqual($expectDict, $dict); if (`size $r`) warning $r;

    applyDictToInfinitePlaneColliderAttributes($nkBdnEditorDefaultInfinitePlaneColliderAttribute, {$ic});
    $r = assertFloatEqual(1.0, `getAttr ($ic + ".colliderWidth")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(1.0, `getAttr ($ic + ".colliderHeight")`, 0.001); if (`size $r`) warning $r;

    pasteInfinitePlaneColliderAttributes({$ic});
    $r = assertFloatEqual(1.3, `getAttr ($ic + ".colliderWidth")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatEqual(0.6, `getAttr ($ic + ".colliderHeight")`, 0.001); if (`size $r`) warning $r;
  }

  // copySphereColliderAttributes / pasteSphereColliderAttributes
  {
    // catchQuiet(`loadPlugin "boneDynamicsNode"`);
    testOpenScene($colliderFilename);
    catchQuiet(`unloadPlugin -f "boneDynamicsNode"`);

    $nkBdnEditorSphereColliderAttributeCache = "";
    $r = assertStringEqual("", $nkBdnEditorSphereColliderAttributeCache); if (`size $r`) warning $r;

    setAttr ($sc + ".colliderRadius") 0.9;
    $r = assertFloatEqual(0.9, `getAttr ($sc + ".colliderRadius")`, 0.001); if (`size $r`) warning $r;

    $expectDict = "name=\"\";colliderType=\"sphere\";colliderRadius=0.9;";
    copySphereColliderAttributes({$sc});
    $dict = dictAddString($nkBdnEditorSphereColliderAttributeCache, "name", "");
    $r = assertStringEqual($expectDict, $dict); if (`size $r`) warning $r;

    applyDictToSphereColliderAttributes($nkBdnEditorDefaultSphereColliderAttribute, {$sc});
    $r = assertFloatEqual(0.5, `getAttr ($sc + ".colliderRadius")`, 0.001); if (`size $r`) warning $r;

    pasteSphereColliderAttributes({$sc});
    $r = assertFloatEqual(0.9, `getAttr ($sc + ".colliderRadius")`, 0.001); if (`size $r`) warning $r;
  }

  print("test6 end\n");
}

/*-
@returns <>
@remarks
*/
proc test7() {
  print("test7 start\n");
  string $r;
  // catchQuiet(`loadPlugin "boneDynamicsNode"`);
  // catchQuiet(`unloadPlugin -f "boneDynamicsNode"`);

  print("test7 end\n");
}

/*-
@param $flags <boolean[]>
@returns <>
*/
global proc nkBdnEditorTest(int $flags[]) {
  if ($flags[0]) test0();
  if ($flags[1]) test1();
  if ($flags[2]) test2();
  if ($flags[3]) test3();
  if ($flags[4]) test4();
  if ($flags[5]) test5();
  if ($flags[6]) test6();
  // if ($flags[7]) test7();
}

/*
eval ("source \"" + `getenv "MAYA_APP_DIR"` + "/dev/nkBdnEditor/nkBdnEditor.mel\"");
nkBdnEditorTest({1, 1, 1, 1, 1, 1, 1});
*/
